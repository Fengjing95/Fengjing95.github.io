---
title:  JS中的闭包
date: {{ date }}
author: 小枫
avatar: https://cdn.jsdelivr.net/gh/fengjing95/cdn@1.2/img/custom/avatar.jpg
authorLink: 
authorAbout: 前端小白
authorDesc: 前端小白
categories: 技术
comments: true
tags: js
keywords: js, 闭包
description: 一篇文章带你了解JS闭包
photos: https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133122739.png
---
> ​    闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。

  相信你看了这段鬼话，80%会感到懵逼，看完下面的内容再回来看这句话，相信你就可以理解了。



函数的作用域

![image-20200723133332013](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133332013.png)

在全局环境中定义了title变量和show方法，当执行show方法时，开辟出一块内存，如果在show方法内部调用context是可以正常执行的，当show执行完的时候，show中定义的context变量不被保留，这时外部调用context就会 not defined。

数据的作用默认就是在函数体内

数据向下流动，只会向子级传递，不会向父级传递

![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

当show方法执行完之后，内存被释放，执行多个show方法相当于多次开辟了内存

![image-20200723133349064](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133349064.png)

如果在show方法中再定义一个head方法，再执行，此时的内存结构如图所示，head方法时show方法内部的，show执行时为head开辟一块内存；**那多次调用show方法会一直调用那一个head方法么？不是的！！！多次**调用show方法会开辟多块内存，他们之间是没有关系的。

![image-20200723133409467](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133409467.png)

这个例子更能清楚的说明，按照常理，第一次调用++n之后变成了2，但是这里第二次调用结果还是2，这就说明了两次调用创建了两次

那么怎么让n一直被使用呢，这时你应该想起来开头有一句话

> 但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。

当数据一直被使用时就会保留下来，那么怎么让他一直被使用呢？

![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

将sum方法作为返回值赋值给a，这时候，feng中的数据就会一直被使用，直到a销毁，这时候多次调用a方法，n就会累加

如果再赋值给b，这就又开辟了一块内存，与a无关n又重新开始计算，结果如下：

![image-20200723133422096](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133422096.png)

这时候你又想起了开头还有一句话：

> 每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址

![image-20200723133432044](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133432044.png)

如果在sum中在添加一个function，这样再执行两次a结果是什么呢？

![image-20200723133443346](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133443346.png)

你没有看错，其实很简单，这跟之前一样，相当于在a中开辟了两块不相关的内存，那么怎么让m累加呢？也很简单，再把show返回出去

![image-20200723133455918](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133455918.png)

这时再创建b，打印结果依旧是2 3 2 3



利用闭包选择数组区间

![image-20200723133523770](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133523770.png)

由于过滤函数一直在调用between的子函数，所以a，b也被保留了下来

闭包会造成内存泄漏

![image-20200723133551508](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133551508.png)

这段代码的意思是点击div会触发打印descript属性，因为事件处理函数是一直存在的，所以每个item在使用完成之后都会保存，而且都是不同的内存区域，对于复杂对象来说是非常浪费内存的

![image-20200723133605481](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133605481.png)

那么怎么解决闭包带来的内存泄漏呢

![image-20200723133617980](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133617980.png)

在使用完之后给item项赋空值

![image-20200723133630316](https://gitee.com/liuhao1108/picGoCDN/raw/master/img/image-20200723133630316.png)

这样就可以解决不必要的内存浪费