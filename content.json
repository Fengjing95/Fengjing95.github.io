{"meta":{"title":"前端小枫","subtitle":"","description":"","author":"小枫","url":"https://easyremember.cn"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"about/index.html","permalink":"https://easyremember.cn/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"bangumi/index.html","permalink":"https://easyremember.cn/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"client/index.html","permalink":"https://easyremember.cn/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"donate/index.html","permalink":"https://easyremember.cn/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-07-13T12:13:10.595Z","comments":false,"path":"lab/index.html","permalink":"https://easyremember.cn/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-09-04T08:55:27.099Z","comments":true,"path":"links/index.html","permalink":"https://easyremember.cn/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-07-13T12:13:10.594Z","comments":true,"path":"comment/index.html","permalink":"https://easyremember.cn/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-13T12:13:10.596Z","comments":false,"path":"music/index.html","permalink":"https://easyremember.cn/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"rss/index.html","permalink":"https://easyremember.cn/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"tags/index.html","permalink":"https://easyremember.cn/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://easyremember.cn/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"video/index.html","permalink":"https://easyremember.cn/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"webpack笔记","slug":"笔记/webpack","date":"2020-09-08T11:14:28.126Z","updated":"2020-09-08T11:16:00.057Z","comments":true,"path":"2020/09/08/笔记/webpack/","link":"","permalink":"https://easyremember.cn/2020/09/08/笔记/webpack/","excerpt":"","text":"1 简介1.1 webpack 五个核心概念1.1.1 Entry入口，指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图 1.1.2 Output输出，指示webpack打包后的资源bundles输出到哪里去，以及怎么命名 1.1.3 Loader加载器，可以让webpack能够去处理非js文件（webpack自身之理解javascript） 1.1.4 Plugins插件，可以用于执行更广范围的任务，插件的范围包括从打包优化和压缩一直到重新定义环境变量等 1.1.5 Mode模式，指示webpack使用相应模式的配置 development：能让代码本地调试运行的环境 production：能让代码优化上线的运行环境 2 webpack 初体验2.1 创建一个webpack项目 创建一个目录，初始化包管理 npm init 运行命令npm install webpack webpack-cli -D 新建src文件夹用于存放代码，新建build文件夹用于存放打包好的文件 编辑代码 运行命令（开发环境） webpack ./src/index.js -o ./build/build.js --mode=development 默认只能处理js/json文件 2.2 打包css样式资源 新建css文件style.css 在index.js中引入 import &#39;style.css&#39; 创建webpack.config.js文件来配置webpack（使用commentJS） const { resolve } = require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, // 模式，不能同时存在 // mode: &#39;production&#39; entry: &#39;./src/index.js&#39;, // 入口文件 output: { filename: &#39;built.js&#39;, // 输出文件名 path: resolve(__dirname, &#39;build&#39;) // 输出路径 }, module: { // loader配置 rules: [{ test: /\\.css$/,// css结尾的文件 use: [// 执行顺序：从右到左，从下到上，依次执行 &#39;style-loader&#39;,// 创建爱你style标签，将js中的样式资源插入，添加到head &#39;css-loader&#39;,// 将css文件变成commentjs模块加载js中，内容是字符串 ] }] }, plugins: [ // 插件配置 ], } 安装所需要的loader 运行命令 webpack 使用less、scss等预编译语法需要下载对应的loader，配置方式同上，再添加一个rule对象 2.3 打包HTML文件 安装打包html的插件 npm install html-webpack-plugin-D 在webpack.config.js中引入并添加配置 const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); ··· plugins: [ // 插件配置 // html-webpack-plugin // 功能： 创建一个空的html文件引入打包之后的所有资源 new HtmlWebpackPlugin({ // 赋值目标文件并引入打包的资源 template: &#39;./src/index.html&#39; }) ], 在创建html模板的时候不要引入资源 2.4 打包图片文件图片添加略过，只给出配置方式 module: { // loader配置 rules: [{ test: /\\.(jpg|png|gif|jpeg)$/, // 只有一个loader的时候可以直接loader+loader名 loader: &#39;url-loader&#39;,// 下载时需要下载url-loader和file-loader options: { /** * 限制大小，小于限制就会被base64处理 * 优点减少请求数量，减轻服务器压力 * 缺点图片会更大，文件请求速度会变慢 */ limit: 200 * 1024 } }] }, 如果html模板中添加了图片，添加一个额外的loader来解析 { test: /\\.html$/, loader: &#39;html-loader&#39; // 处理html中的图片 } 但是，因为url-loader默认使用es6模块化解析，而html-loader引入图片是commentjs 解析时会出现[object Module] 解决办法：关闭ur-loader的ES6解析，在url-loader的options中添加 esModule: false 2.5 打包其他资源{ exclude: /\\.(css|html|jpg|png|gif|jpeg)$/, loader: &#39;file-loader&#39; } 除了这匹配到的后缀文件之外，其他的文件用file-loader打包 2.6 使用devServer开发服务器：用来自动编译，热更新等 在内存中编译打包，不会有任何输出 运行：webpack-dev-server 运行npm install webpack-dev-server -D安装 webpack.config.js中添加配置 devServer: { contentBase: resolve(__dirname, &#39;build&#39;),// 项目构建后的路径 compress: true,// 启动gzip压缩 port: 3000,// 端口号 open: true,// 打开默认浏览器 } 运行webpack-dev-server 3 开发环境配置const { resolve } = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // mode: &#39;production&#39; entry: &#39;./src/index.js&#39;, output: { filename: &#39;built.js&#39;, path: resolve(__dirname, &#39;build&#39;) }, module: { rules: [{ test: /\\.css$/, use: [ &#39;style-loader&#39;, &#39;css-loader&#39;, ] },{ test: /\\.(jpg|png|gif|jpeg)$/, loader: &#39;url-loader&#39;, options: { limit: 200 * 1024, esModule: false } },{ test: /\\.html$/, loader: &#39;html-loader&#39; }] }, plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39; }) ], devServer: { contentBase: resolve(__dirname, &#39;build&#39;), compress: true, port: 3000, open: true, } } 4 生产环境搭建4.1 提取css成单独文件 安装插件 npm install mini-css-extract-plugin -D 修改webpack.config.js配置文件 const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); ··· module: { rules: [{ test: /\\.css$/, use: [ // &#39;style-loader&#39;, MiniCssExtractPlugin.loader,// 替换style-loader，提取css成单独文件 &#39;css-loader&#39;, ] }, ···] }, plugins: [ ··· new MiniCssExtractPlugin({ filename: &#39;css/style.css&#39; }) ], 运行打包命令 4.2 css兼容性处理使用到postcss 运行 npm install postcss-loader postcss-preset-env -D 修改webpack.config.js的css相关部分配置 { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, { loader: &#39;postcss-loader&#39;, options: { ident: &#39;postcss&#39;, plugins: () =&gt; [ require(&#39;postcss-preset-env&#39;)() ] } } ] } 在package.json中添加浏览器版本控制 &quot;browerslist&quot;: { &quot;development&quot;: [ &quot;last 1 chrome version&quot;, &quot;last 1 firefox version&quot;, &quot;last 1 safair version&quot; ], &quot;production&quot;: [ &quot;&gt;0.2%&quot;, &quot;not dead&quot;, &quot;not op_mini all&quot; ] } 运行打包 4.3 压缩css使用插件 optimize-css-assets-webpack-plugin 运行npm install optimize-css-assets-webpack-plugin -D webpack.config.js中引入 const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;); ··· plugins: [ ··· new OptimizeCssAssetsWebpackPlugin() ] 4.4 js语法检查使用eslint，使用airbnb规则检查js语法 运行 npm install eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import -D安装所需的依赖和插件 在package.json中设置eslintConfig，继承airbnb &quot;eslintConfig&quot;: { &quot;extends&quot;: &quot;airbnb-base&quot; } webpack.config.js中添加rules { test: /\\.js$/, exclude: /node_modules/,// 只检查自己的代码，不检查第三方库中的代码 loader: &#39;eslint-loader&#39;, options: { fix: true// 自动修复eslint错误 } } 使用 // eslint-disable-next-line控制下一行不进行检查 4.5 js兼容性处理使用babel-loader进行兼容性处理 运行 npm install babel-loader @babel/core @babel/preset-env @babel/polyfill -D 添加webpack.config.js的rules { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;] } }, @babel/polyfill属于高级语法支持，在需要兼容的js文件中引入即可 import ‘@babel/polyfill’ @babel/polyfill属于暴力支持，回事打包文件变的非常大，所以一般采用按需加载的方式：core.js 运行 npm install corejs -D 修改之前的兼容性配置规则 { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, options: { presets: [ [ &#39;@babel/preset-env&#39;, { useBuiltIns: &#39;usage&#39;,// 按需加载 corejs: { version: 3 }, targets: {// 制定兼容浏览器版本 chrome: &#39;60&#39;, firefox: &#39;50&#39;, ie: &#39;9&#39;, safari: &#39;10&#39; } } ] ] } }, 4.6 HTML和js压缩4.6.1 js压缩将模式调整为production即可实现js代码压缩 4.6.2 HTML压缩在html的插件中添加设置 new HtmlWebpackPlugin({ // 复制目标文件并引入打包的资源 template: &#39;./src/index.html&#39;, minify: { // 移除空格 collapseWhitespace: true, // 移除注释 removeComments: true } }), 5 生产环境配置const { resolve } = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;); module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;js/built.js&#39;, path: resolve(__dirname, &#39;build&#39;) }, module: { // loader配置 rules: [{ test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, { loader: &#39;postcss-loader&#39;, options: { ident: &#39;postcss&#39;, plugins: () =&gt; [ require(&#39;postcss-preset-env&#39;)() ] } } ] }, { test: /\\.(jpg|png|gif|jpeg)$/, loader: &#39;url-loader&#39;, options: { limit: 200 * 1024, esModule: false } }, { test: /\\.html$/, loader: &#39;html-loader&#39; }, { test: /\\.js$/, exclude: /node_modules/, enforce: &#39;pre&#39;,// 优先执行 loader: &#39;eslint-loader&#39;, options: { fix: true } }, { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, options: { presets: [ [ &#39;@babel/preset-env&#39;, { useBuiltIns: &#39;usage&#39;, corejs: { version: 3 }, targets: { chrome: &#39;60&#39;, firefox: &#39;50&#39;, ie: &#39;9&#39;, safari: &#39;10&#39; } } ] ] } }, ] }, plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, minify: { collapseWhitespace: true, removeComments: true } }), new MiniCssExtractPlugin({ filename: &#39;css/style.css&#39; }), new OptimizeCssAssetsWebpackPlugin() ], devServer: { contentBase: resolve(__dirname, &#39;build&#39;), compress: true, port: 3000, open: true, }, // mode: &#39;development&#39;, mode: &#39;production&#39;, } babel和eslint可能会产生冲突使用enforce: ‘pre’让eslint先执行 6 性能优化篇6.1 开发环境性能优化6.1.1 优化打包构建速度6.1.1.1HMR——hot module replacement（模块热替换）只会重新打包这一个模块，不会重新打包 配置devServer devServer: { contentBase: resolve(__dirname, &#39;build&#39;), compress: true, // 启动gzip压缩 port: 3000, // 端口号 open: true, // 打开默认浏览器 hot: true,// 开启热更新 }, 样式文件热更新基于’style-loader’； js文件默认不能使用HMR功能； HTML文件默认不能使用HMR功能，同时会导致问题，HTML文件不能热更新，解决办法：修改entry入口，将html文件引入（不需要做HMR） 6.1.1.2 oneOf减少loader检索每个文件在检索的的时候会每个rules都验证一遍，将所有的rules都放到oneOf中就可以验证到所在的规则不再继续验证 这样出现了问题，js可能会有多个loader，解决办法：oneOf中保留一条rule，其他的取出来与oneOf平级 6.1.2 优化代码调试source-map：提供语言代码构建后代码映射技术（构建代码出错，追踪源代码错误） 添加devtool devtool: &#39;source-map&#39;, [inline- |hidden- | eval-][nosources-][cheap-[module-]]source-map分别对应： inline-内联：（汇集在一起）错误代码准确信息和源代码错误位置 hidden-外部：代码错误原因，没有错误位置，不能追踪代码错误 eval-内联：（分别跟每个文件对应）错误代码准确信息和源代码错误位置（位置信息是哈希值） nosources-外部：错误代码准确信息，没有源代码错误信息 cheap-外部：错误代码准确信息和源代码错误位置（只精确到行，提示整行错误） cheap-module-外部：错误代码准确信息和源代码错误位置 source-map`外部：错误代码准确信息和源代码错误位置： 模式使用 开发环境：速度快，开发更友好 速度快eval&gt;inline&gt;cheap&gt;··· eval-cheap-source-map eval-source-map 调试更友好 source-map cheap-module-source-map cheap-source-map –&gt;eval-source-map / eval-cheap-module-source-map 生产环境：源代码要不要隐藏 内联会让代码体积变大，使用外部方式 source-map ··· 隐藏代码 nosource-source-map// 全部隐藏 hidden-source-map// 隐藏源代码 –&gt;source-map / cheap-module-source-map 6.2生产环境性能优化缓存机制babel缓存修改js打包配置，开启缓存 { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, options: { presets: [ [ &#39;@babel/preset-env&#39;, { useBuiltIns: &#39;usage&#39;, // 按需加载 corejs: { version: 3 }, targets: { // 制定兼容浏览器版本 chrome: &#39;60&#39;, firefox: &#39;50&#39;, ie: &#39;9&#39;, safari: &#39;10&#39; } } ] ], cacheDirectory: true// 开启缓存 } }, 强缓存模式，所有的数据都要缓存，从新打包之后不会试用新的文件 文件资源缓存hash这里修改输出文件名，每次到打包之后的文件都不一样，这就不加绝了强制缓存带来的不刷新了（取10位hash值） output: { filename: &#39;js/built[hash:10].js&#39;, // 输出文件名 path: resolve(__dirname, &#39;build&#39;) // 输出路径 }, 所有的js和css文件共用一个哈希值，重新打包会导致所有的缓存失效 chunkhash根据chunk生成的hash值，如果打包源来自同一个chunk，那么hash值相同 此时，js和css的hash值还是相同，因为css是在js中引入的，同属于一个chunk contenthash根据文件内容生成hash，不同文件hash值一定不一样 filename: &#39;js/built[contenthash:10].js&#39; 如果单独提取了css，css命名修改为 new MiniCssExtractPlugin({ filename: &#39;css/style-[contenthash:10].css&#39; }) tree shaking去除无用代码 必须使用ES6模块化 开启production环境 打包是会自动摇去没有用的叶子 在package.json中配置&quot;sideEffects&quot;: false所有代码都没有副作用 ​ 问题：可能会把css文件干掉，解决&quot;sideEffects&quot;: [&quot;*.css&quot;] code split文件分割 多入口文件分割 添加webpack.config.js配置项，将node中的代码单独打包一个chunks，自动分析多入口文件中有没有公共文件，如果有会单独打包成一个chunk optimization: { splitChunks: { chunks: &#39;all&#39; } }, 通过js代码，让某个文件单独打包成一个chunk 懒加载、预加载懒加载document.getElementById(&#39;btn&#39;).onclick = function() { import(/* webpackChunkName: &#39;test&#39;*/&#39;./js/test.js&#39;) .then(({mul}) =&gt; { console.log(mul(4, 5)); }) } 将引入放在事件的回调函数中，事件触发时才加载js文件 配合eslint语法检查是有问题的，在.eslintrc文件汇总设置 &quot;allowImportExportEverywher&quot;: true，允许在任何地方import 预加载将引入改为 import(/* webpackChunkName: &#39;test&#39;, webpackPrefetch: true */&#39;./js/test.js&#39;) 预加载会提前将js文件加载 区别 懒加载：文件需要才加载 预加载：使用之前加载，浏览器空闲再加载（兼容性较差） 正常加载：并行加载 PWA渐进式网络开发应用程序（离线可访问） ​ workbox–&gt;workbox-webpack-plugin 运行 npm install workbox-webpack-plugin -D 修改webpack.config.js配置 const WorkboxWebpackPlugin = require(&#39;workbox-webpack-plugin&#39;); ··· plugin: [ ··· new WorkboxWebpackPlugin.GenerateSW({ clientsClaim: true, skipWaiting: true }) ] 帮助serviceworker快速启动；删除旧的serviceworker 在入口文件中注册serviceworker，处理兼容 if(&#39;serviceWorker&#39; in navigator) { window.addEventListener(&#39;load&#39;, () =&gt; { navigator.serviceWorker.register(&#39;./service-worker.js&#39;) .then(() =&gt; { console.log(&#39;sw注册成功&#39;) }).catch(() =&gt; { console.log(&#39;sw注册失败&#39;) }) }) } eslint不识别window，navigator等全局变量，修改package.json配置 &quot;eslintConfig&quot;: { &quot;extends&quot;: &quot;airbnb-base&quot;, &quot;env&quot;: { &quot;browser&quot;: true// 支持浏览器全局变量 } } 构建代码 多进程打包消耗时间长的才需要多进程打包，多进程开始需要时间，进程通信也需要时间 运行npm install thread-loader -D 修改webpack.config.js中babel所在的rule { test: /\\.js$/, exclude: /node_modules/, use: [ { loader: &#39;thread-loader&#39;,// 多进程打包 options: { workers: 2,// 使用两个进程 } }, { loader: &#39;babel-loader&#39;, ··· } ] }, externals忽略某些包，比如CDN引入的 在webpack.config.js第一级目录下添加 externals: { // 包名： npm库名 jquery: &#39;jQuery&#39; } dll 新建一个配置文件，例如 webpack.dll.js const {resolve} = require(&#39;path&#39;); const webpack = require(&#39;webpack&#39;); module.exports = { entry: { // [name]: 要打包的库名 jquery: [&#39;jquery&#39;] }, output: { filename: &#39;[name].js&#39;, path: resolve(__dirname, &#39;dll&#39;), library: &#39;[name]_[hash]&#39;// 打包库里暴露的内容叫什么名 }, plugins: [ // 打包生成一个映射关系 new webpack.DllPlugin({ name: &#39;[name]_[hash]&#39;,// 映射库暴露的内容名称 path: resolve(__dirname, &#39;dll/manifast.json&#39;)// 输出文件路径 }) ], mode: &#39;production&#39; } 运行命令 webpack --config webpack.dll.js 运行 npm install add-asset-html-webpack-plugin -D 修改webpack.config.js配置 const webpack = require(&#39;webpack&#39;); const AddAssetHtmlWebpackPlugin = require(&#39;add-asset-html-webpack-plugin&#39;); ··· plugins: [ ··· // 告诉webpack那些文件不需要打包，以及映射关系 new webpack.DllReferencePlugin({ manifest: resolve(__dirname, &#39;dll/manifest&#39;) }), // 将文件打包输出，并在html自动引入该文件 new AddAssetHtmlWebpackPlugin({ filepath: resolve(__dirname, &#39;dll/&#39;) }) ]","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"pug模板渲染","slug":"笔记/pug模板渲染","date":"2020-09-08T01:04:47.328Z","updated":"2020-09-08T01:07:07.883Z","comments":true,"path":"2020/09/08/笔记/pug模板渲染/","link":"","permalink":"https://easyremember.cn/2020/09/08/笔记/pug模板渲染/","excerpt":"","text":"开始 pug由jade改名而来，通过缩进（表示标签间的嵌套关系）的方式来编写代码的过程，在编译的过程中，不需要考虑标签是否闭合的问题。可以加快写代码速度，也为代码复用提供了便捷。 编译pug模板需要安装npm包 $ npm install pug 新建pug模板 div p #{name}今年#{age}岁了 通过js解析pug模板，需要引入pug模块 const pug = require(&#39;pug&#39;); const compiledFunction = pug.compileFile(&#39;template.pug&#39;); console.log(compiledFunction({ name: &#39;张三&#39;, age: 14, })); console.log(compiledFunction({ name: &#39;李四&#39;, age: 25, })); 使用node运行js文件，结果如图 也可以将解析和渲染放在一起，但是这样会对性能造成影响，这个问题可以通过缓存解决 console.log(pug.renderFile(&#39;template.pug&#39;, { name: &#39;王五&#39;, age: 30, })); 语法注释使用//可以转义生成html注释；使用//-表示pug内部的注释，不转义；条件注释直接写，&lt;开头的会被当作文本 属性用逗号作为属性分隔符，不加也可（可以使用JavaScript表达式）；当属性有很多时可以分多行 div(class=&#39;pug-style&#39; id=&#39;div-1&#39;) - var isTrue = true p(class=isTrue ? &#39;success&#39; : &#39;faild&#39;) #{name}今年#{age}岁了 当属姓名中含有一些可能会产生语法冲突的字符时，使用&quot;&quot;、&#39;&#39;将这些属性名包裹起来，或者使用逗号将前后属性分隔开 属性可以使用JavaScript语法嵌入，例如： - var url = &#39;www.baidu.com&#39; a(href=&#39;http://&#39; + url) 如果运行环境支持ES6，可以使用模板字符串${} 使用!=可以不转义（不推荐，很危险，会遭到脚本攻击） true和false的使用 //- 默认为true input(type=&#39;checkbox&#39; checked) input(type=&#39;checkbox&#39; checked=true) //- fasle不变异 input(type=&#39;checkbox&#39; checked=false) //- toString保留true的值 input(type=&#39;checkbox&#39; checked=true.toString()) //- 编译结果如下 &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot;/&gt; 如果声明doctype html缩写样式checked就不会映射属性 行内样式使用{}，类属性使用[]可以嵌入 a(style={color: &#39;red&#39;, &#39;background-color&#39;: &#39;#409eff&#39;}) - var classes = [&#39;test&#39;, &#39;test2&#39;] a(class=[&#39;blue-div&#39;, &#39;big-div&#39;], class=classes) 属性名有短横线连接的，属性名需要加引号，否则可能会出错 字面值 a.button = &lt;a id=&quot;main-link&quot;&gt;&lt;/a&gt; .content = &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;（div过于常见，可以省略） a#main-link = &lt;a id=&quot;main-link&quot;&gt;&lt;/a&gt; #content = &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; 使用&amp;attributes可以将一个对象追加到属性列表中（有一定的危险性，减少使用） 分支条件类C语言中都会有switch这个语法，pug中使用case表示 pug中在没有遇到非空语句之前会一直执行下去，当不想传递分支时使用- break来中断分支传递 循环使用for控制循环 -for (var i = 0; i &lt; 5; i++) li item //- 输出 &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; 通过each控制循环 - var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] each item in arr li= item //- 输出 &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; 另外，可以用while控制循环 使用=可以转义代码，等号换行或者行内紧贴父标签；使用!=可以不转义输出，比如携带标点符号等 条件使用if可以进行条件判断 - var user = {name: &#39;张三&#39;} - var isTrue = false div if isTrue h2.blue 描述 else if user h2.green 描述 p.des= user.name else h2.red 描述 //- 输出 &lt;div&gt; &lt;h2 class=&quot;green&quot;&gt;描述&lt;/h2&gt; &lt;p class=&quot;des&quot;&gt;张三&lt;/p&gt; &lt;/div&gt; unless等价于!= 包含使用include关键字引入外部文本，可以是pug文件，也可以是js文件等 被包含的文件的路径，如果是一个绝对路径（如 include /root.pug），那么前面会加上 options.basedir 选项属性来进行解析。否则，路径应该相对于正在被编译的当前文件 嵌入 #{}转义，可以添加正确的任意JavaScript表达式。 如果需要#{}文本，可以使用\\或者#{}来转义 使用!{}不转义，具有一定的危险性 使用#[]转义pug语句 *混入这是pug很强大的一个功能，类似于函数编程，可以传参 mixin eat(food) li 中午吃#{food} ul +eat(&#39;炸鸡&#39;) +eat(&#39;烤鸭&#39;) //- 输出 &lt;ul&gt; &lt;li&gt;中午吃炸鸡&lt;/li&gt; &lt;li&gt;中午吃烤鸭&lt;/li&gt; &lt;/ul&gt; 也可以把代码块传入，类似于Vue的插槽，通过block接收传进来的代码块 mixin user(name) .user h2 #{name} if block block else p 没有详细资料 +user(&#39;张三&#39;) +user(&#39;张三&#39;) p age: 14 p address: china //- 输出 &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;张三&lt;/h2&gt; &lt;p&gt;没有详细资料&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;张三&lt;/h2&gt; &lt;p&gt;age: 14&lt;/p&gt; &lt;p&gt;address: china&lt;/p&gt; &lt;/div&gt; 可以传入属性，在引用混入的时候传入属性 mixin link(href, name) a(class!=attributes.class, href=href) name //- 使用!=防止二次转义 +link(&#39;www.baidu.com&#39;, &#39;百度&#39;)(class=&quot;button&quot;) //- 输出 &lt;a class=&quot;button&quot; href=&quot;www.baidu.com&quot;&gt;name&lt;/a&gt; 支持ES6的展开运算符 mixin ulArr(className, ...items) ul(class=className) each item in items li= item else li 没有内容 +ulArr(&#39;ulArr&#39;, 1,2,3,4) 结束，又一门新技能最后推荐一个在线转换HTML和pug的网站","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Android笔记","slug":"笔记/Android笔记","date":"2020-09-07T12:09:01.520Z","updated":"2020-09-07T12:11:32.797Z","comments":true,"path":"2020/09/07/笔记/Android笔记/","link":"","permalink":"https://easyremember.cn/2020/09/07/笔记/Android笔记/","excerpt":"","text":"Android笔记 xml中的各种字符串数据建议放在values目录下的string.xml中 &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;HelloWorld&lt;/string&gt; &lt;/resources&gt; 1. 活动1.1 创建活动在包下右键创建新的活动 1.2 创建并加载布局在资源目录下的layout文件夹下右键创建新的布局资源（Android Studio默认创建） 配置好布局之后在活动类下添加布局 public class List extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_list); } 1.3在活动中使用ToastToast是安卓应用中一种比较常用的提示方式 添加方法也比较简单 Toast.makeText(this, &quot;click add&quot;, Toast.LENGTH_SHORT).show(); makeText方法参数： this：上下文，如果嵌套太深this指向会错误，可改为当前活动.this、getContext()，也可以在外层定义一个Context that = this;用来传递this “click add”：字符串，Toast要显示的信息，可以是变量 Toast.LENGTH.SHORT：显示时间2秒，LONG是3.5秒 show()方法不要忘记添加 1.4在活动中使用menu在res下创建menu目录，新建xml文件，内容格式如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;Add&quot;/&gt; &lt;item android:id=&quot;@+id/sub_item&quot; android:title=&quot;Sub&quot;/&gt; &lt;/menu&gt; 在要添加menu的活动中添加菜单，格式如下 @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return super.onCreateOptionsMenu(menu); } @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { Context that = this; switch (item.getItemId()) { case R.id.add_item: Toast.makeText(that, &quot;click add&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.sub_item: Toast.makeText(this, &quot;click sub&quot;, Toast.LENGTH_SHORT).show(); break; default: break; } return super.onOptionsItemSelected(item); } 1.5在活动之间穿梭一个安卓应用通常不止一个活动，需要在不同的活动之间来回穿梭来完成各种操作 1.5.1显式穿梭顾名思义，显示穿梭很明显能看出要跳转到那个活动 在页面中有一个按钮，点击按钮触发切换活动的事件 Button btn_third = (Button) findViewById(R.id.btn_third); btn_third.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent3 = new Intent(MainActivity.this, List.class); startActivity(intent3); } }); 先给button添加事件监听，当触发时间时，使用Intent穿梭事件 Intent构造函数： MainActivity.this：上下文 List.class：要跳转的活动（反射） 活动需要在Mainfest中注册，这些在创建活动时Android Studio默认添加了，如果没有会报错 1.5.2隐式穿梭隐式穿梭不会很容易看出要跳转的目的、 首先，隐式穿梭需要配置Mainfest &lt;activity android:name=&quot;.List&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.hello.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;com.example.hello.MY_CATEGORY&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 然后在跳转时使用另一种方式 Button btn_third = (Button) findViewById(R.id.btn_third); btn_third.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent3 = new Intent(&quot;com.example.hello.MAIN&quot;); // 只使用了android.intent.category.DEFAULT，这里可以不添加category,如果自定义了category就必须要添加 intent3.addCategory(&quot;com.example.hello.MY_CATEGORY&quot;); startActivity(intent3); } }); 配置时注意action和category的包路径，只有action和category一致才会进行跳转 更多隐式穿梭用法 跳转网页 点击事件如下 Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;)); startActivity(intent); 在Mainfest对应事件中添加data标签 &lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter tools:ignore=&quot;AppLinkUrlError&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;http&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 拨打电话 1.5.3 活动之间传递数据在许多情况下，活动之间切换需要携带数据，Intent提供了putExtra方法来传递数据，在MainActivity中通过按钮触发事件，携带参数跳转到SecondActivity Button btn = (Button) findViewById(R.id.button1); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, SecondActivity.class); intent.putExtra(&quot;extra_value1&quot;, 10); intent.putExtra(&quot;extra_value2&quot;, &quot;by first&quot;); startActivityForResult(intent, 1); } }); startActivityForResult(intent, 1);不同的请求通过请求码进行区分 在SecondActivity中接收参数并显示到页面上 final Intent intent = getIntent(); String str = intent.getStringExtra(&quot;extra_value2&quot;); int i = intent.getIntExtra(&quot;extra_value1&quot;, -1); // int类型的数据接收时可以设置默认值 String string = str + i; TextView textView = (TextView) findViewById(R.id.textView); textView.setText(string); 1.5.4向上一个活动返回数据当然，SecondActivity也可以向MainActivity传递数据 @Override public void onBackPressed() { // super.onBackPressed(); Intent intent1 = new Intent(); intent1.putExtra(&quot;data_return&quot;, &quot;I am second&quot;); setResult(RESULT_OK, intent1); finish(); } 当按下返回键时（可以通过其他事件触发），向主页面传递数据，这里要设置result返回的状态 在主活动中接收SecondActivity传回来的数据 @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode) { case 1: if (resultCode == RESULT_OK) { assert data != null; String returnStr = data.getStringExtra(&quot;data_return&quot;); Toast.makeText(this, returnStr, Toast.LENGTH_SHORT).show(); } break; default: break; } } onActivityResult(requestCode, resultCode, data) requestCode：请求码，在发送请求时携带的code resultCode：响应码，活动返回数据时设置的code data：接收的数据 1.6 活动的生命周期 1.7 活动的启动模式参考活动的启动模式 2. UI组件相关省略 2.1 布局2.1.1 线性布局LinearLayout android:layout_width=&quot;match_parent&quot;控制宽度，父组件的宽度，改为 wrap_content就是自身元素的宽度 android:layout_height=&quot;match_parent&quot;控制高度 android:orientation=&quot;vertical&quot;控制纵向排列，如果改为 vertical就会变为水平排列 android:layout_gravity=&quot;right&quot;控制元素的对齐方式 android:layout_weight=&quot;1&quot;类似于css中的flex：1 2.1.2 相对布局RelativeLayout相对于parent进行定位 android:layout_alignParentLeft=”true” android:layout_alignParentright=”true” android:layout_alignParentTop=”true” android:layout_alignParentBottom=”true” android:layout_centerInParent=”true” 相对于控件进行定位 android:layout_above=”@id/button3”上 android:layout_below=”@id/button3”下 android:layout_toLeftOf=”@id/button3” android:layout_toRightOf=”@id/button3” android:layout_alignBottom=”@id/button3”两个控件底边对齐 alignBottom、alignTop、alignLeft、alignRight 2.1.3帧布局FrameLayout2.1.4 百分比布局由Android X支持库提供 导入支持库 搜索percentLayout，添加依赖 然后布局文件中使用百分比布局 &lt;androidx.percentlayout.widget.PercentFrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;right&quot; app:layout_widthPercent=&quot;50%&quot; android:src=&quot;@drawable/wj&quot; tools:ignore=&quot;RtlHardcoded&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_close&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; app:layout_widthPercent=&quot;50%&quot; android:text=&quot;关闭&quot; /&gt; &lt;/LinearLayout&gt; &lt;/androidx.percentlayout.widget.PercentFrameLayout&gt; 2.2 控件2.2.1 创建自定义控件首先新建控件的title.xml布局 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;Button android:id=&quot;@+id/back_btn_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#409eff&quot; android:text=&quot;返回&quot; /&gt; &lt;TextView android:id=&quot;@+id/title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#409eff&quot; android:layout_weight=&quot;1&quot; android:text=&quot;TextView&quot; /&gt; &lt;Button android:id=&quot;@+id/edit_btn_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#409eff&quot; android:text=&quot;菜单&quot; /&gt; &lt;/LinearLayout&gt; 然后在想要引入title的布局中引入&lt;include layout=&quot;@layout/title&quot; /&gt;即可 但是这样给title控件添加事件的时候需要给每一个活动都添加，太过于繁琐 于是有了简便的方法 public class TitleLayout extends LinearLayout { public TitleLayout(Context context, @Nullable AttributeSet attrs) { super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title, this); Button back_btn = (Button)findViewById(R.id.back_btn_title); Button edit_btn = (Button)findViewById(R.id.edit_btn_title); back_btn.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { ((Activity)getContext()).finish(); } }); edit_btn.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { Toast.makeText(getContext(), &quot;click edit&quot;, Toast.LENGTH_SHORT).show(); } }); } } 然后在想要引入控件的活动xml中使用包名引入 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;com.example.helloworld.TitleLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;/LinearLayout&gt; 2.2.2 ListView列表控件首先创建ListView布局 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;ListView android:id=&quot;@+id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 然后在活动中添加 public class List extends AppCompatActivity { private String[] data = {&quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;fire&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;fire&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;fire&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;fire&quot;}; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_list); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(List.this, android.R.layout.simple_list_item_1, data); ListView listView = (ListView) findViewById(R.id.list); listView.setAdapter(adapter); } } 定制ListView 图标 新建一个菜单类，属性是名称和图标 public class Fruit { private String name; private int imageId; public Fruit(String name, int imageId) { this.name = name; this.imageId = imageId; } public String getName() { return name; } public int getImageId() { return imageId; } } 新建list选项布局 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; /&gt; &lt;/LinearLayout&gt; 新建适配器继承自ArrayAdapter public class FruitAdapter extends ArrayAdapter { private int resourceId; public FruitAdapter(@NonNull Context context, int resource, @NonNull List&lt;Fruit&gt; objects) { super(context, resource, objects); resourceId = resource; } @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) { Fruit fruit = (Fruit) getItem(position); @SuppressLint(&quot;ViewHolder&quot;) View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; } } 最后再修改List活动 public class FruitList extends AppCompatActivity { private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_list); addData(); FruitAdapter fruitAdapter = new FruitAdapter(FruitList.this, R.layout.fruit_item, fruitList); ListView listView = (ListView)findViewById(R.id.list); listView.setAdapter(fruitAdapter); } // 初始化list private void addData() { for(int i = 0; i &lt; 10; i++) { Fruit apple = new Fruit(&quot;apple&quot;, R.drawable.icon); fruitList.add(apple); } } } 然后运行出来的List就带上了图标 点击事件 在List活动中添加事件监听 listView.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { Fruit fruit = fruitList.get(position); Toast.makeText(FruitList.this, fruit.getName(), Toast.LENGTH_SHORT).show(); } }); 优化 public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) { Fruit fruit = (Fruit) getItem(position); // @SuppressLint(&quot;ViewHolder&quot;) View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); View view; if(convertView == null) { view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); } else { view = convertView; } ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; } 对convertView进行判断，当为空时使用LayoutInflater加载布局，不为空时直接使用convertView，提高了运行效率 public class FruitAdapter extends ArrayAdapter { private int resourceId; public FruitAdapter(@NonNull Context context, int resource, @NonNull List&lt;Fruit&gt; objects) { super(context, resource, objects); resourceId = resource; } @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) { Fruit fruit = (Fruit) getItem(position); // @SuppressLint(&quot;ViewHolder&quot;) View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); View view; ViewHolder viewHolder; if(convertView == null) { view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView)view.findViewById(R.id.fruit_image); viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_name); view.setTag(viewHolder); } else { view = convertView; viewHolder = (ViewHolder) view.getTag(); } viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; } class ViewHolder { ImageView fruitImage; TextView fruitName; } } 修改FruitAdapter，新建内部类，对控件实例进行缓存，新建实例时通过setTag方法将实例存储，convertView不为空时使用getTag获取缓存的实例 2.2.3 RecycleView3. 碎片碎片可以有效解决手机平板分辨率不同产生的布局难看的问题，当屏幕分辨率大的时候引入两个碎片 3.1 碎片使用创建碎片 设置好碎片布局之后在活动的xml布局中引入fragment，选择要引入的碎片，调整布局 效果如图 3.2 动态使用碎片再创建一个新的右侧碎片 修改当前活动 public class MainActivity2 extends AppCompatActivity implements View.OnClickListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Button button = (Button)findViewById(R.id.left_btn); button.setOnClickListener(this); replaceFragment(new FragmentRight()); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.left_btn: replaceFragment(new FragmentAnotherRight()); break; default: break; } } public void replaceFragment(Fragment fragment) { FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.right_layout, fragment); fragmentTransaction.commit(); } } 活动创建时初始化一个右侧碎片，当左侧按钮触发时更换一个右侧碎片 3.3 返回栈实现了动态添加碎片之后还有一个问题，当点击返回按钮时会直接退出活动，要返回上一个碎片就需要添加一个返回栈 只需要修改replaceFragment方法，调用addToBackStack方法，一般传入null即可 public void replaceFragment(Fragment fragment) { FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.right_layout, fragment); fragmentTransaction.addToBackStack(null); fragmentTransaction.commit(); } 3.4 碎片通信 3.5 碎片生命周期 3.6 使用限定符响应式布局在res目录下新建layout-large或者layout-sw600dp文件夹，新建一个同名的活动布局，当满足条件时，安卓会自动加载相应的布局 普通的布局只有一个fragment大屏设备的引入两个fragment 手机模拟器 平板模拟器 4. 广播机制4.1 简介 标准广播：异步执行，所有的广播接收器会在同一时间接收到广播消息，不能被截断 有序广播：同步执行，只有一个接收器能接受广播消息，接收完才能依次执行，可以被截断 4.2 接收广播4.2.1 动态注册广播接收器可以动态的对自己感兴趣的广播进行注册，可以在代码中注册也可以在AndroidMainfest中注册，前者称为动态注册，后者称为静态注册 4.2.1.1 动态注册监听网络变化在代码中进行注册 public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private NetworkChangeReceiver changeReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ActivityController.addActivity(this); // 广播 intentFilter = new IntentFilter(); intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); changeReceiver = new NetworkChangeReceiver(); registerReceiver(changeReceiver, intentFilter); } @Override public void onDestroy() { super.onDestroy(); unregisterReceiver(changeReceiver); } } public class NetworkChangeReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { ConnectivityManager connectivityManager = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo(); if(networkInfo != null &amp;&amp; networkInfo.isConnected()) { Toast.makeText(context, &quot;网络已连接&quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(context, &quot;网络未连接&quot;, Toast.LENGTH_SHORT).show(); } } } connectivityManager.getActiveNetworkInfo();需要添加权限，Android Studio可以自动添加 当网络连接发生变化时会弹出Toast进行消息提示 4.2.2 静态注册开机自启 new -&gt; other -&gt; Broadcast Recriver 在AndroidMainfest.xml中添加代码 &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; ··· &lt;application&gt; ··· &lt;receiver android:name=&quot;.BootCompleteReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt; 4.3 发送自定义广播4.3.1 标准广播新建一个广播接收器，并静态注册，这里的action是自定义的不再是系统服务 在活动中通过按钮发送广播并携带数据 Button btn_receiver = (Button)findViewById(R.id.btn_receiver); btn_receiver.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(&quot;com.example.helloworld.MY_RECEIVER&quot;); intent.putExtra(&quot;my_blog&quot;, &quot;test&quot;); sendBroadcast(intent); } }); 在接收器中接收数据并显示 public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String msg = intent.getStringExtra(&quot;my_blog&quot;); Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); } } 4.3.2 有序广播4.4 本地广播全局系统的广播存在安全隐患容易被其他程序截获，本地广播只能在程序内部进行传递，提高安全性 导入第三方依赖LocalBroadcastManager 新建本地广播接收器 在活动中动态注册接收器，并添加事件发送广播 `javapublic class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private LocalBroadcastManager localBroadcastManager; private LocalReceiver localReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ActivityController.addActivity(this); intentFilter = new IntentFilter(); localBroadcastManager = LocalBroadcastManager.getInstance(this); intentFilter.addAction(&quot;com.example.helloworld.LOCAL_BROADCAST&quot;); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); Button btn_local = (Button)findViewById(R.id.btn_local); btn_local.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(&quot;com.example.helloworld.LOCAL_BROADCAST&quot;); intent.putExtra(&quot;my_blog&quot;, &quot;test local&quot;); localBroadcastManager.sendBroadcast(intent); } }); } @Override public void onDestroy() { super.onDestroy(); localBroadcastManager.unregisterReceiver(localReceiver); } } &gt; 本地广播只能动态注册 ### 4.5 最佳实践——强制下线 + 创建广播接收器接收强制下线广播 + 接收器添加提示框提示强制下线 + 关闭所有活动，通过ActivityController + 重启登陆活动 ## 5. 数据持久化 ### 5.1 文件存储 新建一个文件操作活动，在布局文件中添加一个`EditText` ```xml &lt;EditText android:id=&quot;@+id/file_edit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:hint=&quot;edit in here&quot; /&gt; 5.1.1 将数据存储到文件在活动中添加代码，编写保存文件的方法并且在活动销毁时触发保存事件 public class FileActivity extends AppCompatActivity { private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_file); editText = (EditText)findViewById(R.id.file_edit); } @Override protected void onDestroy() { super.onDestroy(); String input = editText.getText().toString(); save(input); } public void save(String inputText) { FileOutputStream fileOutputStream = null; BufferedWriter bufferedWriter = null; try { fileOutputStream = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); bufferedWriter = new BufferedWriter(new OutputStreamWriter(fileOutputStream)); bufferedWriter.write(inputText); } catch (IOException e) { e.printStackTrace(); } finally { if(bufferedWriter != null) { try { bufferedWriter.close(); Toast.makeText(FileActivity.this, &quot;saved success&quot;, Toast.LENGTH_SHORT).show(); } catch (IOException e) { e.printStackTrace(); } } } } } 5.1.2 从文件中读取数据在活动中增加加载方法，活动创建时先读取文件，有文件直接加载 public class FileActivity extends AppCompatActivity { private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_file); editText = (EditText)findViewById(R.id.file_edit); String text = load(); if(!TextUtils.isEmpty(text)) { editText.setText(text); editText.setSelection(text.length()); Toast.makeText(FileActivity.this, &quot;loading success&quot;, Toast.LENGTH_SHORT).show(); } } ··· public String load() { FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try { in = openFileInput(&quot;data&quot;); reader = new BufferedReader(new InputStreamReader(in)); String line = &quot;&quot;; while((line = reader.readLine()) != null) { content.append(line); } } catch (IOException e) { e.printStackTrace(); } finally { if(reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } return content.toString(); } } 5.2 SharedPreferences存储存储文件是xml格式 首先创建一个活动，布局中添加两个按钮，一个save一个load 5.2.1将数据存储到SharedPreferences中首先需要获取SharedPreferences对象，Android中提供了三种方式获取SharedPreferences对象 Context类中的getSharedPreferences()方法，两个参数：指定SharedPreferences文件名；指定操作模式，目前只有MODE_PRIVATE可选 Activity类中getPreferences()方法：只有一个参数：操作模式。（默认当前活动名为SharedPreferences文件名） PreferenceManager类中getDefaultSharedPreferences()方法：静态方法，接收一个Context参数，使用当前包名为前缀来命名SharedPreferences文件 SharedPreferences.Editor editor = getSharedPreferences(&quot;data_preference&quot;, MODE_PRIVATE).edit(); editor.putString(&quot;name&quot;, &quot;Tom&quot;); editor.putInt(&quot;age&quot;, 20); editor.putBoolean(&quot;married&quot;, false); editor.apply(); 5.2.2从SharedPreferences中读取数据从上面可以看出SharedPreferences存储文件非常简单，读取文件更为简便，从SharedPreferences对象中一系列get方法即可获得数据 SharedPreferences editor_load = getSharedPreferences(&quot;data_preference&quot;, MODE_PRIVATE); String name = editor_load.getString(&quot;name&quot;, &quot;&quot;); int age = editor_load.getInt(&quot;age&quot;, 0); Boolean married = editor_load.getBoolean(&quot;married&quot;, false); 5.2.3 代码及效果展示public class PreferencesActivity extends AppCompatActivity implements View.OnClickListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_preferences); Button btn_save = (Button)findViewById(R.id.btn_preference_save); btn_save.setOnClickListener(this); Button btn_load = (Button)findViewById(R.id.btn_preference_load); btn_load.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn_preference_save: SharedPreferences.Editor editor = getSharedPreferences(&quot;data_preference&quot;, MODE_PRIVATE).edit(); editor.putString(&quot;name&quot;, &quot;Tom&quot;); editor.putInt(&quot;age&quot;, 20); editor.putBoolean(&quot;married&quot;, false); editor.apply(); Toast.makeText(PreferencesActivity.this, &quot;file save succeed&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.btn_preference_load: SharedPreferences editor_load = getSharedPreferences(&quot;data_preference&quot;, MODE_PRIVATE); String name = editor_load.getString(&quot;name&quot;, &quot;&quot;); int age = editor_load.getInt(&quot;age&quot;, 0); Boolean married = editor_load.getBoolean(&quot;married&quot;, false); String marry = married?&quot;结婚了&quot;:&quot;没结婚&quot;; Toast.makeText(PreferencesActivity.this, name+&quot;今年&quot;+age+&quot;岁&quot;+marry, Toast.LENGTH_SHORT).show(); break; default: break; } } } 5.3 数据库SQLiteSQLite是一款轻量级关系数据库，支持SQL语法，遵循ACID 5.3.1 创建数据库略 5.3.2 LitePal操作数据库通过JavaBean操作数据库 引入依赖LitePal 配置xml映射app.src.main目录下新建assets目录，新建litepal.xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;litepal&gt; &lt;dbname value=&quot;BookStore&quot; /&gt; &lt;version value=&quot;1&quot; /&gt; &lt;list&gt;&lt;/list&gt; &lt;/litepal&gt; 修改Mainfest，application新加属性android:name=&quot;org.litepal.LitePalApplication&quot; 创建数据库创建JavaBean 添加活动代码，当数据库访问一次之后就创建了 对数据进行操作需要让JavaBean继承DataSupport 添加数据 更新数据一种方法是将要修改的数据值全部set然后save在set要修改的值再次save 另一种方法用updateAll book.setPrice(14.5); book.updateAll(&quot;name = ? and author = ?&quot;, &quot;Tom&quot;,&quot;第一行代码&quot;); 设置要修改的价格，然后使用updateAll方法，方法中的参数是约束条件，当当与where查询，只修改匹配到的信息 删除数据使用DataSupport中的deleteAll方法，第一个参数是眼删除的表名，第二个参数是查询条件 DataSupport.deleteAll(Book.class, &quot;price &lt; ?&quot;, &quot;14&quot;); 查询数据使用 List&lt;Book&gt; list = DataSupport.findAll(Book.class);可以将所有的数据返回到一个List中 此外，还支持原生查询 Cursor cursor = DataSupport.findBySQL(&quot;select * from book where name = ?&quot;, &quot;第一行代码&quot;); 返回的是一个Cuesor对象，需要将数据一一取出 6. 跨程序共享数据——内容提供器6.1 运行时权限安卓6.0以上加入了运行时权限，危险权限需要用户授权 参考代码 public class PermissionActivity extends AppCompatActivity { List&lt;String&gt; contacts = new ArrayList&lt;&gt;(); ArrayAdapter&lt;String&gt; adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission); ListView list = (ListView) findViewById(R.id.list_contact); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, contacts); list.setAdapter(adapter); if (ContextCompat.checkSelfPermission(PermissionActivity.this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(PermissionActivity.this, new String[]{Manifest.permission.READ_CONTACTS}, 1); } else { readContacts(); } } private void readContacts() { Cursor cursor = null; try { cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); if(cursor != null) { while (cursor.moveToNext()) { String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); contacts.add(name+ &quot;\\n&quot; +number); } adapter.notifyDataSetChanged(); } } catch (Exception e) { e.printStackTrace(); } finally { if(cursor != null) { cursor.close(); } } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { readContacts(); } else { Toast.makeText(PermissionActivity.this, &quot;no permission&quot;, Toast.LENGTH_SHORT).show(); } break; default: break; } } } 6.2 创建内容提供器7. 运用手机多媒体7.1 使用通知首先获取通知管理器对象，然后创建通知对象，通过通知管理器下发通知，每个通知的id都是不同的 代码示例通过按钮触发通知 Button btn_notification = (Button)findViewById(R.id.btn_notification); btn_notification.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); Notification notification = new Notification.Builder(PermissionActivity.this) .setContentTitle(&quot;1条新消息&quot;) .setContentText(&quot;XXX请求添加好友&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .build(); manager.notify(1, notification); } }); 这里可以看到按钮点击之后通知栏显示了一条通知 但是，这里的通知不能点击，要再让它可以点击 这时需要用到PendingIntent，可以理解为延时的Intent 将代码稍作改装，就得到了可以点击的通知 Button btn_notification = (Button)findViewById(R.id.btn_notification); btn_notification.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(PermissionActivity.this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(PermissionActivity.this, 0, intent, 0); NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); Notification notification = new Notification.Builder(PermissionActivity.this) .setContentTitle(&quot;1条新消息&quot;) .setContentText(&quot;XXX请求添加好友&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pendingIntent) .build(); manager.notify(1, notification); } }); 距离完成还差一步，点击通知之后通知应该是消失的 有两种方法： 通知追加setAutoCancel方法 ··· .setAutoCancel(true) 通过通知管理器的canael方法根据通知id消除通知 ··· NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); manager.cancel(1) 长文本通知 .setStyle(new Notification.BigTextStyle().bigText(&quot;* 当URL没有指定文件名时(比如：https://www.w3schools.com/css/)，&quot; + &quot;服务器将返回默认的文件名，&quot; + &quot;通用的默认文件名是：index.html、index.htm、default.html、和default.html\\n&quot; + &quot;* 但如果你的服务器仅配置了“index.html”作为默认文件名，那么你的文件就必须命名index.html，不能用index.htm\\n&quot; + &quot;* 不过服务器可以配置多个默认的文件名，所以你可以根据需要设置多个默认文件名\\n&quot; + &quot;* 总而言之，HTML文件的完整扩展名是.html，我们没有理由不用它啊~~~&quot;)) 图片通知： .setStyle(new Notification.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.wj))) 7.2 调用摄像头和相册8. 网络8.1 webView应用程序内引入网页，不需要打开系统浏览器 创建活动，布局添加webview组件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.WebActivity&quot;&gt; &lt;WebView android:id=&quot;@+id/web_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 编辑活动代码 public class WebActivity extends AppCompatActivity { @SuppressLint(&quot;SetJavaScriptEnabled&quot;) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_web); WebView webView = (WebView)findViewById(R.id.web_view); // 设置允许js，否则网页逻辑可能无法运行 webView.getSettings().setJavaScriptEnabled(true); webView.setWebViewClient(new WebViewClient()); webView.loadUrl(&quot;http://www.baidu.com&quot;); } } 该活动需要网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 8.2 HTTP协议访问网络8.2.1 HttpURLConnection安卓上发送HTTP请求有两种方式HttpURLConnection和HttpClient，由于HttpClientd的API数量多，扩展困难已经在6.0被移除 创建布局 &lt;Button android:id=&quot;@+id/btn_http&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;HTTP请求&quot; /&gt; &lt;TextView android:id=&quot;@+id/text_http&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 编辑活动代码 public class WebActivity extends AppCompatActivity { TextView responseText; @SuppressLint(&quot;SetJavaScriptEnabled&quot;) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_web); Button sentRequest = (Button)findViewById(R.id.btn_http); responseText = (TextView)findViewById(R.id.text_http); sentRequest.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { sendRequestWithHttpURLConnection(); } }); } private void sendRequestWithHttpURLConnection() { new Thread(new Runnable() { @Override public void run() { // 创建HttpURLConnection对象 HttpURLConnection connection = null; BufferedReader reader = null; try { // URL URL url = new URL(&quot;http://www.baidu.com&quot;); connection = (HttpURLConnection)url.openConnection();// 建立连接 connection.setRequestMethod(&quot;GET&quot;);// 请求方式 connection.setConnectTimeout(8000);// 超时时间 connection.setReadTimeout(8000); InputStream in = connection.getInputStream(); // 获取输入流 reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { response.append(line); } showResponse(response.toString()); } catch (Exception e) { e.printStackTrace(); } finally { // 完成后需要关闭连接 if(reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } if(connection != null) { connection.disconnect(); } } } }).start(); } private void showResponse(final String response) { runOnUiThread(new Runnable() { @Override public void run() { responseText.setText(response); } }); } } 耗时的操作不能再主线程中进行，开一个线程处理； new Thread().start; 不要忽略start 更新UI不能在子线程中，会闪退，通过runOnUiThread切换回主线程 POST请求 connection.setRequestMethod(&quot;POST&quot;);// 请求方式 DataOutputStream out = new DataOutputStream(connection.getOutputStream()); out.writeBytes(&quot;name=Tom&amp;password=123456&quot;); 在获取输入流之前把要提交的数据写入 8.2.2 使用OKHttp在AndroidX中添加依赖okhttp（squareup公司的） 添加新的方法使用OkHttp，把button的绑定事件改为sendRequestWithOkHttp private void sendRequestWithOkHttp() { new Thread(new Runnable() { @Override public void run() { try { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(&quot;http://www.baidu.com&quot;).build(); Response response = client.newCall(request).execute(); String responseData = Objects.requireNonNull(response.body()).string(); showResponse(responseData); } catch (Exception e) { e.printStackTrace(); } } }).start(); } 就可以看到跟原来一样的效果 8.3 解析XML数据进行网络传输通常有两种格式XML和JSON 课本P334 8.4 解析JSON数据 使用GSON 添加依赖gson 可以把JSON的格式映射成一个对象 8.5 网络方法封装将网络方法封装到HttpUtil类中，方法作为静态方法直接调用 如 public class HttpUtil { public static void sendGetRequestWithOkHttp(String address, okhttp3.Callback callback) { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); } } 调用 private void sendRequestWithOkHttp() { new Thread(new Runnable() { @Override public void run() { HttpUtil.sendGetRequestWithOkHttp(&quot;http://www.baidu.com&quot;, new okhttp3.Callback() { @Override public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException { String responseData = Objects.requireNonNull(response.body()).string(); showResponse(responseData); } @Override public void onFailure(@NotNull Call call, @NotNull IOException e) { e.printStackTrace(); } }); } }).start(); }","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/tags/笔记/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Vue中的跨域问题","slug":"技术/Vue中的跨域问题","date":"2020-09-07T10:08:59.597Z","updated":"2020-09-07T11:12:50.343Z","comments":true,"path":"2020/09/07/技术/Vue中的跨域问题/","link":"","permalink":"https://easyremember.cn/2020/09/07/技术/Vue中的跨域问题/","excerpt":"","text":"Vue中的跨域问题什么是跨域？跨域问题其实就是浏览器的同源策略所导致的。 「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 MDN 什么是同源呢？ 协议+域名+端口，三者一致认为是同源 例如： http://www.baidu.com:8080和http://www.baidu.com:8081二者端口不一样，跨域 http://www.jingdong.com和http://www.baidu.com二者域名不一样，跨域 https://www.baidu.com和http://www.baidu.com二者协议端口都不一样，跨域（https://默认端口443，http://默认端口80） http://www.baidu.com/a.js和http://www.baidu.com/b.js，这两者是同源的 怎么解决跨域 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 加粗为常用，jsonp基本过时，了解一下原理 JSONP在发送Ajax请求时，不论请求的资源是何种类型都通不过同源策略，但是！！！你会发现&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;等没有这种限制。然后，js是支持json的，那么把json数据放到js中就可以接收了。废话少说上代码 &lt;!--本地请求--&gt; &lt;script&gt; var local = function(data) { console.log(&#39;请求到的数据是：&#39;, data); } &lt;/script&gt; &lt;script src=&quot;/js/jsonp.js&quot;&gt;&lt;/script&gt;&lt;!--可以是请求接口--&gt; &lt;!--服务器（js）--&gt; local(&#39;data from jsonp!&#39;) 然后运行页面 完事，这就是jsonp，jquery的ajax中也提供了jsonp的请求方式，缺陷只能发送GET请求 CORS普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 Vue跨域解决在vue.config.js中配置跨域，注释已经很清楚了吧，不懂可以QQ，微信，电邮问我 module.exports = { devServer: { host: &quot;localhost&quot;, port: 8000, // 端口号 https: false, // 是否https open: true, //配置自动启动浏览器 // proxy: &#39;http://127.0.0.1:8080&#39; // 配置跨域处理,只有一个代理 // 配置多个代理 proxy: { &#39;/socket.io&#39;: { target: &#39;http://127.0.0.1:7001/&#39;, // 要访问的接口 ws: true, // 是否启用websockets changeOrigin: true, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite: { &#39;^/api&#39;: &#39;&#39; //在请求中用&#39;/api&#39;代替target里面的地址,比如我要调用&#39;http://40.00.100.100:3002/user/add&#39;，直接写&#39;/api/user/add&#39;即可 } }, } } };","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Socket.IO前端后端一起拿捏","slug":"技术/Socket.IO前端后端一起拿捏","date":"2020-09-07T09:17:53.747Z","updated":"2020-09-08T11:08:21.502Z","comments":true,"path":"2020/09/07/技术/Socket.IO前端后端一起拿捏/","link":"","permalink":"https://easyremember.cn/2020/09/07/技术/Socket.IO前端后端一起拿捏/","excerpt":"","text":"Socket.IO前端后端一起拿捏后端——Egg 环境搭建后端socket使用Egg的周边——egg-socket.io 安装运行命令安装 $ npm i egg-socket.io --save 配置在plugin中开启插件 io: { enable: true, package: &#39;egg-socket.io&#39;, }, 在config中配置插件相关信息 // socket config.io = { // init: { wsEngine: &#39;uws&#39; }, init: {}, // 默认ws namespace: { // 命名空间 &#39;/&#39;: { connectionMiddleware: [ &#39;connection&#39; ], // 连接中间件 packetMiddleware: [ &#39;filter&#39; ], // 数据包中间件 }, }, }; 目录结构 编码首先把刚才配置文件中的两个中间件编写完成 connection.ts import { Context } from &#39;egg&#39;; // 这个中间件的作用是提示用户连接与断开的，连接成功的消息发送到客户端，断开连接的消息在服务端打印 export default function connection(): any { return async (ctx: Context, next: () =&gt; Promise &lt; any &gt;) =&gt; { ctx.socket.emit(&#39;res&#39;, &#39;connected!&#39;); await next(); // execute when disconnect. console.log(&#39;disconnection!&#39;); }; } filter.ts import { Context } from &#39;egg&#39;; // 这个中间件的作用是将接收到的数据再发送给客户端 export default function filter(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { ctx.socket.emit(&#39;res&#39;, &#39;packet received!&#39;); console.log(&#39;packet:&#39;, ctx.packet); await next(); }; } 然后配置路由，通过路由分发给controller处理 import { Application } from &#39;egg&#39;; export default (app: Application) =&gt; { const { controller, router, middleware, io } = app; io.route(&#39;chat&#39;, io.controller.chat.index); // 这里需要注意route的两个参数，第一个参数要与第二个参数controller的文件名一致 // 如果配置中有其他的命名空间‘/othername’，路由配置方法如下 // io.of(&#39;/othername&#39;).route(&#39;default&#39;, io.controller.default.index); }; 注意，因为egg-socket.io中没有.d.ts，所以io会挂载不到app上，在下面的目录下添加代码即可 添加代码如下 import { Socket, Server } from &#39;socket.io&#39;; declare module &#39;egg&#39; { export interface Application { io: Serverr &amp; EggSocketIO &amp; Namespace; } export interface Context { socket: Socket } interface EggSocketIO { middleware: xxx; controller: xxx; } interface Namespace { route(event: string, handler: Function): any } } 然后就是controller的代码了 import { Controller } from &#39;egg&#39;; export default class ChatController extends Controller { public async index() { const { ctx } = this; const message = ctx.args[0]; ctx.socket.emit(&#39;res&#39;, `Hi! I&#39;ve got your message: ${message}`); // 这里可以调用service，只是示例就不搞辣么复杂了 } } /* // 在controller 中 // 发送给自己 this.socket.emit(&#39;eventName&#39;, &#39;value&#39;); // 发送给除了自己外的所有人 this.socket.broadcast.emit(&#39;eventName&#39;, &#39;value&#39;); // 发送给所有人，包括自己 this.server.sockets.emit(&#39;eventName&#39;, &#39;value&#39;); */ 测试代码写完然后使用socket.io-client测试一下连接（需要使用npm安装， npm install socket.io-client –save） // eslint-disable-next-line @typescript-eslint/no-var-requires const socket = require(&#39;socket.io-client&#39;)(&#39;http://127.0.0.1:7001/&#39;); socket.on(&#39;connect&#39;, () =&gt; { console.log(&#39;connect!&#39;); socket.emit(&#39;chat&#39;, &#39;hello world!&#39;); }); socket.on(&#39;res&#39;, msg =&gt; { console.log(&#39;res from server: %s!&#39;, msg); }); 然后node ./client.js 客户端运行结果如下 服务端结果如下（关闭服务端时触发中间件，打印了disconnection） 试了很多办法，一直没法用ws访问连接，只能通过socket.io-client跑通 代码代码已经上传码云#socket 前端——Vue 前端使用vue-socket.io，这其实是对socket.io-client的封装，然后挂载到Vue实例 使用也是很简单，安装npm包 $ npm install vue-socket.io --save 然后配置main.js，将组件挂载到Vue实例 import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; import router from &#39;./router&#39; import store from &#39;./store&#39; import VueSocketIO from &#39;vue-socket.io&#39; Vue.config.productionTip = false Vue.use(new VueSocketIO({ debug: false, // 生产环境关闭 connection: &#39;http://127.0.0.1:7001&#39;, vuex: { // store, // actionPrefix: &#39;SOCKET_&#39;, // mutationPrefix: &#39;SOCKET_&#39; }, // options: { path: &quot;/my-app/&quot; } })) new Vue({ router, store, render: h =&gt; h(App) }).$mount(&#39;#app&#39;) 然后新建一个page，这里只加了一个简单的按钮来触发事件 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;sendMessageToServer&quot;&gt;send&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg: &#39;&#39; } }, sockets: { connect: function () { console.log(&#39;连接成功&#39;); }, res: function (val) { console.log(&#39;接收到服务端消息:&#39;, val); }, }, methods: { sendMessageToServer: function() { this.$socket.emit(&#39;chat&#39;, &#39;test111&#39;); // 第一个参数决定了调用后端的哪个socket路由 } } } &lt;/script&gt; &lt;style lang=&quot;less&quot; scoped&gt; &lt;/style&gt; 然后运行项目，查看效果 实战先来看效果 东西就这么个东西，感觉没啥好说的，直接上代码吧，传送门 主要记一下过程中遇到的问题 给输入框添加回车事件时，第三方框架中不可以直接用`@keyup.enter，而是要用@keyup.enter.native` 后端在往前端发送消息时使用的主题是什么，前端就用什么主题接收，比如","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Vue插槽组件","slug":"技术/Vue组件之slot插槽","date":"2020-08-30T08:09:24.323Z","updated":"2020-09-05T09:34:39.830Z","comments":true,"path":"2020/08/30/技术/Vue组件之slot插槽/","link":"","permalink":"https://easyremember.cn/2020/08/30/技术/Vue组件之slot插槽/","excerpt":"","text":"Vue组件之slot插槽 vue里提供了一种将父组件的内容和子组件的模板整合的方法：内容分发，通过slot插槽来实现。 匿名插槽父组件使用子组件时，在子组件标签内部编写内容，子组件内部可以使用来接收传入的内容，插槽可以设置默认内容，当无内容传入时使用默认内容 &lt;!-- SlotTest.vue --&gt; &lt;template&gt; &lt;div&gt; 下面是solt接收到的值： &lt;slot&gt;default data&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 在父组件中直接使用子组件，没有传入数据 &lt;template&gt; &lt;div&gt; &lt;slot-test&gt; &lt;!-- data from father --&gt; &lt;/slot-test&gt; &lt;/div&gt; &lt;/template&gt; 可以看到渲染子组件的时候使用了默认值 然后将子组件中加入数据，子组件中渲染了父组件中传入的数据 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 意思是：通过这种方式传递的参数（data=”slot data”），只能在子组件中访问到（通过props接收），父组件中是访问不到的 具名插槽当组件中需要多个插槽时，使用匿名插槽会非常不方便 标签有一个name属性，用来定义额外插槽，具名插槽中的内容使用标签包裹，声明v-slot:name，配对的内容放置到相应的插槽内部，其余内容放置到默认插槽中 &lt;!-- father --&gt; &lt;template&gt; &lt;div&gt; &lt;slot-test&gt; 这里 &lt;template v-slot:first&gt; 第一个插槽 &lt;/template&gt; &lt;template v-slot:second&gt; 第二个插槽 &lt;/template&gt; 其余内容全部放到默认插槽 &lt;/slot-test&gt; &lt;/div&gt; &lt;/template&gt; &lt;!-- son --&gt; &lt;template&gt; &lt;div&gt; 下面是solt接收到的值： 1. &lt;slot name=&quot;first&quot;&gt;default data&lt;/slot&gt; 2. &lt;slot name=&quot;second&quot;&gt;default data&lt;/slot&gt; 3. &lt;slot&gt;default data&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 来看一下眼效果，很清晰明了。任何没有被包裹在带有 v-slot 的 &lt;template&gt; 中的内容都会被视为默认插槽的内容，相当于 作用域插槽当我们想在父组件中访问子组件内部的一些数据时，就需要在子组件内部的元素上动态绑定一个自定义属性，将数据传递到自定义属性上，通过slot传递给父组件使用 代码示例 &lt;!-- 子组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;slot name=&quot;user&quot; v-bind:user=&quot;user&quot;&gt; &lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { user: { name: &#39;张三&#39;, age: 15 } } }, } &lt;/script&gt; &lt;!-- 父组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;slot-test&gt; &lt;template v-slot:user=&quot;slotProps&quot;&gt; {{slotProps.user.name}}今年{{slotProps.user.age}}岁。 &lt;/template&gt; &lt;/slot-test&gt; &lt;/div&gt; &lt;/template&gt; 当独占默认插槽时可以简写为（不可以和具名插槽混用） &lt;slot-test v-slot=&quot;slotProps&quot;&gt; {{slotProps.user.name}}今年{{slotProps.user.age}}岁。 &lt;/slot-test&gt; 更多用法","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"小爱课程表使用手册","slug":"生活/小爱课程表使用文档——山东工商学院-SDTBU","date":"2020-08-28T11:08:09.118Z","updated":"2020-09-05T09:34:18.364Z","comments":true,"path":"2020/08/28/生活/小爱课程表使用文档——山东工商学院-SDTBU/","link":"","permalink":"https://easyremember.cn/2020/08/28/生活/小爱课程表使用文档——山东工商学院-SDTBU/","excerpt":"","text":"小爱课程表使用手册——山东工商学院-SDTBU 注意：需要小米手机或者非小米手机安装小爱同学非小米手机可能会有部分功能无法使用 效果展示 正式步骤1. 打开小爱课表 控制中心下拉打开小爱捷径（没有可以在编辑中加入），小爱捷径找到课程表捷径 唤醒小爱同学语音助手，告诉她“课程表” 2. 设置打开小爱课程表设置，将一天上课节数调整为10（4-4-2） 3. 选择学校需要提前连接校园网 打开小爱课程表右上角设置，下拉找到选择学校 输入山东工商学院，选项中找到并点击【山东工商学院-SDTBU】 点击教务网站导入 4. 导入课表 点击教务管理系统学生端，登录智慧山商 登录之后点击学期课表 打开要添加的学期课表之后点击屏幕下方一键导入 PS：如果没绑定手机号可能会让你绑定手机，点击取消之后进入的是那个绿色的智慧山商，这时候要退出到小爱课表的设置界面，再点导入键重新进入，一定要是图上的页面才可以导入 PPS：当前周数不对可以在设置中调整 5. 反馈如果信息导入成功点击一个完美支持一下，如果存在导入失败或存在使用问题加Q反馈，点击这里加Q","categories":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/categories/工具/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://easyremember.cn/tags/悦读/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/categories/工具/"}]},{"title":"对比call和apply","slug":"技术/call和apply","date":"2020-08-27T14:47:40.917Z","updated":"2020-09-09T02:55:14.055Z","comments":true,"path":"2020/08/27/技术/call和apply/","link":"","permalink":"https://easyremember.cn/2020/08/27/技术/call和apply/","excerpt":"","text":"call&amp;apply&amp;bindcallcall方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数 语法function.call(thisArg, arg1, arg2, ...) 参数 thisArg：在 function 函数运行时使用的 this 值 arg1, arg2, …：参数列表 示例function fullName() { return this.firstName + this.lastName } function Person(first, last) { this.firstName = first this.lastName = last } var p = new Person(&#39;zhang&#39;, &#39;san&#39;) var p2 = new Person(&#39;li&#39;, &#39;si&#39;) console.log(fullName.call(p)); console.log(fullName.call(p2)); 首先实例化两个Person对象，然后将两个对象实例传给fullName.call() 可以看到控制台已经打印出了两个实例的信息 再来看一下带参数的，这是与apply方法的区别之处 var obj = { name: &#39;张三&#39;, age: 19, func: function (from, to) { console.log(this.name + &#39;今年&#39; + this.age + &#39;,从&#39; + from + &#39;来，要到&#39; + to + &#39;去&#39;); } } obj.func(&#39;北京&#39;, &#39;上海&#39;) var p = { name: &#39;李四&#39;, age: 25 } obj.func.call(p, &#39;天津&#39;, &#39;南京&#39;) apply调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数 语法func.apply(thisArg, [argsArray]) 参数 thisArg：在 function 函数运行时使用的 this 值 [argsArray]：数组或者类数组对象，数组元素将作为单独的参数传给 func 函数 apply方法与call方法的区别就在此处，call接收参数列表，apply接收数组 示例仍然使用call中的主要代码，更容易看出区别 var obj = { name: &#39;张三&#39;, age: 19, func: function (from, to) { console.log(this.name + &#39;今年&#39; + this.age + &#39;,从&#39; + from + &#39;来，要到&#39; + to + &#39;去&#39;); } } obj.func(&#39;北京&#39;, &#39;上海&#39;) var p = { name: &#39;李四&#39;, age: 25 } obj.func.apply(p, [&#39;喀什&#39;, &#39;连云港&#39;]) bind创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数 语法function.bind(thisArg[, arg1[, arg2[, ...]]]) 参数 thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用 new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … （可选）当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。 示例function func(a, b, c) { return a + b + c; } var newFunc = func.bind(null, 10) console.log(newFunc(20, 30)); 将 10 作为默认的第一个参数，只需要传入两个参数即可，传多个参数只会取前两个 function Person(name, age) { this.name = name; this.age = age; } var _Person = Person.bind({}); var p = new _Person(&#39;zhangsan&#39;, 30); // Person {name: &quot;zhangsan&quot;, age: 30} 还可以用来复制对象","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Axios","slug":"笔记/Axios","date":"2020-08-27T04:14:58.150Z","updated":"2020-09-05T09:35:51.229Z","comments":true,"path":"2020/08/27/笔记/Axios/","link":"","permalink":"https://easyremember.cn/2020/08/27/笔记/Axios/","excerpt":"","text":"Axios简介及安装简介axios是基于promise用于浏览器和node.js的http客户端 特点： 能够拦截请求 支持浏览器和node服务器 支持Promise 安装运行命令 $ npm install axios 也可以通过cdn引入 &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 使用示例GETaxios.get(&#39;http://127.0.0.1:7001/news&#39;).then(response =&gt; { console.log(response); }).catch(error =&gt; { console.log(error); }) 如果需要发送参数，有两种方式，第一种就是上面的示例url后添加参数，第二种是将要发送的数据作为对象放到get方法的参数中 axios.get(&#39;http://127.0.0.1:7001/news&#39;, { params: { id: 123 } }).then(response =&gt; { console.log(response); }).catch(error =&gt; { console.log(error); }) POSTaxios.post(&#39;http://127.0.0.1:7001/add&#39;, { name: &#39;zhangsan&#39;, password: &#39;123456&#39; }).then(response =&gt; { console.log(response); }).catch(error =&gt; { console.log(error); }) axios的APIaxios(config)axios({ method: &#39;POST&#39;, url: &#39;http://127.0.0.1:7001/add&#39;, data: { name: &#39;zhangsan&#39;, password: &#39;123456&#39; } }); // 获取远程图片 axios({ method:&#39;get&#39;, url:&#39;http://127.0.0.1:7001/img&#39;, responseType:&#39;stream&#39; }) .then(function(response) { response.data.pipe(fs.createWriteStream(&#39;bg.jpg&#39;)) }); axios(url[, config])不添加config，默认GET请求 别名 axios.request(url); axios.get(url[,config]); axios.delete(url[,config]); axios.head(url[,config]); axios.options(url[,config]); axios.post(url[,data[,config]]); axios.put(url[,data[,config]]); axios.patch(url[,data[,config]]); 请求和响应请求配置{ // `url` 是用于请求的服务器 URL url: &#39;/user&#39;, // `method` 是创建请求时使用的方法 method: &#39;get&#39;, // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#39;https://some-domain.com/api/&#39;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &#39;PUT&#39;, &#39;POST&#39;, 和 &#39;PATCH&#39; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: &#39;Fred&#39; }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: &#39;janedoe&#39;, password: &#39;s00pers3cret&#39; }, // `responseType` 表示服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39; responseType: &#39;json&#39;, // default // `responseEncoding` 响应编码 responseEncoding: &#39;utf8&#39;, // default // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // Do whatever you want with the native progress event }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // &#39;proxy&#39; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: &#39;127.0.0.1&#39;, port: 9000, auth: { username: &#39;mikeymike&#39;, password: &#39;rapunz3l&#39; } }, // `cancelToken` 指定用于取消请求的 cancel token cancelToken: new CancelToken(function (cancel) { }) } 响应结构{ // `data` 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &#39;OK&#39;, // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {}, // &#39;request&#39; 请求信息 request: {} } 拦截器// 添加一个请求拦截器 axios.interceptors.request.use( config =&gt; { const token = token; token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; { return Promise.error(error); }) // 添加一个响应拦截器 axios.interceptors.response.use( response =&gt; { if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, error =&gt; { return Promise.reject(error.response); }) Vue -axiosmain.js引入Axios import axios from &#39;axios&#39; axios.defaults.withCredentials = true //跨域 axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/json&#39; Vue.use(axios) Vue.prototype.$http = axios // 将axios挂载到Vue原型，可以直接在Vue对象中this.$http来发送请求","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://easyremember.cn/tags/Node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Promise学习笔记","slug":"笔记/Promise","date":"2020-08-20T09:41:38.591Z","updated":"2020-09-05T09:38:03.804Z","comments":true,"path":"2020/08/20/笔记/Promise/","link":"","permalink":"https://easyremember.cn/2020/08/20/笔记/Promise/","excerpt":"","text":"Promise学习笔记参考视频教程 知识铺垫函数对象和实例对象 函数对象：将函数作为对象使用 实例对象：new 函数产生的对象(执行构造函数) 只有在new出实例对象之后，函数才能叫做构造函数 function Person() { } var p = new Person(); console.log(Person.prototype) 在这段代码中p是实例对象，Person是构造函数，打印Person原型时，Person是函数对象 回调函数 同步回调：立即执行，完全执行完了才结束，不会放入回调队列 异步回调：不会立即执行，放入回调队列中将来执行 const arr = [1, 2, 3]; arr.forEach(item =&gt; { console.log(item); }); console.log(&#39;foreach之后&#39;); setTimeout(() =&gt; { console.log(&#39;callback&#39;); }, 0); console.log(&#39;setTime之后&#39;); 上面一段是同步回调，按照顺序执行；下面一段是异步函数，放到队列中执行，主线程执行完毕之后才执行 错误处理 错误的类型 Error: 所有错误的父类型 ReferenceError: 引用的变量不存在 TypeError: 数据类型不正确的错误 RangeError: 数据值不在其所允许的范围内 SyntaxError: 语法错误 错误处理 捕获错误: try … catch 抛出错误: throw error 错误对象 message属性: 错误相关信息 stack属性: 函数调用栈记录信息 Promise理解和使用什么是Promise 抽象表达: Promise是JS中进行异步编程的新的解决方案(旧的是谁？纯回调callback) 具体表达: 从语法上来说: Promise是一个构造函数 从功能上来说: promise对象用来封装一个异步操作并可以获取其结果 promise的状态改变(只有2种结果,，只能改变一次) pending变为resolved pending变为rejected 无论成功还是失败都会有一个 结果，成功的称为value，失败的称为reason promise的基本流程(pending，图里面写错了) 为什么使用Promise 指定回调函数的方式更加灵活：可以在请求发出甚至结束后指定回调函数 支持链式调用，可以解决回调地狱问题 怎么使用Promise简单的示例 const p = new Promise((resolve, reject) =&gt; { const d = Date.now(); if (d % 2 === 1) { resolve(&#39;success&#39;) } else { reject(&#39;faild&#39;) } }) p.then(value =&gt; console.log(value), reason =&gt; console.log(reason)) .then()接收两个函数，第一个是成功的回调（onResolved），第二个是失败的回调（onRejected） 主要API Promise构造函数: Promise (excutor) {} Promise.prototype.then方法: (onResolved, onRejected) =&gt; {} Promise.prototype.catch方法: (onRejected) =&gt; {}，拦截失败操作，返回promise对象，如果catch之前有reject，直接跳到reject，中间所有的.then都不执行 Promise.resolve方法: (value) =&gt; {}，修改状态为成功 Promise.reject方法: (reason) =&gt; {}，修改状态为失败 Promise.all方法: (promises) =&gt; {}，参数为一个可迭代对象，等所有的promise对象都完成之后状态变为resolved，返回结果可迭代对象；如果过有失败结果，状态变为rejected，失败原因是第一个失败的promise对象的结果 Promise.race方法: (promises) =&gt; {}，参数为一个可迭代对象，如果有任何一个promise解决或者拒绝，返回的promise就会解决或者拒绝 存在的问题 改变状态不一定是resolve和reject，也可以发生错误或者抛出异常 同一个promise对象添加对个.then都会执行 改变promise状态和指定回调函数谁先谁后 正常情况下是先指定回调函数再改变状态 先改变状态再指定回调：①在执行器中直接调用resolve()/reject()②延迟更长时间才调用then() 什么时候得到数据 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据 不论成功失败，回调函数永远是异步执行 .then返回promise的状态——由指定的回调函数执行的结果决定 抛出异常，新的promise变为rejected，reason为跑出的异常 返回的是非promise任意值，状态改为resolved，value是返回值 返回值是一个新的promise，这个promise的结果就会成为新的promise的结果 自定义Promise整体结构由于ES6和CommenJS都需要编译才能使用，所以自定义Promise需要使用ES5模块语法（自调用函数） (function (window) { /* Promise：构造函数 excutor: 执行器 */ function Promise(excutor) { } /* Promise 原型对象.then 指定成功和失败的回调函数 返回一个新的Promise */ Promise.prototype.then = function (onResolved, onRejected) { } /* Promise 原型对象.catch 指定失败的回调函数 返回一个新的Promise */ Promise.prototype.catch = function (onRejected) { } /* Promise 原型对象.resolve 返回一个指定value的Promise */ Promise.resolve = function (value) { } /* Promise 原型对象.reject 返回一个指定reason的Promise */ Promise.reject = function (reason) { } /* Promise 原型对象.all 返回一个Promise，所有promise都成功才成功，一个失败就失败 */ Promise.all = function (promises) { } /* Promise 原型对象.race 返回一个Promise，由第一个完成的promise决定 */ Promise.race = function (promises) { } // 暴露Promise window.Promise = Promise; })(window) 构造函数/* Promise：构造函数 excutor: 执行器 */ function Promise(excutor) { this.status = &#39;pending&#39;; // 状态 this.data = undefined; // 数据 this.callbacks = []; // 保存回调函数，结构：{onResolved() {}, onReject() {}} function resolve(value) { // 当前状态不是pending结束 if (this.status !== &#39;pending&#39;) { return } // 修改状态 this.status = &#39;resolved&#39;; // 保存数据 this.data = value; // 立即执行callback if (this.callbacks.length &gt; 0) { this.callbacks.forEach(callbacksObj =&gt; { setTimeout(() =&gt; { // 异步执行回调 callbacksObj.onResolved(value) }, 0) }); } } function reject(reason) { // 当前状态不是pending结束 if (this.status !== &#39;pending&#39;) { return } // 修改状态 this.status = &#39;rejected&#39;; // 保存数据 this.data = value; // 立即执行callback if (this.callbacks.length &gt; 0) { this.callbacks.forEach(callbacksObj =&gt; { setTimeout(() =&gt; { // 异步执行回调 callbacksObj.onRejected(reason) }, 0) }); } } // 立即执行excutor try { excutor(resolve, reject); } catch (error) { // 抛出异常变为rejected reject(error); } } Promise.then()/.catch()先来看一下这个例子，将fn赋值给f，两种方法，第二种比第一种简介，在.then内部返回数据时会用到 function fn() { } var f = function fn() { } var f = fn; 正片开始 /* Promise 原型对象.then 指定成功和失败的回调函数 返回一个新的Promise */ Promise.prototype.then = function (onResolved, onRejected) { onResolved = typeof onResolved === &#39;function&#39; ? onResolved : value =&gt; value onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; {throw reason} const _this = this; // 返回一个新的promise return new Promise((resolve, reject) =&gt; { // 指定调用回调函数 function handle(callback) { try { const result = callback(_this.data); if (result instanceof Promise) { // 类型为promise，结果是这个promise的结果 // result.then( // value =&gt; resolve(value), // reason =&gt; reject(reason) // ) result.then(resolve, reject); } else { resolve(result); // 非promise返回结果 } } catch (error) { // 抛出异常，失败 reject(error); } } if (_this.status === PENDING) { _this.callbacks.push({ onResolved(value) { handle(onResolved) }, onRejected(reason) { handle(onRejected) } }) } else if (_this.status === RESOLVED) { setTimeout(() =&gt; { handle(onResolved) }) } else { setTimeout(() =&gt; { handle(onRejected) }) } }) } /* Promise 原型对象.catch 指定失败的回调函数 返回一个新的Promise */ Promise.prototype.catch = function (onRejected) { return this.then(undefined, onRejected) } Promise.resolve()/reject() /* Promise 原型对象.resolve 返回一个指定value的Promise */ Promise.resolve = function (value) { // 返回一个成功/失败的promise return new Promise((resolve, reject) =&gt; { if (value instanceof Promise) { value.then(resolve, reject) } else { resolve(value) } }) } /* Promise 原型对象.reject 返回一个指定reason的Promise */ Promise.reject = function (reason) { // 返回一个失败的promise return new Promise((resolve, reject) =&gt; { reject(reason); }) } Promise.all()/race() /* Promise 原型对象.all 返回一个Promise，所有promise都成功才成功，一个失败就失败 */ Promise.all = function (promises) { const values = new Array(promises.length); // 保存所有成功的value let resolveCount = 0; // 计数器，计算成功的数量 return new Promise((resolve, reject) =&gt; { // 获取每个promise的结果 promises.forEach((p, index) =&gt; { p.then( value =&gt; { resolveCount++; values[index] = value; if (resolveCount === promises.length) { // 所有都完成才会resolve resolve(values) } }, reason =&gt; { reject(reason) } ) }) }) } /* Promise 原型对象.race 返回一个Promise，由第一个完成的promise决定 */ Promise.race = function (promises) { return new Promise((resolve, reject) =&gt; { promises.forEach((p) =&gt; { p.then( value =&gt; { resolve(value) }, reason =&gt; { reject(reason) } ) }) }) } 代码代码已经上传码云","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"原型和原型链","slug":"技术/原型和原型链","date":"2020-08-19T00:53:18.162Z","updated":"2020-09-05T09:35:16.583Z","comments":true,"path":"2020/08/19/技术/原型和原型链/","link":"","permalink":"https://easyremember.cn/2020/08/19/技术/原型和原型链/","excerpt":"","text":"原型和原型链 javascript是动态的，并且本身不提供一个 class 实现。（在 ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的）。 每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性 __proto__就是指向对象原型的属性 例如有一个Person对象，实例化一个实例对象之后它的__proto__指向Object 每个函数都会自带一个prototype属性，指向对象原型 function Person(name) { this.name = name; } Person.prototype.age = 12; var zhangsan = new Person(&#39;zhangsan&#39;); console.log(zhangsan); 可以看到实例的原型中已经有了age属性 实例对象.__proto__ === 构造函数.prototype 上面的例子中 zhangsan.__proto__ === Person.prototype Person.prototype.__proto__ === Object.prototype zhangsan——Person——Object这种原型与原型层层相链接的过程即为原型链 当读取实例属性时，如果找不到就会从原型链一层一层地往上找，一直到最顶层为止 所有对象的原型最终都指向Object，而Object.prototype.__proto__ === null","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"vuex入门","slug":"技术/vuex入门","date":"2020-08-18T11:03:09.232Z","updated":"2020-09-05T09:34:40.320Z","comments":true,"path":"2020/08/18/技术/vuex入门/","link":"","permalink":"https://easyremember.cn/2020/08/18/技术/vuex入门/","excerpt":"","text":"vuex入门优势 集中管理数据，易于后期开发和维护 高效的实现组件之间的数据共享，提高开发效率 vuex中数据都是响应式的，实时保持页面同步 哪些数据适合存储到Vuex中只有组件之间需要共享的数据，才有必要存储到Vuex中 Vuex核心概念State提供唯一的公共数据源 const store = new Vuex.store({ state: { count: 0 } }) 组件中访问State数据 第一种方式：this.$store.state.全局数据名 第二种方式：按需导入import {mapState} from &#39;vuex&#39;，通过mapState函数，将当前组件需要的全局数据映射为当前组件的computed计算属性 computed: { ...mapState([&#39;count&#39;]) } Mutation用于变更store中的数据 只能通过mutation变更Store数据，不可以直接操作Store中的数据 可以集中监控所有数据变化 在vuex中定义方法 const store = new Vuex.store({ mutations: { add(state) { state.count++ } } }) 方法一：通过this.$store.commit方法触发vuex中的方法 methods: { btnHandle1() { this.$store.commit(&#39;add&#39;) } } 可以在触发mutation的时候传递参数 const store = new Vuex.store({ mutations: { addN(state, step) { state.count += step } } }) ······ btnHandle2() { this.$store.commit(&#39;add&#39;, 3) } 方法二：从Vuex中按需导入mapMutations函数，将需要的mapMutations函数映射为当前组建的methods方法 import {mapMutations} from &#39;vuex&#39; ··· methods: { ...mapMutations([&#39;sub&#39;]), Handle() { this.sub() } } 带参数 methods: { ...mapMutations([&#39;subN&#39;]), Handle2() { this.subN(3) } } mutation函数中不可以执行异步操作 Action用于处理异步任务，Action 提交的是 mutation，而不是直接变更状态 const store = new Vuex.Store({ state: { count: 0 }, mutations: { add (state) { state.count++ } }, actions: { addAsync(context, step) { setTimeout(() =&gt; { context.commit(&#39;add&#39;, step) },1000) } } }) 方法一：通过 $store.dispatch()触发Action btnHandle3() { this.$store.dispatch(&#39;addAsync&#39;) } 携带参数 addAsyncN(context, step) { setTimeout(() =&gt; { context.commit(&#39;addN&#39;, step) },1000) } ······ btnHandle4() { this.$store.dispatch(&#39;addAsyncN&#39;, 3) } 方法二：从vuex中按需导入mapActions函数，将需要的actions函数映射为组建的methods import {mapActions} from &#39;vuex&#39; ······ methods: { ...mapActions([&#39;subAsync&#39;]), Handle3() { this.subAsync() } } 携带参数 methods: { ...mapActions([&#39;subAsyncN&#39;]), Handle4() { this.subAsyncN(3) } } Getter用于对Store中的数据进行加工处理形成新的数据，不会修改原有数据 对Store中的数据进行加工处理形成新的数据，类似于Vue中的计算属性 Store中的数据发生变化，Getter的数据也会跟着改变 定义getter getters: { showNum(state) { return &#39;当前最新数量是【&#39; + state.count + &#39;】&#39; } } 获取getter 方法一：通过this.$store.getters.getter的方法名 this.$store.getters.showNum 方法二：按需导入mapGetters函数，通过mapGetters函数，将当前组件需要的全局数据映射为当前组件的computed计算属性 import {mapGetters} from &#39;vuex&#39; ······ computed: { ...mapGetters([&#39;showNum&#39;]) }, Vuex模块化管理随着功能和数据不断增加，store会越来越臃肿，把不同的功能单独拆分处理，可以方便管理 └── store └── index.js # 总的store └── modules └── modulesA.js # 模块A └── modulesB.js # 模块B · # 其他模块 规模较小的可以将不同的核心放在一个模块js中，分多了反而不方便 user.js const state = {} const actions = {} _______________ export defult { namespaced: true, state, actions, } index.js import moduleA from &#39;./modules/modulesA&#39; ___________ modules: { moduleA } Vuex模块化管理调用不同功能划分模块之后引入数据的方式略有改变 state方法一： this.$store.state.moduleA.key2，在原来直接引入数据的基础上，添加了模块名 方法二： computed: { ...mapState({ key: state =&gt; state.moduleA.key1 }) ------------------- ...mapState(&#39;moduleA&#39;, { key: &quot;key1&quot; }), }, 将模块中的key1赋值给计算属性key,两种方法结果是一样的 mutations方法一： this.$store.commit(&#39;moduleA/changeValue&#39;)，在原来直接调用方法名的基础之上添加模块名 方法二： methods: { ...mapMutations(&#39;moduleA&#39;,[&#39;changeValue&#39;]), handle() { this.changeValue() } } 在引入方法之前添加模块名 actions同mutataions 方法一： this.$store.dispatch(&#39;moduleA/changeAsync&#39;) 方法二： methods: { ...mapActions(&#39;moduleA&#39;, [&#39;changeAsync&#39;]), handle() { this.changeAsync() } } getters方法一 computed: { ...mapGetters(&#39;moduleA&#39;,{ dKey: &quot;detailValue&quot; }) }, 方法二 this.$store.getters[&#39;moduleA/getMethods&#39;] Vuex状态管理 组件通过调用actions触发mutations来修改state，state经过getters包装之后显示到组件； 组件不能直接修改state，只让mutation修改state","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"原生JS实现AJAX","slug":"技术/原生JS实现AJAX","date":"2020-08-18T08:14:27.923Z","updated":"2020-09-05T09:35:10.625Z","comments":true,"path":"2020/08/18/技术/原生JS实现AJAX/","link":"","permalink":"https://easyremember.cn/2020/08/18/技术/原生JS实现AJAX/","excerpt":"","text":"原生JS实现AJAX什么是AjaxAJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），不是新的编程语言，而是一种使用现有标准的新方法，不重新加载整个页面的情况下更新部分页面 Ajax工作原理 XHR(XMLHttpRequiest)创建XHR对象新版本的浏览器都支持XHR对象，直接实例化即可var xhr = new XMLHttpRequest(); XHR请求如果要将数据发送到服务器，使用XMLHttpRequest 对象的 open() 和 send() 方法 open(method, url, async) method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) string：仅用于 POST 请求发送数据 GET请求function load() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { document.getElementById(&quot;box&quot;).innerHTML = xhr.responseText; } } xhr.open(&#39;GET&#39;, &#39;/promise.js&#39;, true); xhr.send(); } 声明一个函数，函数中实例化一个XHR实例对象，当xhr的状态改变成相应的状态时，将请求到的文本插入HTML文档中 POST请求过程相同，只是在send中加入要发送的数据 封装每次请求都要写这一堆东西太过繁琐，将代码抽离出来作为单独的模块 var Ajax = { get: function (url,callback) { var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { callback(xhr.responseText); } } }, post: function (url, data, callback) { var xhr = new XMLHttpRequest(); xhr.open(&#39;POSt&#39;, url, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { callback(xhr.responseText); } } xhr.send(data); } } function load() { Ajax.get(&#39;/promise.js&#39;, (res) =&gt; { document.getElementById(&quot;box&quot;).innerHTML = res; }); } get请求传入url和callback，ststus变为200时触发callback readystate status 反馈内容 基于Promise封装var Ajax = { get: function (url) { return new Promise((resolve, reject) =&gt; { var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status === 0)) { resolve(xhr.responseText); } } }) }, post: function (url, data) { return new Promise((resolve, reject) =&gt; { var xhr = new XMLHttpRequest(); xhr.open(&#39;POSt&#39;, url, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 0) { resolve(xhr.responseText); } } xhr.send(data); }) } } function load() { const p = Ajax.get(&#39;/promise.js&#39;).then(value =&gt; { console.log(value); }).catch(reason =&gt; { console.log(reason); }) } 把异步操作封装到Promise，调用起来相当方便，这样可以请求到数据，但判断状态如果加上else就会走else分支，目前没有找到原因","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"ES6和CommonJS的模块化","slug":"技术/ES6和CommonJS","date":"2020-08-18T01:10:06.072Z","updated":"2020-09-09T02:55:20.645Z","comments":true,"path":"2020/08/18/技术/ES6和CommonJS/","link":"","permalink":"https://easyremember.cn/2020/08/18/技术/ES6和CommonJS/","excerpt":"","text":"ES6和CommonJS的模块化 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 导出导入对比ES6ES6采用import/export来进行导出导入操作，还有一种导出方式export default，一般使用了export default的不允许同时使用export CommonJScjs采用require/module.exports来进行导入导出操作 ES6是引用，CommonJS是拷贝ES6导入的是模块的引用，当模块内部的值发生改变时，引用的值也会改变 print.js代码如下 export let num = 9; export function logNum() { num++; } 引用如下 可以看到每在浏览器点击一次button都会打印出num的值+1 CommonJS模块输出的是值的拷贝，模块内部的变化不会影响到输出值 print.js代码修改为如下 let num = 9; function logNum() { num++; } module.exports = { num, logNum } 然后再点击button会看到控制台打印出的数值一直不变 此外，export default导出的效果也跟CommenJS相同 let num = 9; function logNum() { num++; } export default { num, logNum } 引入时接收为一个对象 打印结果同样不变 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 运行时加载: CommonJS 模块就是对象（即module.exports属性）；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载” 此外 CommonJs是动态语法可以写在判断里，ES6 Module静态语法只能写在顶层","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Egg实用中间件","slug":"技术/Egg常用的包","date":"2020-08-17T08:17:39.921Z","updated":"2020-09-05T09:37:20.810Z","comments":true,"path":"2020/08/17/技术/Egg常用的包/","link":"","permalink":"https://easyremember.cn/2020/08/17/技术/Egg常用的包/","excerpt":"","text":"Egg常用的插件egg-mysql安装与配置首先安装egg-mysql的包 $ npm i --save egg-mysql 然后在plugin.ts开启插件 mysql: { enable: true, package: &#39;egg-mysql&#39;, }, 再然后在config中配置数据库信息 单数据库// mysql数据库 config.mysql = { client: { // 单数据库信息配置 host: &#39;localhost&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;liuhao&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;ssmbuild&#39;, // 数据库名 }, app: true, // 是否加载到 app 上，默认开启 agent: false, // 是否加载到 agent 上，默认关闭 }; 使用方法 await app.mysql.query(sql, values); 多数据库// mysql数据库 config.mysql = { clients: { // 多据库信息配置 db1: { host: &#39;localhost&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;liuhao&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;ssmbuild&#39;, // 数据库名 }, db2: { host: &#39;mysql.com&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;root&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;test&#39;, // 数据库名 } }, app: true, // 是否加载到 app 上，默认开启 agent: false, // 是否加载到 agent 上，默认关闭 }; 使用方法 const client1 = app.mysql.get(&#39;db1&#39;);await client1.query(sql, values); const client2 = app.mysql.get(&#39;db2&#39;);await client2.query(sql, values); 注意egg-mysql没有index.d.ts，所以编译不过，在typings/index.d.ts中添加配置 import &#39;egg&#39;; declare module &#39;egg&#39; { interface mysql { get(tableName: String, find: {}): Promise&lt;Any&gt; insert(tableName: String, find: {}): Promise&lt;Any&gt; update(tableName: String, find: {}): Promise&lt;Any&gt; delete(tableName: String, find: {}): Promise&lt;Any&gt; query(sql: String, values: Any[]): Promise&lt;Any&gt; } interface Application { mysql: mysql; } } 详见寒风傲天博文 CRUDCreate使用insert方法插入一条记录，插入成功判定 result.affectedRows === 1 // controller public async insert() { const { ctx } = this; const book = { bookName: &#39;js&#39;, bookCounts: 2, detail: &#39;test&#39;, }; const result = await ctx.service.book.create(book); if (result.affectedRows === 1) { ctx.body = &#39;插入成功&#39;; } else { ctx.body = &#39;插入失败&#39;; } } // service public async create(book) { const { app } = this; const result = await app.mysql.insert(&#39;books&#39;, book); return result; } 结果如图 Read使用 get 方法或 select 方法获取一条或多条记录。select 方法支持条件查询与结果的定制。 // controller public async index() { const { ctx } = this; const result = await ctx.service.book.select(); await ctx.render(&#39;book.ejs&#39;, { result, }); } // service public async select(options?: object) { const { app } = this; const result = await app.mysql.select(&#39;books&#39;, options); return result; } 来看下效果 定制查询 Update&amp;Delete使用 update 方法更新数据库记录 const result = await app.mysql.update(&#39;posts&#39;, row, options); // 参数: 表名，更新的数据，查询参数 const updateSuccess = result.affectedRows === 1; // 插入成功判定 使用 delete 方法删除数据库记录 const result = await app.mysql.delete(&#39;posts&#39;, options); 直接执行sql查询使用 query 执行sql 语句 const id = 1; cosnt count = 4; const results = await app.mysql.query(&#39;select * from books where id = ? and bookCounts &gt; ?&#39;, [id, count]); 事务 代码代码已上传码云#2部分 egg-sequelize安装与配置安装egg-sequelize和mysql2 $ npm install --save egg-sequelize mysql2 在plugin中开启插件 sequelize: { enable: true, package: &#39;egg-sequelize&#39;, }, 在config中配置sequelize // 配置sequellize config.sequelize = { dialect: &#39;mysql&#39;, // 数据库类型 database: &#39;ssmbuild&#39;, // 数据库名称 host: &#39;127.0.0.1&#39;, // 数据库ip地址 port: 3306, // 数据库端口 username: &#39;liuhao&#39;, // 数据库用户名 password: &#39;123456&#39;, // 数据库密码 }; 经测试这种方式可以进行操作，但是，不能自动生成表，需要手动建表 配置sequelize-cli安装 $ npm install --save-dev sequelize-cli 在项目根目录下新建一个 .sequelizerc 配置文件 &#39;use strict&#39;; const path = require(&#39;path&#39;); module.exports = { config: path.join(__dirname, &#39;database/config.json&#39;), &#39;migrations-path&#39;: path.join(__dirname, &#39;database/migrations&#39;), &#39;seeders-path&#39;: path.join(__dirname, &#39;database/seeders&#39;), &#39;models-path&#39;: path.join(__dirname, &#39;app/model&#39;), }; 然后运行命令初始化配置文件和目录 $ npx sequelize init:config $ npx sequelize init:migrations 根目录下会生成数据库相关文件夹 将config.js中的数据库配置改为自己的配置 然后运行命令生成表，以user为例 $ npx sequelize migration:generate --name=users 可以看到多了一个users.js文件，开始配置user模型 module.exports = { // 在执行数据库升级时调用的函数，创建 users 表 up: async (queryInterface, Sequelize) =&gt; { /** * Add altering commands here. * * Example: * await queryInterface.createTable(&#39;users&#39;, { id: Sequelize.INTEGER }); */ const { INTEGER, STRING } = Sequelize; await queryInterface.createTable(&#39;users&#39;, { id: { type: INTEGER, // INTEGER就是mysql中的int primaryKey: true, autoIncrement: true, // 自动增长 }, name: STRING(20), url: STRING(100), country: STRING(10), }, { // timestamps: false, // 去除createAt updateAt createdAt: false, // 表示不启用created_at updatedAt: false, // 表示不启用updated_at freezeTableName: true, // 使用自定义表名 // 使用自定义表名之后上面写的users就直接就是你的表名，如果不加的话，你就可以写user，但是自己的表名为users，程序会自动将s加上 tableName: &#39;users&#39;, // 自定义的表名，也可以不写，直接用define后面的也可以 // 只要你使用了freezeTableName，程序就不会自动给你加上s了 }); }, // 在执行数据库降级时调用的函数，删除 users 表 down: async queryInterface =&gt; { /** * Add reverting commands here. * * Example: * await queryInterface.dropTable(&#39;users&#39;); */ await queryInterface.dropTable(&#39;users&#39;); }, }; 然后变更数据库 # 升级数据库 $ npx sequelize db:migrate # 如果有问题需要回滚，可以通过 `db:migrate:undo` 回退一个变更 # npx sequelize db:migrate:undo # 可以通过 `db:migrate:undo:all` 回退到初始状态 # npx sequelize db:migrate:undo:all 可以看到数据库中已经有了users表 编码OK，配置已经完成，现在开始进行愉快的编码 首先在app目录下新建一个model文件夹，将user模型添加到model下面，然后就可以通过app.model.User 或者 ctx.model.User 访问了，以insert为例 // controller public async add() { const { ctx } = this; const result = await ctx.service.user.createUser({ name: &#39;zhangsan&#39;, url: &#39;http://zhangsan.com&#39;, country: &#39;CN&#39;, }); ctx.body = result; } // service public async createUser(user: object) { const res = await this.ctx.model.User.create(user); return res; } 然后就可以看到已经插入数据成功 更多sequelize使用方法不多赘述，见之前的博文，传送门 代码代码已上传码云#3部分 egg-passport这里用微博的第三登录做为示范 安装及配置首先运行命令安装passport支持 $ npm i --save egg-passport $ npm i --save egg-passport-weibo 然后开启插件 passport: { enable: true, package: &#39;egg-passport&#39;, }, passportWeibo: { enable: true, package: &#39;egg-passport-weibo&#39;, }, 然后在config.default中配置申请到的身份码 // weibo登录 config.passportWeibo = { key: &#39;your key&#39;, secret: &#39;your secret&#39;, }; 编码首先在router中挂载路由，这里使用的是插件提供的语法糖（这里挂载的时候可能会报错，因为没有index.d.ts文件，这个问题解决办法上面说过，这里不再赘述） export default (app: Application) =&gt; { const { controller, router } = app; router.get(&#39;/&#39;, controller.home.index); app.passport.mount(&#39;weibo&#39;); // 相当于 // const github = app.passport.authenticate(&#39;github&#39;, {}); // router.get(&#39;/passport/github&#39;, github); // router.get(&#39;/passport/github/callback&#39;, github); }; 然后在controller中编写登录操作 public async index() { // const { ctx } = this; // // ctx.body = await ctx.service.test.sayHi(&#39;egg&#39;); // await ctx.render(&#39;login.ejs&#39;); const { ctx } = this; if (ctx.isAuthenticated()) { ctx.body = `&lt;div&gt; &lt;h2&gt;${ctx.path}&lt;/h2&gt; &lt;hr&gt; Logined user: &lt;img src=&quot;${ctx.user.photo}&quot;&gt; ${ctx.user.displayName} / ${ctx.user.id} | &lt;a href=&quot;/logout&quot;&gt;Logout&lt;/a&gt; &lt;pre&gt;&lt;code&gt;${JSON.stringify(ctx.user, null, 2)}&lt;/code&gt;&lt;/pre&gt; &lt;hr&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/user&quot;&gt;User&lt;/a&gt; &lt;/div&gt;`; } else { ctx.session.returnTo = ctx.path; ctx.body = ` &lt;div&gt; &lt;h2&gt;${ctx.path}&lt;/h2&gt; &lt;hr&gt; Login with &lt;a href=&quot;/passport/weibo&quot;&gt;Weibo&lt;/a&gt; &lt;hr&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/user&quot;&gt;User&lt;/a&gt; &lt;/div&gt; `; } } 由于我的服务器已经过期，没有可用的网站来审核，所以申请到的oauth码不能使用，如果通过审核，这就可以使用了 此外 API ctx.user - 获取当前已登录的用户信息 ctx.isAuthenticated() - 检查该请求是否已授权 ctx.login(user, [options]) - 为用户启动一个登录的 session ctx.logout() - 退出，将用户信息从 session 中清除 ctx.session.returnTo= - 在跳转验证前设置，可以指定成功后的 redirect 地址 还提供了 API： app.passport.verify(async (ctx, user) =&gt; {}) - 校验用户 app.passport.serializeUser(async (ctx, user) =&gt; {}) - 序列化用户信息后存储进 session app.passport.deserializeUser(async (ctx, user) =&gt; {}) - 反序列化后取出用户信息 app.passport.authenticate(strategy, options) - 生成指定的鉴权中间件 options.successRedirect - 指定鉴权成功后的 redirect 地址 options.loginURL - 跳转登录地址，默认为 /passport/${strategy} options.callbackURL - 授权后回调地址，默认为 /passport/${strategy}/callback app.passport.mount(strategy, options) - 语法糖，方便开发者配置路由 代码代码已上传码云#4部分 egg-jwtjwt（jsonwebtoken）是我认为潜力最大的一种用户状态验证方式 JWT原理三部分组成，用.分割 header: 一个json对象，描述JWT的元数据 payload: 一个 JSON 对象，用来存放实际需要传递的数据 signature: 对header和payload两部分的签名，防止数据被篡改 安装与配置运行命令安装 $ npm i egg-jwt --save 开启插件 jwt: { enable: true, package: &#39;egg-jwt&#39;, } 在config.default中配置秘钥 // JWT秘钥 config.jwt = { secret: &#39;xiaofeng&#39;, }; 编码生成登录页使用post方法提交表单不再列出，主要给出生成token的操作（同样jwt没有index.d.ts，需要手动配置，见前文） public async add() { const { ctx, app } = this; ctx.cookies.set(&#39;username&#39;, ctx.request.body.username); const token = app.jwt.sign({ username: ctx.request.body.username, }, app.config.jwt.secret); ctx.set({ authorization: token }); //设置headers ctx.body = token; } 效果如图 验证import { Context } from &#39;egg&#39;; // 自定义的中间件：验证token export default function jwtAuth(options: any): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { const token = ctx.request.header.authorization; let decode = &#39;&#39;; if (token) { try { // 解码token decode = await ctx.app.jwt.verify(token, options.secret); console.log(&#39;decode======&gt;&#39;, decode); await next(); } catch (error) { ctx.status = 401; ctx.body = { message: error.message, }; return; } } else { ctx.status = 401; ctx.body = { message: &#39;没有token&#39;, }; return; } }; } 自定义验证token中间件，在路由文件中添加需要token才能访问的路由 import { Application } from &#39;egg&#39;; export default (app: Application) =&gt; { const { controller, router, middleware } = app; const token = middleware.jwtAuth(app.config.jwt); router.get(&#39;/news&#39;, token, controller.news.index); }; 没有获得token访问需要登录的路由时会提示没有token使用接口测试工具绑定一个已经生成的token可以看到成功解析了token 代码代码已上传码云#5部分,验证部分在#8 egg-validateegg-validate用于对参数进行检验，比如检验一个用户名是不是字符串ctx.validate({ userName: &#39;string&#39; }); 安装及配置运行命令 $ npm i egg-validate --save plugin中开启插件 validate: { enable: true, package: &#39;egg-validate&#39;, }, config中配置 // validate, 参数校验器 config.validate = { convert: true, // 对参数可以使用convertType规则进行类型转换 // validateRoot: false, // 限制被验证值必须是一个对象。 }; 编码编写一个post请求，接收一个对象作为参数 （validator需要手动挂载，使用什么方法添加什么规则） import { Controller } from &#39;egg&#39;; // 规则 const createRule = { name: &#39;string&#39;, age: { type: &#39;number&#39;, min: 0, max: 100, }, sex: [ &#39;man&#39;, &#39;woman&#39; ], }; export default class PostsController extends Controller { public async index() { const { ctx } = this; ctx.body = &#39;posts index&#39;; } public async create() { const { ctx, app } = this; // ctx.validate(createRule, ctx.request.body); // 自动处理错误，422 const error = app.validator.validate(createRule, ctx.request.body); // 返回错误信息，开发者处理 console.log(error); ctx.status = 201; } } 效果如图，当出现错误时返回错误，没有错误error为空，created是自动加的 更多规则 自定义规则使用app.validator.addRule添加更多自定义规则（需要手动挂载） 例如： app.validator.addRule(&#39;newRule&#39;, (rule, value)=&gt;{ if (value.length &lt; 3 || value.length &gt; 10) { console.log(&quot;用户名的长度应该在3-10之间&quot;); } }); 自定义规则需要单独在一个文件中添加 代码代码已上传码云#6部分 egg-cors 请求跨域是我们在日常开发中经常碰到的问题 egg解决跨域也是非常的简单，只要开启egg-cors就行了 安装及配置运行命令 $ npm i egg-cors --save plugin中开启插件 cors: { enable: true, package: &#39;egg-cors&#39;, }, config中配置 // 关闭csrf config.security = { csrf: { enable: false, // 关闭csrf }, domainWhiteList: [ &#39;*&#39; ], // 白名单 }; // CORS config.cors = { origin: &#39;*&#39;, allowMethods: &#39;GET,HEAD,PUT,POST,DELETE,PATCH&#39;, }; 然后就可以了 代码代码已上传码云#7部分","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://easyremember.cn/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"EggJS学习笔记","slug":"笔记/EggJS学习笔记","date":"2020-08-15T15:14:19.584Z","updated":"2020-09-05T09:36:10.076Z","comments":true,"path":"2020/08/15/笔记/EggJS学习笔记/","link":"","permalink":"https://easyremember.cn/2020/08/15/笔记/EggJS学习笔记/","excerpt":"","text":"EggJS学习笔记开始介绍Egg.js 为企业级框架和应用而生，Express框架本身缺少约定，标准的 MVC 模型会有各种千奇百怪的写法。Egg 按照约定进行开发，奉行『约定优于配置』，团队协作成本低。 Egg特性 提供基于Egg定制上层框架的能力 高度可拓展的插件机制 内置多进程管理 基于Koa开发，性能优异 框架稳定，测试覆盖率高 渐进式开发 安装$ npm init egg --type=ts $ npm i 本篇主要使用ts，类型可以不填，会让你手动选择， 启动$ npm run dev $ open http://localhost:7001 目录结构egg-project ├── package.json -- 框架配置，依赖 ├── app --源码目录 | ├── router.ts -- 用于配置 URL 路由规则 | ├── model -- 用于放置领域模型 │ | └── user.ts │ ├── controller -- 用于解析用户的输入，处理后返回相应的结果 │ | └── home.ts │ ├── service (可选) -- 用于编写业务逻辑层 │ | └── user.ts │ ├── middleware (可选) -- 用于编写中间件 │ ├── schedule (可选) -- 用于定时任务 │ ├── public (可选) -- 用于放置静态资源 │ ├── view (可选) -- 用于放置模板文件 │ └── extend (可选) -- 用于框架的扩展 ├── config -- 配置文件 | ├── plugin.ts -- 用于配置需要加载的插件 | ├── config.default.ts -- 用于编写配置文件(下同) │ ├── config.prod.ts | ├── config.test.ts (可选) | ├── config.local.ts (可选) | └── config.unittest.js (可选) ├── logs -- 日志文件 └── test/app -- 用于单元测试 └── controller -- 用于controller层的单元测试 └── home.test.js 路由路由文件代码如下 import { Application } from &#39;egg&#39;; export default (app: Application) =&gt; { const { controller, router } = app; router.get(&#39;/&#39;, controller.home.index); router.get(&#39;/login&#39;, controller.admin.login); }; 代码简单明了，一眼就能看懂是如何配置的，为了防止看不懂，我们来说一下 配置方法明白了再来说一下路由文件整体的结构 首先从egg中解构出Application，这是一个接口，对传入的参数做出约束（启动文件在egg包中，使用过程基本不用动）；从传入的app中再解构出controller和router，router就是路由对象 可以看到源码中router对象中有很多HTTP方法 这个是最常用的get方法参数，路径和中间件，中间件这里就是要执行的操作，示例中用到controller中的方法 POST请求直接用相同的方法配置POST请求会抛出错误 因为这样不符合Egg的安全机制，常见的安全问题 XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作。 CSRF 攻击：伪造用户请求向网站发起恶意请求。 钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。 HTTP参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。 远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。 解决办法1在访问页面时向页面发送签名数据csrf public async index() { const { ctx } = this; // ctx.body = await ctx.service.test.sayHi(&#39;egg&#39;); await ctx.render(&#39;login.ejs&#39;, { csrf: ctx.csrf, }); } 然后在页面发送请求的时候带上这个csrf &lt;form action=&quot;/login?_csrf=&lt;%= csrf %&gt; &quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; 解决办法2使用中间件发送csrf import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { // 设置全局变量 ctx.state.csrf = ctx.csrf; await next(); }; } 这样就不用每次在方法里面发送csrf了 如果觉得url带着一长串csrf不好看，可以在表单域设置csrf &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;&lt;%= csrf %&gt;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; controller已经获取到了表单数据 resources自动配置RESTful风格API，只需要一行代码router.resources(&#39;posts&#39;, &#39;/api/posts&#39;, controller.posts);，就可以自动生成下面一套API Method Path Route Name Controller.Action GET /api/posts posts app.controllers.posts.index GET /api/posts/new new_post app.controllers.posts.new GET /api/posts/:id post app.controllers.posts.show GET /api/posts/:id/edit edit_post app.controllers.posts.edit POST /api/posts posts app.controllers.posts.create PUT /api/posts/:id post app.controllers.posts.update DELETE /api/posts/:id post app.controllers.posts.destroy 只需要在Controller中实现Action即可 控制器Controller看完路由再来看一下controller，代码如下 import { Controller } from &#39;egg&#39;; export default class AdminController extends Controller { public async login() { const { ctx } = this; ctx.body = await ctx.service.login.welcome(&#39;egg&#39;); } } 新建一个类继承egg中的Controller，编写方法login 这里注意，egg基于Koa，Koa是ctx.xxx，在egg中ctx被封装在this里面，使用解构赋值解析出来，如果不使用解构就要使用this.ctx.xxx 获取传值get类型通过ctx.query获取参数，比如 export default class AdminController extends Controller { public async index() { const { ctx } = this; const userName: string = ctx.query.name; ctx.body = await ctx.service.login.welcome(userName); } } 可以看到已经从url中获取了name参数 动态路由从url中获取数据，但不是使用query的形式，而是使用http://127.0.0.1:7001/user/123这种形式 在配置路由时添加参数，例如 router.get(&#39;/user/:id&#39;, controller.admin.user); 然后在Controller中使用ctx.params获取参数，如 public async user() { const { ctx } = this; const id: string = ctx.params.id; ctx.body = await ctx.service.login.userCenter(id); } 服务ServiceService 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，好处： 保持 Controller 中的逻辑更加简洁。 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。 将逻辑和展现分离，更容易编写测试用例 使用场景： 复杂数据的处理，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。或者计算完成后，更新到数据库。 第三方服务的调用 定义服务代码示例 import { Service } from &#39;egg&#39;; /** * Login Service */ export default class Login extends Service { /** * userCenter for you * @param id - your id */ public async userCenter(id: string) { return `ID：${id}`; } } 属性 配置项config在config.default.ts中添加配置项，可以直接在controller或者service中调用配置项。比如在config中定义一个字符串，然后在service中调用，代码如下 //config.default.ts // 自定义配置项 config.str = &#39;this is a config string&#39;; // Login.ts public async userCenter(id: string) { console.log(this.config.str); return `ID：${id}`; } 日志loggerlogger有四种级别，下面给出示例 this.logger.debug(&#39;this is degug&#39;); this.logger.info(&#39;this is info&#39;); this.logger.warn(&#39;this is warn&#39;); this.logger.error(&#39;this is error&#39;); 上下文ctx this.ctx.curl 发起网络调用。 this.ctx.service.otherService 调用其他 Service。 this.ctx.db 发起数据库调用等， db 可能是其他插件提前挂载到 app 上的模块。 注意 模板引擎安装模板引擎使用ejs做案例，首先安装ejs包，npm文档 $ npm i egg-view-ejs --save 然后将下面这段代码放到对应的配置文件里面 // {app_root}/config/plugin.js exports.ejs = { enable: true, package: &#39;egg-view-ejs&#39;, }; // {app_root}/config/config.default.js exports.view = { mapping: { &#39;.ejs&#39;: &#39;ejs&#39;, }, }; // ejs config exports.ejs = {}; 注意ts的配置方式不同，如下图 编写模板代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2 style=&quot;color: #409eff;&quot;&gt;&lt;%= data %&gt;&lt;/h2&gt; &lt;ul&gt; &lt;% for(let i = 0; i &lt; list.length; i++) { %&gt; &lt;li&gt;&lt;%= list[i] %&gt;&lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;img src=&quot;/public/images/egg.jpg&quot; alt=&quot;&quot; width=&quot;100px&quot; height=&quot;60px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 模板文件一定要放在app下的view目录下ejs语法： &lt;% ‘脚本’ 标签，用于流程控制，无输出。 &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 _%&gt; 将结束标签后面的空格符删除 controller返回模板并传值public async user() { const { ctx } = this; const id: string = ctx.params.id; const udata: string = await ctx.service.login.userCenter(id); const arr: number[] = [ 111, 222, 333 ]; await ctx.render(&#39;user.ejs&#39;, { data: udata, list: arr, }); } 这里注意两个点 ctx.render是异步方法，需要使用await修饰 render的第一个参数是模板名称，这里需要加上后缀名，否则会报错 效果如图 实战：小爬虫地址：http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1 Serviceimport { Service } from &#39;egg&#39;; /** * News Service */ export default class Login extends Service { /** * getNewsList */ public async getNewsList() { const url = this.config.api + &#39;appapi.php?a=getPortalList&amp;catid=20&amp;page=1&#39;; const res = await this.ctx.curl(url); const response = JSON.parse(res.data); return response.result; } /** * getContent * @param aid 文章aid */ public async getContent(aid: string) { const url = this.config.api + &#39;appapi.php?a=getPortalArticle&amp;aid=&#39; + aid; const res = await this.ctx.curl(url); const response = JSON.parse(res.data); console.log(response.result); return response.result; } } Controllerimport { Controller } from &#39;egg&#39;; export default class AdminController extends Controller { public async index() { const { ctx } = this; const data = await ctx.service.news.getNewsList(); await ctx.render(&#39;news.ejs&#39;, { data, }); } public async newsContent() { const { ctx } = this; const aid = ctx.query.aid; const data = await ctx.service.news.getContent(aid); await ctx.render(&#39;newscontent.ejs&#39;, { data: data[0], }); } } ejsnews.ejs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;News&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;新闻列表&lt;/h2&gt; &lt;ul&gt; &lt;% for( let i = 0; i &lt; data.length; i++ ) { %&gt; &lt;li&gt;&lt;a href=&quot;/newscontent?aid=&lt;%= data[i].aid %&gt;&quot; &gt;&lt;%= data[i].title %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; newscontent.ejs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;详情&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%- data.content %&gt; &lt;script&gt; document.title = &#39;&lt;%= data.title %&gt;&#39; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 最终效果 框架拓展extend有多种拓展自身的功能 Application Context Request Response Helper Applicationapp 对象指的是 Koa 的全局应用对象，全局只有一个，在应用启动时被创建 拓展方式框架会把 app/extend/application.ts 中定义的对象与 Koa Application 的 prototype 对象进行合并，直接创建文件进行编码即可，例如 import { Application } from &#39;egg&#39;; export default { func(this: Application) { return &#39;app extend&#39;; }, }; 在app对象中直接调用方法即可 其他对象拓展方式跟Application同样注意：request和response是在ctx里面使用的 中间件middleware配置中间件 Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。 一个中间件是一个放置在 app/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数： options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来。 app: 当前应用 Application 的实例。 来看一下代码示例，这个中间件的作用是在每次请求的时候打印出时间 import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { ctx.logger.info(new Date()); await next(); }; } 中间件写完之后要在config中进行配置，在middlewware数组中添加文件名 然后每次请求时就会看到打印出了日志 中间件传值中间件传值在配置文件中bizConfig中增加中间件同名对象，就可以在中间件中通过options来访问变量 const bizConfig = { // 中间件传值 printdate: { configStr: &#39;this is value from config&#39;, }, }; 这时中间件需要配置参数 import { Context, Application, EggAppConfig } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(options: EggAppConfig[&#39;printdate&#39;], app: Application): any { app.logger.warn(options.configStr); return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { ctx.logger.info(new Date()); await next(); }; } 服务启动时就会在控制台看到打印出来的日志 实用中间件csrf中间件import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function auth(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { // 设置全局变量 ctx.state.csrf = ctx.csrf; await next(); }; } 然后在config中添加中间件config.middleware = [ &#39;auth&#39; ];，就可以在任意页面上获取csrf了 CookieCookie是存储在访问者计算机中的变量，可以让同一个浏览器访问同一个域名的时候共享数据 Egg中Cookie的设置和获取设置ctx.cookies.set(key, value, options) public async add() { const { ctx } = this; ctx.cookies.set(&#39;username&#39;, ctx.request.body.username); ctx.body = ctx.request.body; } 在浏览器的开发者工具中查看Cookie 获取ctx.cookies.get(key, options) 设置 {Number} maxAge: 设置这个键值对在浏览器的最长保存时间。是一个从服务器当前时刻开始的毫秒数。 {Date} expires: 设置这个键值对的失效时间，如果设置了 maxAge，expires 将会被覆盖。如果 maxAge 和 expires 都没设置，Cookie 将会在浏览器的会话失效（一般是关闭浏览器时）的时候失效。 {String} path: 设置键值对生效的 URL 路径，默认设置在根路径上（/），也就是当前域名下的所有 URL 都可以访问这个 Cookie。 {String} domain: 设置键值对生效的域名，默认没有配置，可以配置成只在指定域名才能访问。 {Boolean} httpOnly: 设置键值对是否可以被 js 访问，默认为 true，不允许被 js 访问。 {Boolean} secure: 设置键值对只在 HTTPS 连接上传输，框架会帮我们判断当前是否在 HTTPS 连接上自动设置 secure 的值。 除了这些属性之外，框架另外扩展了 3 个参数的支持： {Boolean} overwrite：设置 key 相同的键值对如何处理，如果设置为 true，则后设置的值会覆盖前面设置的，否则将会发送两个 set-cookie 响应头。 {Boolean} signed：设置是否对 Cookie 进行签名，如果设置为 true，则设置键值对的时候会同时对这个键值对的值进行签名，后面取的时候做校验，可以防止前端对这个值进行篡改。默认为 true。 {Boolean} encrypt：设置是否对 Cookie 进行加密，如果设置为 true，则在发送 Cookie 前会对这个键值对的值进行加密，客户端无法读取到 Cookie 的明文值。默认为 false。 Session Cookie 在 Web 应用中经常承担标识请求方身份的功能，所以 Web 应用在 Cookie 的基础上封装了 Session 的概念，专门用做用户身份识别 Session保存在服务器上 Egg中使用Session 可以在config中配置session信息 exports.session = { key: &#39;EGG_SESS&#39;, maxAge: 24 * 3600 * 1000, // 1 天 httpOnly: true, encrypt: true, }; 代码代码已上传码云，传送门","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://easyremember.cn/tags/Node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"VS Code 实用插件","slug":"资源/VSCode使用插件集合","date":"2020-08-13T06:25:25.881Z","updated":"2020-09-05T09:40:22.694Z","comments":true,"path":"2020/08/13/资源/VSCode使用插件集合/","link":"","permalink":"https://easyremember.cn/2020/08/13/资源/VSCode使用插件集合/","excerpt":"","text":"VSCode使用插件集合any-rule一款正则表达式生成插件，安装之后使用Ctrl+Shift+P调出命令面板，输入zz就可以看到常用的正则表达式，回车即可插入代码中 Auto Rename Tag可以自动修改闭合的标签，修改前半部分标签，后半部分自动跟随修改，再也不会乱了 Bracket Pair Colorizer彩色括号插件，当代码中括号过多的时候很容易混乱，有了这款插件之后，配对的标签会渲染为同一种颜色，括号配对关系相当清楚 Easy LESS可以自动将less文件编译为css文件 essjs可以自动添加很多Egg框架的代码片段，比如controller、service之类，大大提高编码效率 Git History插件提供可视化查看git信息，提交记录等 htmltagwrap这款插件可以对选中的代码进行标签嵌套，选中代码之后使用组合快捷键Alt+W触发，嵌套标签时不用再剪来剪去了 Indenticator可以在高亮显示鼠标选中的代码块所在的层级 JavaScript (ES6) code snippets可以通过简写快速插入ES6语法的js代码片段，详细见简写使用文档 Live Server这也是一款很强大的插件，通过服务器展示html，在html文件中右键选择open with live server就可以在浏览器中查看网页效果 Path Autocomplete自动补全路径的插件，快速的填写路径，可以通过./、C:(磁盘路径)等触发 RegExp Preview and Editor一款正则表达式验证插件，可以展示正则式匹配的全过程，安装插件之后可以选中正则式右键来查看匹配过程 还有一个正则编辑器，通过Ctrl+Shift+P调出命令面板，搜索regexp editor命令来触发，可以一边写一边展示匹配过程 REST Client直接在VSCode中进行接口数据测试的一款插件，在文件区域新建一个.http后缀的文件，然后编写接口测试，比如GET方法，url是127.0.0.1:7001，编写出来就是 GET http://127.0.0.1:7001 不同的接口之间使用三个#进行分割，编写好接口之后会在url上面出现一个Send Request，点击就可以使用了 Vue VSCode Snippets可以快速插入Vue代码片段，非常方便，更多快捷命令见文档说明 ESLint代码规则检查插件，当代码中出现不符合ESlint语法规范时会有报错","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"高级组件provide/inject","slug":"技术/高级组件provide-inject","date":"2020-08-12T06:56:52.036Z","updated":"2020-09-05T09:34:58.314Z","comments":true,"path":"2020/08/12/技术/高级组件provide-inject/","link":"","permalink":"https://easyremember.cn/2020/08/12/技术/高级组件provide-inject/","excerpt":"","text":"高级组件provide / inject官方文档介绍 类型 provide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是： 一个字符串数组，或 一个对象，对象的 key 是本地的绑定名，value 是： 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或 一个对象，该对象的： from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol) default 属性是降级情况下使用的 value 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 人话开始简单的来说就是在父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量。 示例父组件中使用provide定义一个变量 provide: { father: &quot;demo&quot;, }, 子组件使用inject引入变量 inject: [ &quot;father&quot; ], 再来看一下浏览器效果 可以看到浏览器的控制台成功的打印出了这个变量的值 上面提到，这种方式绑定的变量不是响应式的，我们来尝试一下 首先给父组件添加按钮绑定事件修改provide的值 provideHandle() { this.father = &quot;new demo&quot;; console.log(this.father); }, 然后来看效果 可以看到当点击按钮时，父组件的值已经改变，但是子组件中显示的依旧是原来的‘demo’ 响应方法：将父组件this对象作为返回值传递给子组件 废话少说，看效果 可以看到，子组件中的数据相应的发生了变化 更多示例","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Express中使用Sequelize实现ORM","slug":"技术/Express中使用Sequelize实现ORM","date":"2020-08-10T06:33:37.962Z","updated":"2020-09-05T09:37:31.675Z","comments":true,"path":"2020/08/10/技术/Express中使用Sequelize实现ORM/","link":"","permalink":"https://easyremember.cn/2020/08/10/技术/Express中使用Sequelize实现ORM/","excerpt":"","text":"Express中使用Sequelize实现ORM起步第一步当然是环境，首先使用Express生成器安装express环境 express myapp // myapp，你自己的项目名称（需要全局安装express） npm install 然后安装sequelize npm install --save sequelize npm install --save mysql2 // 驱动，这里主要说mysql，其他的类型见官网文档 连接连接到数据库必须有sequelize实例，实例化方法如下 const connect = new DB(&#39;dbname&#39;, &#39;username&#39;, &#39;password&#39;, { host: &#39;localhost&#39;, dialect: &#39;mysql&#39; }) 配置好实例之后可以使用.authenticate()来测试连接 connect.authenticate().then(() =&gt; { console.log(&#39;连接成功&#39;) }).catch(error =&gt; { console.error(&#39;连接失败:&#39;, error); }) 关闭连接 默认情况下，Sequelize将使连接保持打开状态，并对所有查询使用相同的连接。如果需要关闭连接，请调用sequelize.close()（它是异步的并返回Promise） 模型基础定义模型 模型是Sequelize的本质。模型是代表数据库中表的抽象。在Sequelize中，它是扩展Model的类 使用sequelize.define方法来定义模型，sequelize会根据定义的模型名称的复数自动建表 const Book = connect.define(&#39;Book&#39;, { bookName: DB.STRING, // 属性名： 数据类型 bookCounts: DB.INTEGER, detail: DB.STRING, }, { timestamps: false // 自动生成createAt和updateAt }) 此外也可以直接提供表名 sequelize.define(&#39;Book&#39;, { // ... attributes }, { tableName: &#39;literature&#39; }); 更多数据类型： // CHAR Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.TEXT(&#39;tiny&#39;) // TINYTEXT // NUMBER Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 10) // FLOAT(11,10) Sequelize.DOUBLE // DOUBLE Sequelize.DOUBLE(11) // DOUBLE(11) Sequelize.DOUBLE(11, 10) // DOUBLE(11,10) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) // TIME Sequelize.DATE // mysql / sqlite 为 DATETIME, postgres 为带时区的 TIMESTAMP Sequelize.DATE(6) // DATETIME(6) 适用 mysql 5.6.4+. 小数秒支持最多6位精度 Sequelize.DATEONLY // DATE 不带时间. // BOOLEAN Sequelize.BOOLEAN // TINYINT(1) //ENUM Sequelize.ENUM(&#39;value 1&#39;, &#39;value 2&#39;) // 一个允许值为&#39;value 1&#39;和&#39;value 2&#39;的ENUM // blob Sequelize.BLOB // BLOB (PostgreSQL 为 bytea) Sequelize.BLOB(&#39;tiny&#39;) // TINYBLOB (PostgreSQL 为 bytea. 其余参数是 medium 和 long) // GEOMETRY Sequelize.GEOMETRY // Spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. Sequelize.GEOMETRY(&#39;POINT&#39;) // 带有 geometry 类型的 spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. Sequelize.GEOMETRY(&#39;POINT&#39;, 4326) // 具有 geometry 类型和 SRID 的 spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. // unsigned 和 zerofill 属性 Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL 数据类型来源，掘金，云影sky的详细易用的 Sequelize 解读 模型同步使用model.async()方法来将模型与数据库同步 User.sync() -如果不存在则创建表（如果已经存在则不执行任何操作） User.sync({ force: true }) -这将创建表，如果该表已经存在，则将其首先删除 User.sync({ alter: true }) -这将检查数据库中表的当前状态（它具有哪些列，它们的数据类型等），然后在表中进行必要的更改以使其与模型匹配 创建模型实例使用model.build方法来创建模型实例 const jsBook = Book.build({ bookName: &#39;你不知道的JS&#39;, bookCounts: 3, detail: &#39;JS 进阶系列&#39;, }) 上面的创建实例之后使用jsBook.save();方法来保存到数据库 模型查询INSERT查询上面的模型保存还有一种简便方法，直接使用model.create方法，直接保存到数据库 Book.create({ bookName: &#39;你不知道的JS&#39;, bookCounts: 3, detail: &#39;JS 进阶系列&#39;, }) 可以看到数据库中已经生成了这条记录 控制台可以看到sql语句 SELECT查询find查询使用findAll方法查询整个表 Book.findAll() 效果图 可以使用attributes选项来进行列查询，数组中列出要查询的字段名 Book.findAll({ attributes: [&#39;id&#39;, &#39;bookName&#39;], }) 效果图 使用exclude删除一些选定的属性 Book.findAll({ attributes: { exclude: [&#39;bookCounts&#39;] }, }) 效果图 其他find查询 findByPk：使用提供的主键仅从表中获得一个条目 findOne：获取它找到的第一个条目（如果提供的话，它满足可选的查询选项） findOrCreate：查询不到实例就创建一个，返回值是实例（查到的或者创建的）和一个布尔值（创建为true） findAndCountAll：查询并计数，有两个返回值，一个是查询到的记录另一个是count where子句使用where选项可以进行where查询 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, id: 1 } }) // SELECT * FROM books WHERE bookName = &#39;你不知道的JS&#39; AND id = 1; 效果如图 有了AND就有OR，使用Op.or来进行or操作 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, id: { [Op.or]: [1, 2] } } }) // SELECT * FROM books WHERE bookName = &#39;你不知道的JS&#39; AND (id = 1 OR id = 2); 效果图 AND也可以使用Op.and来操作，但是易读性不强（不常用） Book.findAll({ where: { [Op.and]: [ { bookName: &#39;你不知道的JS&#39; }, { id: { [Op.or]: [1, 2] } } ] } }) sequelize提供了更多运算 const { Op } = require(&quot;sequelize&quot;); Post.findAll({ where: { [Op.and]: [{ a: 5 }, { b: 6 }], // (a = 5) AND (b = 6) [Op.or]: [{ a: 5 }, { b: 6 }], // (a = 5) OR (b = 6) someAttribute: { // Basics [Op.eq]: 3, // = 3 [Op.ne]: 20, // != 20 [Op.is]: null, // IS NULL [Op.not]: true, // IS NOT TRUE [Op.or]: [5, 6], // (someAttribute = 5) OR (someAttribute = 6) // Using dialect specific column identifiers (PG in the following example): [Op.col]: &#39;user.organization_id&#39;, // = &quot;user&quot;.&quot;organization_id&quot; // Number comparisons [Op.gt]: 6, // &gt; 6 [Op.gte]: 6, // &gt;= 6 [Op.lt]: 10, // &lt; 10 [Op.lte]: 10, // &lt;= 10 [Op.between]: [6, 10], // BETWEEN 6 AND 10 [Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15 // Other operators [Op.all]: sequelize.literal(&#39;SELECT 1&#39;), // &gt; ALL (SELECT 1) [Op.in]: [1, 2], // IN [1, 2] [Op.notIn]: [1, 2], // NOT IN [1, 2] [Op.like]: &#39;%hat&#39;, // LIKE &#39;%hat&#39; [Op.notLike]: &#39;%hat&#39;, // NOT LIKE &#39;%hat&#39; [Op.startsWith]: &#39;hat&#39;, // LIKE &#39;hat%&#39; [Op.endsWith]: &#39;hat&#39;, // LIKE &#39;%hat&#39; [Op.substring]: &#39;hat&#39;, // LIKE &#39;%hat%&#39; [Op.iLike]: &#39;%hat&#39;, // ILIKE &#39;%hat&#39; (case insensitive) (PG only) [Op.notILike]: &#39;%hat&#39;, // NOT ILIKE &#39;%hat&#39; (PG only) [Op.regexp]: &#39;^[h|a|t]&#39;, // REGEXP/~ &#39;^[h|a|t]&#39; (MySQL/PG only) [Op.notRegexp]: &#39;^[h|a|t]&#39;, // NOT REGEXP/!~ &#39;^[h|a|t]&#39; (MySQL/PG only) [Op.iRegexp]: &#39;^[h|a|t]&#39;, // ~* &#39;^[h|a|t]&#39; (PG only) [Op.notIRegexp]: &#39;^[h|a|t]&#39;, // !~* &#39;^[h|a|t]&#39; (PG only) [Op.any]: [2, 3], // ANY ARRAY[2, 3]::INTEGER (PG only) // In Postgres, Op.like/Op.iLike/Op.notLike can be combined to Op.any: [Op.like]: { [Op.any]: [&#39;cat&#39;, &#39;hat&#39;] } // LIKE ANY ARRAY[&#39;cat&#39;, &#39;hat&#39;] // There are more postgres-only range operators, see below } } }); UPDATE查询使用model.update方法来进行数据更新 Book.update({ bookCounts: 5 }, { where: { id: 2 } }) // UPDATE books SET bookCounts =5 WHERE id = 2; 修改后的数据如下 DELETE查询使用model.destory方法进行删除操作 Book.destory({ where: { id: 2 } }) 限制和分页使用limit和offset选项进行限制/分页 limit：每一页的记录数量限制 offset：第几页，从0开始 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, }， offset: parseInt(req.query.page) ? parseInt(req.query.page) : 0, limit: 1 }) 实用方法 进阶用法getter&amp;setter 事务","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://easyremember.cn/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"TypeScript学习笔记","slug":"笔记/TypeScript学习笔记","date":"2020-08-06T15:25:45.926Z","updated":"2020-09-05T09:38:13.592Z","comments":true,"path":"2020/08/06/笔记/TypeScript学习笔记/","link":"","permalink":"https://easyremember.cn/2020/08/06/笔记/TypeScript学习笔记/","excerpt":"","text":"TypeScript学习笔记1 简介TypeScript是由微软推出的编程语言，是javascript的超集，遵循ES5、ES6规范，拓展了js的语法 TypeScript更像是java等后端语言，可以开发大型企业项目，最新的前端框架基本都是使用了TS 2 安装npm install -g typescript cnpm以及yarn安装方式一样 3 编译及配置3.1 编译浏览器不识别ts代码，需要将ts代码编译为ES5的代码 新建index.ts脚本，编写代码 console.log(&quot;hello TS&quot;); 使用 tsc index.ts 命令进行编译 编译完成之后会生成index.js脚本，内容是 这一段代码看不出差别，来一段ts语法的代码 let str:String = &#39;feng&#39;; console.log(str); 再来看看编译出来的js脚本 3.2 在vscode中配置自动编译每次写完代码手动保存很不方便，可以使用配置文件自动生成js 在根目录下运行命令 tsc --init生成配置文件tsconfig.json 将outDir一行的注释打开，目录修改为要输出到的目录，不修改也可 点击选项卡终端-&gt;运行任务-&gt;typescript-&gt;tsc监视，然后再编写ts代码保存时就可以自动生成js了 4 数据类型ts为了使编写代码更规范增加了类型校验mts主要提供了以下几种类型的数据 布尔类型（boolean） 数字类型（number） 字符串类型（string） 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 4.1 布尔类型在变量标识符之后声明变量类型为boolean，那么这个变量只能接受布尔类型的赋值，如果赋值为其他类型的数据，在编译时会报错，例如 let isReal: boolean = 123; 定义布尔类型的变量isReal，然后为其赋值数字123，在编译时会抛出下面错误 意思是’123’不能赋值给boolean类型的变量 4.2 数值类型规则同布尔类型，声明的标识符是number 整形和浮点型都可以用number声明 4.3 字符串类型声明的标识符是string 4.4 数组类型声明方式有两种： 使用中括号 let arr:number[] = [1,2,3] // 数字类型的数组不能出现其它数据类型 使用泛型声明 let arr: Array&lt;number&gt; = [1, 2, 3] 4.5 元组类型let tuple:[string, number, boolean] = [&#39;feng&#39;, 11, true] 元组也是一种数组，可以指定数组的每一项的数据类型 4.6 枚举类型枚举类型用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。 枚举类型可以手动设置值 enum Flag { success = 1, error = -1 } let f: Flag = Flag.success console.log(f);// 1 // 另外一种手动设置的方式，只定义第一项，后面的依次递增 enum Animal { cat = 2, dog, snake } var a: Animal = Animal.snake; console.log(a); // 4 // 自定义值可以在任意位置，上面的代码汇中如果只定义dog=2，那么snake就是3 也可以使用默认值，默认值就是索引值 enum Color { blue, red, green } const c: Color = Color.blue; console.log(c); // 0 4.7 任意类型在上面的基本类型中，一旦定义了类型就不能再赋值其他类型的数据，否则就会报错 那如果想给一个变量赋值多种类型的数据就需要用到any来声明变量了 在ts文件中写入以下代码 var node = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 保存时会抛出以下错误 编译之后代码是可以运行的，但是存在问题 意思是node是一个Object类型，这时再给node声明Object类型 var node:Object = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 这时还会报错，因为进本数据类型中没有Object，这时就可以使用any类型了 var node: any = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 4.8 null和undefinednull和undefined是其他数据类型的子类 undefined声明变量是undefined类型之后，变量undefined不会报错，例如 但如果定义了undefined类型就不会报错 undefined一般用于联合类型 var num: number | undefined; num = 123; console.log(num); num可以是number类型，也可以是undefined null变量声明null之后只能为空值，如果为变量赋值就会报错 等于空值时不会报错 4.9 void类型用于定义没有返回值的方法 ((): void =&gt; { console.log(&#39;void&#39;); })() lambda表达式的写法 4.10 never类型其他类型，表示从不会出现（包括null和undefined的子类型），被never声明的变量只能被never类型的数据赋值 5 函数5.1 声明函数5.1.1 命名函数在TypeScript中声明函数时，要声明参数类型以及函数返回值类型 没有返回值使用void进行声明 function run(): string { return &#39;string&#39; } 在声明函数返回值类型之后，返回值的类型必须是声明的类型，否则报错 5.1.2 匿名函数在TypeScript中定义匿名函数也需要声明返回值类型 var func2 = function (): number { return 123; } 同样，返回值需要符合声明的返回值类型，不一致则会报错 5.2 传参定义一个方法，接收一个firstname和一个lastname，返回一个fullname function getName(firstname: string, lastname: string): string { return `${firstname}--${lastname}` } console.log(getName(&#39;Chan&#39;, &#39;Jack&#39;)); // Chan--Jack 匿名函数同样的在参数后声明类型 5.2.1 可选参数在func3中，有两个参数，现在调用func3，只传一个参数 function func3(name: string, age: number): void { console.log(name + &quot;--&quot; + age); } func3(&#39;zhangsan&#39;); 编译时会报错，原因是少了一个参数 在可选参数后添加?，表示参数可以有也可以没有 可选参数必须放到参数的最后面 5.2.2 默认参数在ES5中不可以设置默认参数，在ES6和TS中可以设置默认参数 function func3(name: string, age: number=20): void { console.log(name + &quot;--&quot; + age); } func3(&#39;zhangsan&#39;); // zahngsan--20 当默认参数在最后时，设置默认参数之后可以不传参数，使用默认的值，当默认参数在前面时必须传参数 5.2.3 剩余参数当不确定参数的数量时，可以使用ES6的扩展运算符（...） function getSum(...args: number[]): void { var result: number = 0; args.forEach(element =&gt; { result += element }); console.log(result); } getSum(1, 2, 3, 4) // 10 getSum(1, 2, 3, 4, 5) // 15 也可以固定前几个参数，然后后面的用扩展运算符接收 function getSum2(a: number, ...args: number[]): void { var result: number = a; args.forEach(element =&gt; { result += element }); console.log(result); } getSum2(1, 2, 3, 4) // 10 5.3 函数重载 java中的重载：两个或两个以上同名函数，但是他们接收的参数不一样，这时会出现函数重载 TypeScript中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的 function getInfo(name: string): string; function getInfo(age: number): string; function getInfo(str: any): any { if (typeof str === &#39;string&#39;) { return &#39;我叫&#39; + str } else { return &#39;我的年龄是&#39; + str } } console.log(getInfo(&#39;zahngsan&#39;)); console.log(getInfo(12)); 来看下结果 显然，ts在通过这种方式为一个函数实现了两种功能，但是，传参的类型必须在重载的函数参数之内，如果匹配不到就会报错 6 类6.1 对比ES56.1.1 定义类在ES5中使用构造函数创建对象，直接在function内部添加属性和方法 function Person() { this.name = &#39;zhangsan&#39; this.getInfo = function () { console.log(this.name); } } var p = new Person(); p.getInfo(); // zhangsan 还可以通过原型链的方式给对象添加属性和方法 Person.prototype.age = 20; Person.prototype.getAge = function () { console.log(this.age); } var p = new Person(); p.getAge(); // 20 但是，使用原型链添加的引用类型属性会被所有实例共享，意思就是当某一实例的该属性变化时，其他实例的属性都会改变 Person.prototype.friends = [&#39;f1&#39;, &#39;f2&#39;]; Person.prototype.getFriends = function () { console.log(this.friends); } var p = new Person(); p.getFriends(); var p2 = new Person(); p2.friends.push(&#39;f3&#39;); p.getFriends(); p2.getFriends(); 可以看到，改变一个实例的引用类型的属性，另一个实例也变了；基本数据类型不存在这种问题 6.1.2 静态方法ES5中给对象添加静态方法非常简单 Person.static = function () { console.log(&#39;静态方法&#39;); } Person.static(); // 静态方法 静态方法不需要实例化就可以调用，并且，对象实例不可以调用静态方法 6.1.2 继承ES5中通过对象冒充来实现继承 function People() { Person.call(this); } var peo = new People(); peo.getInfo(); // zhangsan 此外也可以通过原型的方法来实现继承 function People() { } People.prototype = new Person(); var peo = new People(); peo.getInfo(); 但是在实例化子类时无法给父类传参 function Person(name) { this.name = name; this.getInfo = function () { console.log(this.name); } } function People() { } People.prototype = new Person(); var peo = new People(&#39;zhangsan&#39;); peo.getInfo(); // undefined 然后就有了原型链+构造函数的组合继承模式——寄生组合继承 function People(name) { Person.call(this, name) } People.prototype = Person.prototype; var peo = new People(&#39;zhangsan&#39;); peo.getInfo(); // zhangsan 6.2 TypeScript中的类6.2.1 定义类在TS中，使用class关键字来定义类，类需要实例化时需要添加构造器 class Person { name: string; // 属性 constructor(n: string) { // 构造函数，实例化时触发 this.name = n; } getName(): string { return this.name; } setName(name: string): void { this.name = name } } var p: Person = new Person(&#39;李四&#39;); console.log(p.getName()); // 李四 p.setName(&#39;张三&#39;); console.log(p.getName()); // 张三 拓展——params方式实例化class Article { title: string | undefined; desc: string | undefined; status: number | undefined constructor(params: { title: string | undefined, desc: string | undefined, status?: number | undefined }) { this.title = params.title; this.desc = params.desc; this.status = params.status; } } var newArticle: Article = new Article({ title: &#39;大事件&#39;, desc: &#39;都是小事&#39; }) console.log(newArticle); 通过向构造器传入json对象，然后使用索引值来实例化对象 6.2.2 继承TS中继承有专门的关键字extends，需要配合super初始化父类构造函数来实现继承 class People extends Person { constructor(name: string) { super(name); } } var peo = new People(&#39;王五&#39;); console.log(peo.getName()); // 王五 6.2.3 修饰符 public：公有，在类里面、子类、外部都可以访问 protected：保护，在类里面，子类中可以访问 private：私有，只有类里面可以访问 属性不加修饰符默认是public 6.2.4 静态属性&amp;静态方法使用static修饰符声明静态方法，但是静态方法无法直接获取类中的属性，只能获取静态属性（同样用static修饰） class Person { name: string; static age: number = 20; constructor(n: string) { // 构造函数，实例化时触发 this.name = n; } getName(): string { return this.name; } setName(name: string): void { this.name = name } static log(): void { console.log(`年龄是${this.age}`); } } Person.log(); // 年龄是20 6.2.5 多态父类定义一个方法不去实现，让继承他的子类去实现，每一个子类有不同的表现 class Animals { name: string; constructor(name: string) { this.name = name; } getInfo(): void { } } class Dog extends Animals { constructor(name: string) { super(name); } getInfo(): void { console.log(this.name + &#39;是一只狗&#39;); } } class Cat extends Animals { constructor(name: string) { super(name); } getInfo(): void { console.log(this.name + &#39;是一只猫&#39;); } } var cat: Cat = new Cat(&#39;kitty&#39;); cat.getInfo(); // kitty是一只猫 var dog: Dog = new Dog(&#39;Tony&#39;); dog.getInfo(); // Tony是一只狗 这段代码中有一个父类Animals，两个子类Dog和Cat分别继承Animals，Animals定义了一个getInfo方法，两个子类中分别重写了这个方法，实现了不同的功能 6.2.6 抽象类 提供其他类继承的基类，不能被实例化；用absort关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现；抽象方法只能放在抽象类中 abstract class AbstractAnimals{ abstract func1(): void; abstract func2(): string; } class Mouse extends AbstractAnimals{ func1(): void { console.log(&#39;function 1&#39;); } func2(): string { return &#39;function 2&#39; } } 7 接口 在面向对象程序设计中，接口是一种规范的定义，它规定了行为和动作的规范，起到了限制和规范的作用。接口定义了某一批类需要遵守的规范，不关心这些类内部的状态数据，也不关心方法实现细节，只规定类需要提供哪些方法。类似于java中的类，更加灵活。 定义接口关键字：interface 7.1 属性接口属性接口就是对json格式的限制 interface FullName { firstName: string; lastName: string; } function getFullName(name: FullName) { return `${name.firstName}----${name.lastName}` } console.log(getFullName({ firstName: &#39;zhang&#39;, lastName: &#39;san&#39; })); // zhang----san 在这段代码中，定义了一个FullName接口，方法getFullName参数name要满足这个接口，如果不满足接口定义的规则就会报错 并且，参数必须且只能有接口定义的数据项，如参数使用对象name，该对象必须包含接口定义的项并且符合数据类型限制 可以使用 ? 定义可选属性，用法同可选参数 7.2 函数类型接口对方法传入的参数以及返回值进行约束 interface FuncRule { (key: string, value: string): string; } var funcIn: FuncRule = function (key: string, value: string): string { return `${key}---${value}` } console.log(funcIn(&#39;name&#39;, &#39;张三&#39;)); 接口中规定了两个参数和他们的类型以及返回值的类型，实现这个接口的函数就必须有这两个参数和返回值。参数类型不符合规定就会报错 7.3 可索引接口对数组、对象的约束 7.3.1 对数组的约束interface UserArr{ [index:number]:string; } var arr:UserArr=[&#39;aa&#39;, &#39;bb&#39;] console.log(arr[0]) 接口规定了索引值是number类型，value是string类型（开始这里没看懂，数组的索引还能不是number？？？继续往下看） 7.3.2 对对象的约束interface UserObj{ [index:string]:string } var arr:UserObj = { name: &#39;alex&#39; } 这里明白了，对数组的约束和对对象的约束不是具体的分类，索引值是number就限定了数组，索引值是string就限定了对象 7.4 类类型接口类类型约束和抽象有些类似，这里最接近于java中的接口类 // 接口 interface AnimalsInterface { name: string; eat(food: string): void; } // 实现类 class Tigger implements AnimalsInterface { name: string; constructor(name: string) { this.name = name; } eat(food: string): void { console.log(`${this.name}吃的是${food}。`); } } // 实例化 var t: Tigger = new Tigger(&#39;泰哥&#39;); t.eat(&#39;猪肉&#39;); // 泰哥吃的是猪肉。 在实现接口方法的时候，参数可以没有 7.5 接口扩展（接口继承）interface Animals { eat(): void; } interface People extends Animals { name: string; work(): void; } class Chinese implements People { name: string; constructor(name: string) { this.name = name; } work(): void { console.log(this.name + &#39;可以工作&#39;); } eat(): void { console.log(this.name + &#39;吃大餐&#39;); } } var ming: Chinese = new Chinese(&#39;小明&#39;); ming.work(); 接口People继承了接口Animals，在实现People接口的时候，需要同时实现Animals中定义的内容，如果去掉了Animals中的方法就会报错 8 泛型 泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。将类型参数化以达到代码复用提高软件开发工作效率的一种数据类型。泛型类]是引用类型，是堆对象，主要是引入了类型参数这个概念。 ——百度百科《泛型》 8.1 泛型变量先来看个例子 function getValue&lt;T&gt;(value: T): string { return &#39;获得的值是&#39; + value; } console.log(getValue&lt;number&gt;(12345)); 定义方法时规定了泛型T，传参时使用泛型规定类型 8.2 泛型类java中的ArrayList就是这种东西 class ArrayList&lt;T&gt; { private list: T[] = []; add(item: T): void { this.list.push(item); } getList(): T[] { return this.list; } } var arr = new ArrayList&lt;number&gt;(); arr.add(1); arr.add(4); console.log(arr.getList()); 这里用number类型做了个例子，泛型可以是任意类型，类也可以 使用上文7.5中的Chinese类来示范 // 实例化对象 var ming: Chinese = new Chinese(&#39;小明&#39;); var hong: Chinese = new Chinese(&#39;小红&#39;); // 将对象添加进list var arr = new ArrayList&lt;Chinese&gt;(); arr.add(ming); arr.add(hong); console.log(arr.getList()); 8.3 泛型接口在定义接口时使用泛型，实现接口时相应的需要用泛型实现，调用方法时可以根据需要规定数据的类型 interface ConfigFn { &lt;T&gt;(value: T): T; // 最后一个T是返回值类型，可以是其他的 } var getData: ConfigFn = function &lt;T&gt;(name: T): T { return name; } console.log(getData&lt;string&gt;(&#39;张三&#39;)); 9 装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器装饰器的写法：普通装饰器（无法传参） 、 装饰器工厂（可传参） 装饰器是过去几年中js最大的成就之一，已是ES7的标准特性之一 9.1 类装饰器装饰器本身是一个函数，装饰器通过@符号来使用 function logClass(params: any) { params.prototype.name = &#39;装饰器&#39;; params.prototype.run = function () { console.log(&#39;这是一个装饰器&#39;); } } @logClass class Log { constructor() { } getData() { } } var log: any = new Log(); // 这里变量类型声明any log.run(); // 这是一个装饰器 9.1.1 装饰器工厂装饰器工厂可以传参，通过闭包的方式进行操作 function logClass(params?: any) { return function (target: any) { console.log(params); } } @logClass(&#39;get&#39;) class Log { constructor() { } } var log: any = new Log(); // get 这里调用装饰器的时候方法立即执行 function logClass(params?: any) { return function (target: any) { target.prototype.pro = params; } } @logClass(&#39;post&#39;) class Log { constructor() { } } var log: any = new Log(); console.log(log.pro); 上面这一段代码通过装饰器动态给类添加属性，在调用构造器的时候一定要加括号，参数可选时没有参数也要带括号 9.1.2 重载构造函数 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数； 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明； function logClass(target: any) { return class extends target { url = &#39;newValue&#39; getData() { console.log(&#39;getData:&#39;, this.url); } } } @logClass class HttpClient { public url: string | undefined; constructor() { this.url = &#39;value&#39; } getData() { console.log(this.url); } } var http = new HttpClient(); http.getData(); //getData: newValue 装饰器返回的就是HttpClient的子类，因此TS可以自动推导 http 的类型； 重载时必须将类里面的所有属性几方法重载 9.2 属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入两个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 成员的名字； function LogProperty(params: any) { return function (target: any, attr: any) { console.log(target); console.log(attr); } } class User { @LogProperty(&#39;zhangsan&#39;) name: string; constructor() { } } 从图中可以看到属性装饰器传入的两个参数 function LogProperty(params: any) { return function (target: any, attr: any) { target[attr] = params; } } class User { @LogProperty(&#39;zhangsan&#39;) name: string | undefined; constructor() { } getName(): void { console.log(this.name); } } var u = new User(); u.getName(); // zhangsan 9.3 方法装饰器方法装饰器被应用到方法的属性描述符上，可以用来监视、修改、替换方法的定义。方法装饰器会在运行时传入3个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 成员的名字； 成员的属性描述符； function get(params: any) { return function (target: any, methodName: any, desc: any) { console.log(target); console.log(methodName); console.log(desc); } } class HttpClient { url: string | undefined; constructor() { } @get(&#39;/user&#39;) getData() { console.log(&#39;getData: &#39;, this.url); } } 可以从打印结果看到方法装饰器的三个参数 function get(params:any) { return function(target:any, methodName:any, desc:any) { var oldMethod = desc.value; desc.value = function(...args:any[]) { let newArgs = args.map((item)=&gt;{ return String(item); }); oldMethod.apply(this, newArgs); } } } class HttpClient { constructor() { } @get(&#39;http://baidu.com&#39;) getData(...args:any[]) { console.log(&#39;getData: &#39;, args); } } var http = new HttpClient(); http.getData(1, 2, true); // getData: [&quot;1&quot;, &quot;2&quot;, &quot;true&quot;] 9.4 参数装饰器参数装饰器表达式会在运行时被调用，可以为类的原型增加一些元素数据，传入3个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 方法名称，如果装饰的是构造函数的参数，则值为undefined 参数在函数参数列表中的索引； function logParams(params:any) { return function(target:any, methodName:any, paramIndex:any) { console.log(target) // { constructor:f, getData:f } console.log(methodName) // getData console.log(paramIndex) // 0 } } class HttpClient { constructor() { } getData(@logParams(&#39;uuid&#39;) uuid:any) { console.log(uuid); } } 参数装饰器只能用来监视一个方法的参数是否被传入 9.5 装饰器执行顺序多个装饰器同时装饰到一个声明上，语法支持从左到右，或从上到下书写； 不同装饰器的执行顺序：属性装饰器 &gt; 方法装饰器 &gt; 参数装饰器 &gt; 类装饰器；","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Vue组件通信","slug":"技术/Vue组件通信","date":"2020-08-04T13:44:18.572Z","updated":"2020-09-05T09:34:40.002Z","comments":true,"path":"2020/08/04/技术/Vue组件通信/","link":"","permalink":"https://easyremember.cn/2020/08/04/技术/Vue组件通信/","excerpt":"","text":"Vue组件间通信Vue中组件的通信方式大致有：父——子、子——父、兄弟之间的通信 父子传值父——子父组件向子组件传值的时候，使用v-bind绑定属性，携带要发送的数据，子组件通过props接收这个数据（要跟属性名相同） Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; &lt;Son :fromFather=&quot;fromFatherM&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFatherM: &quot;父组件的消息&quot;, }; }, }; &lt;/script&gt; 为了容易区分属性名和数据，数据后加了个M，子组件接收数据时要使用这里面的属性名 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, // 接收参数并指定类型 }, data() { return {}; }, }; &lt;/script&gt; 效果如图 子——父子组件向父组件发送数据要通过方法来完成，父组件引用子组件的时候向子组件传递一个方法，子组件通过触发事件向方法中传参来向父组件发行数据 Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; 接收：{{sonData}} &lt;Son :fromFather=&quot;fromFather&quot; @receive=&quot;receiveData&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFather: &quot;父组件的消息&quot;, sonData: &quot;&quot;, }; }, methods: { receiveData(d) { // 接收数据并赋值 this.sonData = d; }, }, }; &lt;/script&gt; 使用@receive绑定事件，子组件发出数据时需要向这个绑定事件提交 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;input type=&quot;text&quot; v-model=&quot;fromSon&quot; /&gt; &lt;button @click=&quot;sonHandle&quot;&gt;send&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, }, data() { return { fromSon: &quot;&quot;, }; }, methods: { sonHandle() { this.$emit(&quot;receive&quot;, this.fromSon); // 发送数据的事件 }, }, }; &lt;/script&gt; 效果如图 使用$parent和$children官方文档中还给出了一对API mounted() { console.log(this.$parent.id + &quot;$parent&quot;); }, mounted() { console.log(this.$children[0].id + &quot;$children&quot;); }, 这里一定要注意获取的数组 还可以通过$refs来获取，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 可以获取 上面三种方式的结果如图 兄弟组件兄弟组件传值可以借助一个空白组件，如果项目较大，可以使用Vue官方状态管理Vuex，之后会发Vuex的介绍","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"JS正则表达式","slug":"技术/JS正则表达式","date":"2020-08-03T16:26:08.012Z","updated":"2020-09-05T09:37:39.102Z","comments":true,"path":"2020/08/04/技术/JS正则表达式/","link":"","permalink":"https://easyremember.cn/2020/08/04/技术/JS正则表达式/","excerpt":"","text":"JS正则表达式创建正则的两种方式： 创建字面量正则表达式，使用//包裹 let reg = /\\w/ 创建正则表达式对象，使用new RegExp() let reg = new RegExp(/\\w/) 选择符 |“I” 左右两边匹配到一个就算是true let str = &#39;张三：010-1568413，李四：020-1586640&#39; let reg = /(010|020)\\-\\d{7,8}/ console.log(reg.test(str)); // true 转义在字符串中\\d和d是一样的 console.log(&#39;\\d&#39; === &#39;d&#39;) // true 在创建字面量的时候直接使用//创建，或者在字符串中转义 let str = &#39;123.abc&#39; let reg = &quot;\\\\d+\\\\.\\\\w+&quot; let reg2 = /\\d+\\.\\w+/ console.log(str.match(reg)); console.log(str.match(reg2)); 边界以^开始，以$结束，可用于检测网址开头和文件后缀 ^开始边界let str = &#39;http:www.easyremember.cn&#39; let reg = /^https?:www\\..+/ console.log(reg.test(str)); // true $结束边界let str = &#39;C://Users/All Users/abc.txt&#39; let str2 = &#39;C://Users/All Users/abc.log&#39; let reg = /\\.txt$/ console.log(reg.test(str)); // true console.log(reg.test(str2)); // false 元字符\\w：所有的字母、数字、下划线 \\W：所有的非数字、字母、下划线 \\d：所有的数字 \\D：所有的非数字 \\s：所有的空白字符，换行、空格等 \\S：所有的非空白字符 .：除换行以外的任意字符 模式修饰符 i：不区分大小写 g：全局匹配 y：从lastIndex开始匹配 u：处理UTF-16编码字符 m：多行处理 s：单行处理，忽略换行符 原子表 原子表 说明 [] 只匹配其中的一个原子 [^] 只匹配”除了”其中字符的任意一个原子 [0-9] 匹配0-9任何一个数字 [a-z] 匹配小写a-z任何一个字母 [A-Z] 匹配大写A-Z任何一个字母 Tips:\\d == [0-9] \\D == [^0-9] 原子组使用（）包裹 引用分组：引用之前原子组匹配到的内容，\\1\\2…… let str = &#39;abc123.c123&#39; let reg = /([a-z]\\d+)\\.\\1/g console.log(str.match(reg)); // [&quot;c123.123&quot;] 分组别名 为不同分组命名，使用?&lt;&gt;命名，使用$&lt;&gt;引用 let str = &#39;abc123.c123&#39; let reg = /(?&lt;init&gt;[a-z]\\d+)\\.\\1/g // console.log(str.match(reg)); console.log(str.replace(reg, `&lt;p&gt;$&lt;init&gt;&lt;/p&gt;`)); 重复+：重复一次或多次 *：重复零次或多次 ?：重复零次或一次 {n}：重复n次 {n,}：重复n次或更多次 {n,m}：重复n次到m次 let str = &#39;1234&#39; let reg = /\\d/ let reg2 = /\\d+/let reg3 = /^\\d{1,2}$/ console.log(str.match(reg)); console.log(str.match(reg2)); console.log(reg3.test(str)); 字符方法search返回要搜索内容的索引，没有返回-1 let str = &#39;abcdef&#39; console.log(str.search(&#39;ef&#39;));// 4 console.log(str.search(/\\w/)); // 0 console.log(str.search(&#39;efg&#39;)); // -1 match使用字符串或者正则表达式匹配，返回匹配的内容，匹配不到返回null let str = &#39;abcdef&#39;console.log(str.match(&#39;ef&#39;)); // ef console.log(str.match(/\\w+/)); // abcdef matchAll：返回一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` for (let s of str.matchAll(reg)) { console.log(s); } split：使用字符分割字符串 let str = &#39;abc/def/123&#39; console.log(str.split(&#39;/&#39;)); // [&quot;abc&quot;,&quot;def&quot;,&quot;123&quot;] replace替换字符为 let str = &#39;abc/def/123&#39; console.log(str.replace(/\\W/g, &#39;-&#39;)); // abc-def-123 正则方法test检测字符串是否符合要求，返回值是一个布尔值 exec不使用全局匹配与match相同，使用全局匹配会匹配完全部字符串，返回结果是一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` console.log(reg.exec(str)); console.log(reg.exec(str)); 断言?=exp相当于if，但是是后置的例如 &lt;main&gt; 中国努力建设有中国特色社会主义&lt;/main&gt; &lt;script type=&quot;text/javascript&quot;&gt; let reg = /中国(?=特色)/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) &lt;/script&gt; ?&lt;=exp前置断言 let reg = /(?&lt;=有)中国/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) 效果跟前面的?=效果是一样的 ?!exp后面不能出现exp匹配到的内容 ?&lt;!exp前面不能出现exp匹配到的内容","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"let、const和var的区别","slug":"技术/let、const和var","date":"2020-08-02T11:09:59.170Z","updated":"2020-09-05T09:37:43.284Z","comments":true,"path":"2020/08/02/技术/let、const和var/","link":"","permalink":"https://easyremember.cn/2020/08/02/技术/let、const和var/","excerpt":"","text":"let、const和var作用域var作用于全局，先来看一个例子 for (var i = 0; i &lt; 5; i++) { var a = 1; } console.log(a, i); // 1 5 跳出了for循环之外a依旧可以访问，用于控制循环的i也能够访问，i=5循环跳出，所以i是5 再来看一下把var改成const for (var i = 0; i &lt; 5; i++) { const a = 1; } console.log(a, i); // Uncaught ReferenceError: a is not defined 这时a是块级作用域，除了循环之后就访问不到了，再来看i，把i改成const声明 Uncaught TypeError: Assignment to constant variable. const属于常量，赋值之后不能改变，这里应该用let，let是变量 重复声明var b = 1; var b = 2; console.log(b); // 2 用var可以重复声明，再来试一下const const b = 1; const b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 可以看出const不可以重复声明，再来试一下let let b = 1; let b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 由此可以看出，const和let不可以重复声明 总结cosnt和let是ES6新出的块级作用域，不可以重复声明，此外 const b; b = 2; console.log(b); // Uncaught SyntaxError: Missing initializer in const declaration const不可以先声明后赋值，let可以 上面说到const不可以重新赋值，有一种情况例外 const b = { a: &#39;a&#39; }; b.a = &#39;b&#39;; console.log(b); 来看一下结果 可以看到值已经发生了改变","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Less预编译使用","slug":"笔记/Less预编译","date":"2020-08-02T06:11:51.895Z","updated":"2020-09-05T09:36:26.797Z","comments":true,"path":"2020/08/02/笔记/Less预编译/","link":"","permalink":"https://easyremember.cn/2020/08/02/笔记/Less预编译/","excerpt":"","text":"less预编译1 初见lessless是一门向后兼容的 CSS 扩展语言。 HTML标签不能直接识别less样式，需要引入less.js来编译 引入样式文件 &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt; 引入编译脚本 &lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 但是，这种方式是运行时编译，不是预编译，在VSCode插件商店中搜索less下载对应的编译插件 每次保存less文件时就可以自动编译出css文件 2 less语法2.1 注释less有两种注释 常规的css注释 /* 可见注释，会被编译到css文件中 */ 编译后不可见注释 // 不可见注释，不会被编译到css文件中 2.2 变量使用@符号声明变量，样式中可以引用，less的变量都是块级作用域，直接上代码，一目了然 less块级作用域：首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承 @width: 10px; @height: @width + 10px; .box { width: @width; height: @height; } 编译结果为 属性名和选择器也可以用变量，但是在引用的时候需要用 {}包裹起来，上代码 @width: 10px; @height: @width + 10px; @m: margin; @selector: #nav; .box { @{m}: 10px; width: @width; height: @height; } @{selector} { color: red; } 来看下编译后的，属性和选择器引用很少使用 变量延迟加载 .over { @var: 1; .three { @var: 2; brass: @var; @var: 3; } one: @var; } one属性是在over作用域中的，跟brass无关，所以one的值是1；在brass作用域中，要等变量先加载完再引用，这就是延迟加载，所以three的值是3 2.3 嵌套前面的代码已经能够体现嵌套规则了，可以根据HTML的层级关系来嵌套css样式，伪类选择器也是可以嵌套的 .box { width: @width; height: @height; background-color: pink; :hover { background-color: deeppink; } } 编译结果是这样的 注意这里多了一个空格，这样是不生效的，那怎么样去掉这个空格呢，使用&amp;取消父子关系，让两个类挨在一起 .box { width: @width; height: @height; background-color: pink; &amp;:hover { background-color: deeppink; } } 再来看结果 空格没了 2.3.1 @嵌套和冒泡@ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变 例如 .component { width: 600px; @media (min-width: 768px) { width: 300px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } @media (min-width: 1280px) { width: 800px; } } 这段代码在component类中嵌套了三个媒体查询，编译之后media会编译到最外层 2.4 混合2.4.1 混合混合就是将一系列属性从一个规则集引用到另一个规则集的方式，简单来说已定义的类可以在另一个类中进行引用 .border { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 结果 引用混合的时候，混合没有参数时，括号可以加也可以不加；混合需要使用默认参数时，括号必须加 2.4.2 不编译的混合如果只想定义一个混合，在选择其后面加一个括号，那么这个混合不会被编译 .border() { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 编译结果只有.border-2这个类 2.4.3 带参数的混合类似于js定义方法一样接收参数，然后进行编译（但是，他不叫函数，叫混合） .bar(@w, @h, @color) { width: @w; height: @h; color: @color; } .nav-bar { .bar(100px, 200px, #409eff); } 在引用bar的时候将参数填入，然后进行编译 可以设置参数的默认值，可以传递命名参数 .bar(@w: 10px, @h:10px, @color:green) { width: @w; height: @h; color: @color; } .nav-bar { .bar(@color: #409eff); } 结果 当引用混合的时候不加任何参数就会全部使用默认值 2.4.4 匹配模式根据标识匹配混合，下面定义了4种样式，分别是上右下左边框 .border-style(@_, @w, @h, @c) { border-style: solid; } .border-style(T, @w, @h, @c) { width: @w; height: @h; border-color: @c transparent transparent transparent; } .border-style(R, @w, @h, @c) { width: @w; height: @h; border-color: transparent @c transparent transparent; } .border-style(B, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent @c transparent; } .border-style(L, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent transparent @c; } .border-3 { .border-style(B, 100px, 100px, #000); } 匹配效果如图 注意代码开始的地方 .border-style(@_, @w, @h, @c) { border-style: solid; } 这一段，@_用来匹配L、R、B、T标识，每次使用匹配模式时自动带上这段公共代码 2.4.5 @arguments@arguments包含传进来的所有参数 .border_arg(@w:30px,@c:red,@sty:solid){ border:@arguments; } .test_arguments{ .border_arg(); } 结果如图 2.5 运算 算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。计算的结果以最左侧操作数的单位类型为准。如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px 到 cm 或 rad 到 % 的转换 @color: #224488 / 2; //结果是 #112244 background-color: #112244 + #111; // 结果是 #223355,#111-&gt;#111111 2.6 转义当需要引入无效的CSS语法或Less不能识别的字符，就需要使用转义字符，在字符串前面加一个 ~，并将需要转义的字符串放在 “” 中 @min768: ~&quot;(min-width: 768px)&quot;; .element { @media @min768 { color: pink; } } // 结果 @media (min-width: 768px) { .element { color: pink; } } 在需要使用cacl()的时候less会自动编译括号里面的东西 使用转义来避免自动编译 .no { height: 100 +20px; width: ~&quot;cacl(200px + 20)&quot;; } 2.7 映射 Less 3.5 版本开始，可以将混合和规则集作为一组值的映射（map）使用 #colors() { primary: blue; secondary: green; } .button { color: #colors[primary]; border: 1px solid #colors[secondary]; } // 结果 .button { color: blue; border: 1px solid green; } 2.8 导入less文件导入可以省略后缀名 @import &quot;main&quot;; // mian.less @import &quot;style.css&quot;; 2.9 继承使用extend函数继承一个类 .middle { margin: 0 auto; } .footer:extend(.middle) { color: pink; } 编译之后的middle类将会变成两个类公共部分，用逗号连接","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"https://easyremember.cn/tags/css/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"动态控制输入框数量","slug":"随想/动态控制输入框","date":"2020-08-01T14:00:17.672Z","updated":"2020-09-05T09:35:01.008Z","comments":true,"path":"2020/08/01/随想/动态控制输入框/","link":"","permalink":"https://easyremember.cn/2020/08/01/随想/动态控制输入框/","excerpt":"","text":"动态控制输入框在开发中经常会遇到根据情况动态控制输入框的情况，以前都是使用UI框架提供的组件，这次自己动手完成了一个简易的动态输入框 先来上效果 正片开始 加减号使用fontawesome的图标不多做赘述 先来看一下标签 &lt;div id=&quot;upload-problem-outin&quot; v-for=&quot;(item, index) in problem.sample&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.inputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输入样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.outputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输出样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;/div&gt; problem.sample是problem对象中的样例相关部分，格式如下 sample: [{ inputSample: &#39;&#39;, outputSample: &#39;&#39; }], 通过v-for遍历sample数组来渲染样例组数，通过数据绑定，控制sample数组的内容来实现样例组数的渲染 再来看一下控制的方法 addSample() { this.problem.sample.push({ inputSample: &#39;&#39;, outputSample: &#39;&#39; }) }, subSample() { if(this.problem.sample.length &lt; 2) { alert(&#39;至少保留一组&#39;) return } this.problem.sample.pop() } 触发增加事件时向原数组追加一个sample对象，触发减少事件时丢掉最后一项，智力有一个判断，即样例数不能少于1 大功告成","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"Vue绑定不到组件","slug":"随想/Vue子路由常见的问题","date":"2020-08-01T10:38:09.001Z","updated":"2020-09-05T09:39:17.258Z","comments":true,"path":"2020/08/01/随想/Vue子路由常见的问题/","link":"","permalink":"https://easyremember.cn/2020/08/01/随想/Vue子路由常见的问题/","excerpt":"","text":"Vue子路由常见的问题之前在进行开发的时候遇到了一个很玄学的问题，有一个页面需要设置二级路由，在设置二级路由之后浏览器却出现了报错 路由设置如下 报错信息 在查阅了相关资料之后找到了一种解决办法，component改为conponents 虽然没搞明白原理，先试试再说，浏览器正常不报错，但是！！！ 组件也没加载出来，TnT，这啥啊，治标不治本 然后我发现了这个 由于vue-router版本升级的原因需要手动添加.default来加载组件 原因如下 还有种方法 { path: &#39;back&#39;, name: &#39;back&#39;, component: resolve =&gt; require([&#39;@/components/Admin/Back&#39;], resolve), } 我试了下，我试了下这种方式也没问题，resolve是require的回调 还找到了一种说法 require 是 CommonJS 的模块导入方式，而组件定义时写的 export default 是 ES6 方式，因此require 导入的结果其实是一个含 default 属性的对象，所以 vue 中 component 用这个会报错，而恰好 vue 的命名视图组件注册用 components ，而官方也说了“如果 router-view 没有设置名字，那么默认为 default”，所以这两个default 正好对应起来，于是像楼主所说加了s就不会报错了。而合理的用法应该是 require(‘xxx.vue’).default 或是用 import","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"Vue刷新页面","slug":"随想/Vue页面刷新方法","date":"2020-07-31T14:14:47.733Z","updated":"2020-09-05T09:39:17.184Z","comments":true,"path":"2020/07/31/随想/Vue页面刷新方法/","link":"","permalink":"https://easyremember.cn/2020/07/31/随想/Vue页面刷新方法/","excerpt":"","text":"Vue页面刷新方法在编写提交表单的时候，当表单提交上之后清空当前表单 开始的时候我想的是表单提交成功之后data中表单中有关表单内容的变量重新赋空值，但是这样太过麻烦 偶然间在一篇博客中发现可以通过路由跳转当前路由来清空页面 然后就想着搜集一下有没有其他方法，搜集之后总结在这里了 路由跳转this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.go(0) }) 通过this.$router.go(0)来刷新页面 location.reload()也可以实现刷新页面 但是这样或有一个空白的过程 通过空白组件刷新将上传成功之后的回调修改 this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.replace({ path: &#39;/admin/back&#39;, name: &#39;back&#39; }) }) 然后创建一个新的空白组件back.vue，script部分如下 // 用于刷新页面，没有实际意义 export default { name: &quot;Back&quot;, data() { this.$router.replace({ path: &#39;/admin/uploadProblem&#39;, name: &#39;UploadProblem&#39; }) return { } } } 效果如下，网上说会有路由的改变过程，我没有发现。。。 provide / inject 组合先修改一下app.vue，通过provide传递reload方法 export default { provide() { return { reload: this.reload() } }, name: &quot;Back&quot;, data() { return { isRouterAlive: true } }, methods: { reload() { this.isRouterAlive = false this.$nextTick(function() { this.isRouterAlive = true }) } } } 在需要重新加载的页面通过 inject: [&#39;reload&#39;],接收方法（网上叫它‘注入依赖’），然后就可以在方法中调用 this.reload()","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"Vue点击切换导航栏样式","slug":"随想/Vue点击切换导航栏样式","date":"2020-07-31T06:09:30.441Z","updated":"2020-09-05T09:39:17.031Z","comments":true,"path":"2020/07/31/随想/Vue点击切换导航栏样式/","link":"","permalink":"https://easyremember.cn/2020/07/31/随想/Vue点击切换导航栏样式/","excerpt":"","text":"Vue点击切换导航栏样式导航栏内容如下 &lt;div class=&quot;collapse&quot;&gt; &lt;div class=&quot;links&quot;&gt; &lt;router-link v-for=&quot;link in linkLists&quot; :to=&quot;link.links&quot; :key=&quot;link.id&quot; exact&gt;{{link.show}} &lt;/router-link&gt; &lt;/div&gt; 效果如图 感觉太过简单，就想着加一个激活效果，开始想了很多种方法，但是都存着一定的缺陷，偶然间发现了router-link-active这个东西 可以给激活的router-link添加样式，尝试了一下 在links里面添加样式（使用的less预编译） .links { display: flex; margin-right: auto; a { color: #777; margin: 0 10px; } a:hover { color: #409eff; } .router-link-active { color: #409eff; } } 开始我以为完事了，但是却发现无论怎么切换首页一直处于激活状态，我开始面向百度解决问题 然后我发现了exact exact 是一个单独的属性 正确用法是 &lt;router-link to=&quot;/home&quot; active-class=&quot;bianlan&quot; exact&gt;。 这样，只有当路径刚好是 /home 时才会添加 bianlan 类名，而当路径是 /home/something 时则不会（因为不 exact） 在router-link标签中添加exact属性之后效果完美","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"JS递归、闭包、作用域链","slug":"技术/JS递归、闭包、作用域链","date":"2020-07-31T04:14:58.555Z","updated":"2020-09-05T09:37:36.669Z","comments":true,"path":"2020/07/31/技术/JS递归、闭包、作用域链/","link":"","permalink":"https://easyremember.cn/2020/07/31/技术/JS递归、闭包、作用域链/","excerpt":"","text":"JS递归、闭包、作用域链递归常规的递归函数function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } } console.log(func(4)); // 24 这是一个非常常见的递归函数，但是有一种情况会使得此方法出现错误。 var func2 = func; func = null; console.log(func2(4)); 将递归函数赋值给一个变量，然后把原函数赋值为null，这时候再调用就会报错 这是因为function属于引用类型，赋值时通过指针指向原函数，原函数发生改变，调用时就会出错 使用callee在上面的情况下，使用arguments.callee就可以解决，arguments.callee是一个指向正在执行函数的指针，将经典递归做以下改动 function func(number) { if (number &lt;= 1) { return 1; } else { return number * arguments.callee(number - 1); } } console.log(func(4)); //24 使用指针进行递归，无论怎么调用函数都不会出错，但是，在严格模式下使用arguments.callee会报错 命名函数表达式以上两种方法都存在这不同程度的缺陷，使用命名函数表达式可以达到指针的效果，亦可以同时运行在严格模式和非严格模式下 var func2 = (function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } }); var func3 = func2; func2 = null; console.log(func3(4)); 这时依旧可以正常显示结果 闭包 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 上面的递归最后一种方法就可以理解为一个闭包 闭包与变量经典的示例 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function () { return i; } } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } // 10,10,10,10,10,10,10,10,10,10 乍一看好像是for循环中每次循环将0-9赋值给数组的每一项，其实并不是，因为当前的newArray()正在执行，每个函数作用域链都保存着newArray()的活动对象，所以for循环中每次都是引用的同一个变量i，for循环结束之后，i是10，所以每个函数内部的i都是10。 再将返回i的函数包在一个匿名函数中，就可以达到互不影响的效果 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function (num: number) { return function () { return num; }; }(i) } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } 结果如下 在for循环中,自调用函数立即执行,获取实时地i赋值给num. 循环结束之后,返回result，在自调用函数执行之后，他的作用域就被销毁了，不会再被其他操作影响 this对象// 非严格模式 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return function () { return this.arg; }; } }; console.log(object.getArg()()); //window 为什么结果会是window呢，来看一下最后一行 // object.getArg()()相当于 var val = object.getArg(); val(); 把getArg返回的方法赋值给了val变量，然后执行函数。因为val在全局中，所以获得的arg是全局中的arg还有一种情况会出现问题 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return this.arg; } }; object.getArg() // object object.getArg() // object (object.getArg = object.getArg)() // window 第一种方法简单的调用了object的方法；第二种方法引用了object的方法，this对象能够维持；但是第三种是一个赋值语句，赋值语句是有返回值的，也就是等号右边，所以这里引用了方法，但不是object内部而是指向window 从这张图就可以看出赋值语句其实是有返回值的 解决方法 1 传递this指向var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { var _this = this; return function () { return _this.arg; }; } }; console.log(object.getArg()()); 将object的this传递到getArg之内，然后使用这个引用值获取arg 2 箭头函数也就是lambda表达式 var arg: string = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return () =&gt; { return this.arg } } } console.log(object.getArg()()); 箭头函数的一大特点就是不改变this的指向 内存泄漏闭包的缺陷在于会造成内存泄露，当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，比如通过node结点给html元素添加点击事件的时候，当事件添加完之后，存储node结点的变量会一直占用内存，造成内存泄漏 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; 存储divNode的内存将会无法释放也无法使用，怎么解决呢 在添加完事件之后将divNode手动赋值为空 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; divNode = null; 作用域链作用域 作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。 全局作用域一般全局作用域有以下几种情况 最外层函数和最外层函数外面定义的变量拥有全局作用域 所有未直接定义的变量 所有window对象 函数作用域声明在函数内部的变量，函数作用域一般只有代码片段中可以访问，比如函数内部 例如 function func1(a) { var b = a * 2; function func2(c) { console.log(a, b, c); } func2(b * 2); } func1(2) 这段代码中存在3个作用域 全局作用域，标识符func1 作用域func1，标识符a，b，func2 作用域func2，标识符c 作用域链 由多级作用域连续引用形成的链式结果，掌管一切变量的使用顺序： 先在局部找，没有，就延作用域向父级作用域找。 可以向上搜索，但不可以向下搜索 这种一层一层的关系，就是 作用域链 。","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Express+MySQL实现增删查改","slug":"技术/Express+MySQL实现增删查改","date":"2020-07-28T13:56:38.115Z","updated":"2020-09-05T09:37:26.108Z","comments":true,"path":"2020/07/28/技术/Express+MySQL实现增删查改/","link":"","permalink":"https://easyremember.cn/2020/07/28/技术/Express+MySQL实现增删查改/","excerpt":"","text":"Express+MySQL实现增删查改现在Node后台开发在网上找到的资料基本都是用的MongoDB数据库，不太容易找到使用MySQL数据库的资料，所以我整理了一下这篇文章，将会讲解如何使用Express和MySQL来实现CRUD 环境搭建生成器可以直接使用Express生成器自动生成Express工程 $ npm install -g express-generator $ express --view=ejs myapp 手动搭建创建一个项目目录$ npm init 新建app.js入口文件 新建router.js路由文件 创建views文件夹，存放EJS模板文件（student.ejs, editStu.ejs） 新建public公共资源 views文件夹命名不可以是别的，会报错 安装第三方模块$ npm install express --save $ npm install mysql --save $ npm install ejs --save 编写代码编写入口文件实例化、模板引擎设置、静态资源、监听 const express = require(&#39;express&#39;); const app = express(); const stuRoute = require(&#39;/router&#39;) // 设置模板引擎 app.set(&quot;view engine&quot;, &quot;ejs&quot;); // 加载静态资源 app.use(express.static(&#39;public&#39;)); // 使用路由 app.use(stuRoute); // 监听 app.listen(3001, () =&gt; { console.log(&#39;启动成功&#39;); }) 编写路由文件const express = require(&#39;express&#39;); const route = express.Router(); const mysql = require(&#39;mysql&#39;); // 配置数据库,连接池模式 var pool = mysql.createPool({ connectionLimit: 10, // 连接数量 host: &#39;localhost&#39;, // 地址 user: &#39;liuhao&#39;, // 数据库用户名 password: &#39;123456&#39;, // 数据可密码 database: &#39;ssmbuild&#39; // 数据库名 }); route.get(&#39;/student&#39;, (req, res) =&gt; { console.log(&quot;/student:&quot;, req.query); const sql = &#39;select * from books where bookName = ?&#39;; let params = [&#39;java&#39;]; // 根据条件查询信息 pool.getConnection(function (err, connection) { if (err) throw err; // not connected! connection.query(sql, params, function (error, results, fields) { connection.release(); console.log(results); // 将数据传到ejs渲染 res.render(&#39;student&#39;, { res: [] }) if (error) throw error; }); }); }) module.exports = route; 效果展示查询结果 数据库数据 这里可以看到数据已经查询成功 本篇主要讲解mysql模块使用，对数据渲染不再赘述另外修改删除修改一下sql语句和params参数即可，开发时数据库部分一般会单独作为一个模块进行封装 现在大部分开发一般是返回json数据，后期会再进行记录","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"express","slug":"express","permalink":"https://easyremember.cn/tags/express/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"思途实训day5","slug":"生活/STDay 5","date":"2020-07-26T13:40:01.320Z","updated":"2020-09-05T09:36:44.780Z","comments":true,"path":"2020/07/26/生活/STDay 5/","link":"","permalink":"https://easyremember.cn/2020/07/26/生活/STDay 5/","excerpt":"","text":"Day 5引入js尽量放在body标签的最后，先加载静态标签，再加载js脚本 jQuery表达式必须有分号 jQuery改变元素样式(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); })() click事件$(function () { $(&#39;button&#39;).click(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); }); }); 导航栏颜色修改 &lt;ul id=&quot;nav-ul&quot; onclick=&quot;navHandle()&quot;&gt; &lt;li id=&quot;li1&quot;&gt;首页&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;所有宝贝&lt;/li&gt; &lt;li id=&quot;li3&quot;&gt;每周一上新&lt;/li&gt; &lt;li id=&quot;li4&quot;&gt;生活馆&lt;/li&gt; &lt;li id=&quot;li5&quot;&gt;特惠&lt;/li&gt; &lt;li id=&quot;li6&quot;&gt;礼品区&lt;/li&gt; &lt;/ul&gt; function navHandle() { var nodeId = window.event.target.id; // console.log(node); $(&#39;#&#39; + nodeId).css({ &#39;color&#39;: &#39;#d62cc0&#39; }).siblings().css({ &#39;color&#39;: &#39;#ffffff&#39; }); } siblings()方法返回被选中元素的同级元素 鼠标经过和移出$(function() { $(&#39;#mouse&#39;).mouseenter(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;red&#39; }); }); }); $(function() { $(&#39;#mouse&#39;).mouseleave(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;#409eff&#39; }); }); }); 淡入淡出效果$(function() { $(&#39;.b-f-1&#39;).mouseenter(() =&gt; { $(&#39;#black1&#39;).fadeOut(500); }); }); $(function() { $(&#39;.b-f-1&#39;).mouseleave(() =&gt; { $(&#39;#black1&#39;).fadeIn(300); }); }); 滑动效果slideDown、slideUp $(function() { $(&#39;div&#39;).mouseenter(() =&gt; { $(&#39;div&#39;).slideDown(1000); }); }); $(function() { $(&#39;div&#39;).mouseleave(() =&gt; { $(&#39;div&#39;).slideUp(1000); }); }); 总结今天大概复习了一下jQuery，很多东西都忘了，需要再看一下","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"思途实训day4","slug":"生活/STDay 4","date":"2020-07-24T11:29:57.687Z","updated":"2020-09-05T09:36:44.729Z","comments":true,"path":"2020/07/24/生活/STDay 4/","link":"","permalink":"https://easyremember.cn/2020/07/24/生活/STDay 4/","excerpt":"","text":"Day4旋转+透明度div { width: 150px; height: 150px; border-radius: 50%; overflow: hidden; border: solid 3px #409eff; transition: 0.5s; opacity: 0.5; } div:hover { transform: rotate(200deg); opacity: 1; } 今日收获。。。就是个透明opacity 成果","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"思途实训day3","slug":"生活/STDay 3","date":"2020-07-24T01:17:51.174Z","updated":"2020-09-05T09:36:44.676Z","comments":true,"path":"2020/07/24/生活/STDay 3/","link":"","permalink":"https://easyremember.cn/2020/07/24/生活/STDay 3/","excerpt":"","text":"Day 3HTML标签。。。从0开始的那种。。。 css样式通配符选择器* { margin: 0; list-style: none; /* 去掉list圆点 */ text-decoration: none; /* 去掉下划线 */ } 列表右浮动只给父级不给子级背景图片引入背景图片必须设置高度，否则不显示 .binner { /* no-repeat不平铺 */ background: url(../img/TB183NQapLM8KJjSZFBSutJHVXa.jpg) no-repeat; height: 568px; background-size: 100% auto; /* 图片自适应 */ } 行高等于div高度时自动居中.nav-f { width: 660px; height: 120px; position: absolute; left: 168px; line-height: 120px; } 精灵图使用Photoshop信息面板配合精灵图设置图片 比如这张精灵图 .shopping { width: 30px; height: 30px; background: url(../img/icon.png); background-position: -16px -133px; } 引入图片之后将鼠标移至图标左上角，看到位置是X：16，Y：133，将图片位置设置为-16px,-133px，将图片沿着X轴Y轴移动之后，浏览器会自动根据设置的宽高从起点位置裁切","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"JS异步轮询","slug":"技术/异步轮询","date":"2020-07-23T05:50:43.924Z","updated":"2020-09-05T09:35:06.977Z","comments":true,"path":"2020/07/23/技术/异步轮询/","link":"","permalink":"https://easyremember.cn/2020/07/23/技术/异步轮询/","excerpt":"","text":"异步轮询异步先来看一个例子 console.log(&#39;start&#39;) setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;) }, 4000) console.log(&#39;end&#39;) 这段代码的执行顺序是什么，你可能想到的结果是 start setTimeout end 但是，js是单线程的，不会因为一个任务而被阻塞，异步操作将会被放到队列中，等主线程执行完第一轮任务，然后再执行队列中的任务 这里稍微扯一下栈和队列 栈（stack） 栈是一种先进后出的数据结构，可以理解为一个桶，先放进的东西在最低下，后放的东西在最外面，外面的取完了之后才能拿出最先放进去的东西； 队列（queue） 队列是一种先进先出的数据结构，可以看做一个管道，先进的先出，后进的后出 回到正题，上面的例子中setTimeout是一个异步操作，被放到了队列中，当主线程执行完成之后再来执行队列中的任务，所以答案应该是 在js的队列中有两种划分，一种是宏任务（macrotask queue），一种是微任务（microtask queue），每一个事件循环（Event Loop）都有一个微任务，会有一个或多个宏任务，每一次事件循环都会首先执行微任务执行完后从宏任务取出一个加入到微任务然后执行，直至队列中所有的任务执行结束 宏任务 script(整体代码) setTimeout setInterval I/O UI交互事件 postMessage MessageChannel setImmediate(Node.js 环境) 微任务 Promise.then Object.observe MutaionObserver process.nextTick(Node.js 环境) Promise异步原理看完了，下面开始Promise let promise = new Promise((resolve, reject) =&gt; { // resolve(&quot;成功&quot;) // reject(&quot;失败&quot;) }) console.log(promise) 先来看一下Promise对象的结构 当没有任何操作的时候，Promise对象的状态时pending，值是undefinded 当在Promise中调用resolve之后，状态变为resolved，值是成功 当调用reject的时候，状态变为rejected，值是失败 pending就是未决，resolve可以理解为成功，reject可以理解为拒绝 Promise的状态是不可逆的，resolve和reject同时出现，先执行的决定状态，后执行的不生效 下面这三种方法可以触发Promise.then的错误方法 throw new Error(‘fail’) reject(‘fail’) 错误操作（默认，类似try/catch） 链式调用console.log(&#39;start&#39;) let promise = new Promise((resolve, reject) =&gt; { console.log(&#39;promise&#39;) resolve(&quot;success&quot;) // reject(&quot;faild&quot;) }).then(value =&gt; { console.log(value+1) return value }, reason =&gt; { console.log(reason) }).then(value =&gt; { console.log(value+2) }, reason =&gt; { console.log(reason) }) console.log(&#39;end&#39;) 打印结果为 Promise会将返回值作为.then()的参数传递下去，而且两个.then是在主线程执行完成之后才执行的，这里被放到了微任务（不是并列的，当执行第一个.then的时候第二个.then才会被放到微任务），如果不调用resolve或者reject，微任务是不创建的 每一个Promise.then也是一个Promise 状态中转let promiseErr = new Promise((resolve, reject) =&gt; { reject(&#39;faild&#39;) }) let promise = new Promise((resolve, reject) =&gt; { resolve(promiseErr) }).then(value =&gt; { console.log(&#39;value:&#39;+value) }, reason =&gt; { console.log(&#39;err:&#39;+reason); }) 这里promise虽然调用了resolve，但是返回的状态却是promiseErr的，所以他的结果是 .then是对它前一个Promise对象的操作 错误捕获这样每一个then都有两个方法，过于繁琐，可以在then中只写成功方法，在最后使用catch方法捕获错误 let promise = new Promise((resolve, reject) =&gt; { resolve() }).then(v =&gt; { console.log(&#39;p1&#39;) throw new Error(&#39;fail&#39;) }).then(v =&gt; { console.log(&#39;p2&#39;) }).catch(err =&gt; { console.log(err) }).then(v =&gt; { console.log(&#39;p3&#39;) }).then(v =&gt; { console.log(&#39;p4&#39;) }) 结果为 有结果可以看出，发生错误的地方到catch之间的代码不会执行，catch返回值也是一个Promise对象 async/await了解了Promise之后，async/await就很容易了，它其实就是Promise的语法糖 async function asyncFunc() { return &quot;asunc&quot; } let result = asyncFunc() console.log(result); 从结果看出，async方法返回的也是一个Promise对象 来看看下面这个例子 function p() { console.log(&#39;p&#39;) } async function func() { await p(); console.log(&#39;OK&#39;) } console.log(&#39;start&#39;) func() console.log(&#39;end&#39;) // start // p // end // OK 用知乎上看到过一个例子来解释，可以将 async function func() { await p(); console.log(&#39;OK&#39;) } 理解为 function func() { return Promise.resolve(p()).then(() =&gt; { console.log(&#39;OK&#39;) }) } console.log(‘OK’)被分配到微任务中等待下一轮轮询 来看一个综合案例 async function async1() { console.log(&#39;async1 start&#39;) await async2() console.log(&#39;async1 end&#39;) } async function async2() { console.log(&#39;async2&#39;) } console.log(&#39;script start&#39;) setTimeout(function () { console.log(&#39;settimeout&#39;) }) async1() new Promise(function (resolve) { console.log(&#39;promise1&#39;) resolve() }).then(function () { console.log(&#39;promise2&#39;) }) console.log(&#39;script end&#39;) 输出结果是 script start async1 start async2 promise1 script end async1 end promise2 settimeout 你做对了么(๑´ㅂ`๑)","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"JS中的闭包","slug":"技术/闭包","date":"2020-07-23T05:28:46.515Z","updated":"2020-09-05T09:34:48.925Z","comments":true,"path":"2020/07/23/技术/闭包/","link":"","permalink":"https://easyremember.cn/2020/07/23/技术/闭包/","excerpt":"","text":"​ 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 相信你看了这段鬼话，80%会感到懵逼，看完下面的内容再回来看这句话，相信你就可以理解了。 函数的作用域 在全局环境中定义了title变量和show方法，当执行show方法时，开辟出一块内存，如果在show方法内部调用context是可以正常执行的，当show执行完的时候，show中定义的context变量不被保留，这时外部调用context就会 not defined。 数据的作用默认就是在函数体内 数据向下流动，只会向子级传递，不会向父级传递 当show方法执行完之后，内存被释放，执行多个show方法相当于多次开辟了内存 如果在show方法中再定义一个head方法，再执行，此时的内存结构如图所示，head方法时show方法内部的，show执行时为head开辟一块内存；那多次调用show方法会一直调用那一个head方法么？不是的！！！多次调用show方法会开辟多块内存，他们之间是没有关系的。 这个例子更能清楚的说明，按照常理，第一次调用++n之后变成了2，但是这里第二次调用结果还是2，这就说明了两次调用创建了两次 那么怎么让n一直被使用呢，这时你应该想起来开头有一句话 但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 当数据一直被使用时就会保留下来，那么怎么让他一直被使用呢？ 将sum方法作为返回值赋值给a，这时候，feng中的数据就会一直被使用，直到a销毁，这时候多次调用a方法，n就会累加 如果再赋值给b，这就又开辟了一块内存，与a无关n又重新开始计算，结果如下： 这时候你又想起了开头还有一句话： 每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址 如果在sum中在添加一个function，这样再执行两次a结果是什么呢？ 你没有看错，其实很简单，这跟之前一样，相当于在a中开辟了两块不相关的内存，那么怎么让m累加呢？也很简单，再把show返回出去 这时再创建b，打印结果依旧是2 3 2 3 利用闭包选择数组区间 由于过滤函数一直在调用between的子函数，所以a，b也被保留了下来 闭包会造成内存泄漏 这段代码的意思是点击div会触发打印descript属性，因为事件处理函数是一直存在的，所以每个item在使用完成之后都会保存，而且都是不同的内存区域，对于复杂对象来说是非常浪费内存的 那么怎么解决闭包带来的内存泄漏呢 在使用完之后给item项赋空值 这样就可以解决不必要的内存浪费","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"思途实训day2","slug":"生活/STDay 2","date":"2020-07-22T08:57:04.870Z","updated":"2020-09-05T09:36:44.564Z","comments":true,"path":"2020/07/22/生活/STDay 2/","link":"","permalink":"https://easyremember.cn/2020/07/22/生活/STDay 2/","excerpt":"","text":"Day 2字体选择： 中文：微软雅黑， 宋体，黑体 英文：arial 字体大小： 网页最小字号：12px， 不重要信息 一般用的最小字号：14px 精确抠图解锁原背景，新建图层填充鲜艳的颜色，例如绿色 用魔棒工具选择背景色，调整容差值，右键选择【调整边缘】 调整参数 菱形方格 制作一个这样的菱形方格 用矩形工具选择一个矩形框填充一个颜色，【ctrl】+【T】自由变换，按住shift旋90度 在图层调节描边，内阴影和投影 就可以看到效果图中的样式 图层蒙版将要贴入的图片拖拽至目标图层上方 注意在图层区域要将两图层放在一起 左上角有自动选择，点一下就可以定位图层 在两图层之间按住【alt】+鼠标左键 图层区会变成 显示的样式就会变成 图标绘制 锚点工具使用 首先利用椭圆工具绘制黄色圆形，然后复制两份 利用圆角矩形工具绘制蓝色矩形，绘制完成之后按【A】键选中元素出现锚点，按住【ctrl】用鼠标拖拽锚点成为一个梯形 在梯形内绘制三个圆角矩形，填充背景色构造成镂空的感觉 绘制底座，使用圆角矩形，使用锚点工具选择右上角两个点，【delete】，然后将描边改为白色 使用钢笔工具绘制上面的把手，钢笔工具点击一个点，再点第二个点不要松手，调整弧度至合理，使用上面底座相同的配置即可 钢笔工具在使用的时候如果出现角度很别扭的时候，可以在上一个点调好之后不松手，按住【alt】鼠标移动调节手柄 切图将所有的背景色全部隐藏，用切片工具画出切片区域，存储为web格式","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"思途实训day1","slug":"生活/STDay 1","date":"2020-07-22T07:27:01.446Z","updated":"2020-09-05T09:36:44.408Z","comments":true,"path":"2020/07/22/生活/STDay 1/","link":"","permalink":"https://easyremember.cn/2020/07/22/生活/STDay 1/","excerpt":"","text":"Day 1PhotoShop操作快捷键 图层复制：【Ctrl】+【J】 自由变换：【Ctrl】+【T】 画笔工具：【B】，画笔调节：粗——右中括号，细——左中括号 放大：【ctrl】+【space】，缩小：【ctrl】+【alt】+【space】，抓手：【space】 盖印：【ctrl】+【alt】+【shift】+【e】 首选项：【ctrl】+【k】 填充前景色：【alt】+【delete】，填充背景色：【ctrl】+【delete】 移动工具：【v】 编组：【ctrl】+【g】 制作大头像调节图层素材图片 1 复制一个图层（可使用ctrl+j，也可以拖拽图层到下方的新建图层图标） 2 ctrl+t自由变换图层，缩放到合适的比例（按住shift等比缩放） 3 调节新图层透明度，50%-60%合适 4 将两图层下巴对齐 5 在小图层上新建蒙版 6 用黑色画笔将大图层头部涂黑，涂完之后将不透明度调至100%，如果有多余部分使用白色画笔涂回去（硬度调为0） 7 使用裁切工具只保留需要的部分，盖印生成图层 成果图如下 图层修饰 滤镜中点开液化 使用膨胀工具在两眼位置分别点击两下将眼部放大 使用褶皱工具将鼻子和嘴缩小 使用左推工具将脸收一下 如果拖坏了可以使用重建工具将要恢复的地方涂一下 GIF制作窗口打开时间轴，新建帧动画 在图层中控制要显示的帧然后添加关键帧 调节每一帧的时间 导出：存储为web格式，调节为GIF格式 网页设计项目立项——分析市场环境——解决用户痛点 仿照图 自己做的设计图： 渐变色：在选区内添加渐变图层，否则会使整个背景全部渐变 选择多个图层：选中第一个图层，按住shift选中最后一个图层 要选中某一图层的某一部分：先用多边形框选工具选出大致部分，然后ctrl+alt+shift+点击要选中部分的图层","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"Typora图片自动上传到图床","slug":"资源/Typora图片自动上传到图床","date":"2020-07-15T11:50:22.787Z","updated":"2020-09-05T09:40:22.479Z","comments":true,"path":"2020/07/15/资源/Typora图片自动上传到图床/","link":"","permalink":"https://easyremember.cn/2020/07/15/资源/Typora图片自动上传到图床/","excerpt":"","text":"Typora图片自动上传到图床你是否还在为找不到可靠的图床而烦恼 是否害怕图床网站关闭资源丢失 是否担心资源不能管理而发愁 今天他来了 1 下载安装picGo地址在这里，根据需要的版本进行下载 下载完成后进行安装 安装完之后在桌面右下角图标打开picGo详细界面 2 配置picGo图床+giteepicGo支持多个图床 这里主要说一下gitee新建一个公开的仓库，私有的在相册和Typora无法显示 搜索插件gitee（需要安装Node环境） 据说是两个都可以，我只试过了gitee，安装好之后在上面的图床列表里就会出现gitee图床 这里是配置信息 owner：gitee用户名 repo：gitee仓库名 path：路径，存放到根目录可以不用写 token：gitee个人令牌 message：可以不写 关于gitee个人令牌的获取 点开gitee的设置，在左侧栏找到私人令牌，然后点击生成新令牌 描述可以随便写一下，然后点击确认会生成一个token 将token复制到picGo中就可以了 3 配置Typora+picGo在Typora的偏好设置中将插入图片改为上传图片，上传服务修改为picGo App，并选择到安装目录 点击验证 如果出现false情况，看一下连接中的端口号，然后到picGo的设置中找到Server服务 将端口号修改一致 然后保存，再试一下验证","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"ES6笔记","slug":"笔记/ES6笔记","date":"2020-07-15T07:24:55.780Z","updated":"2020-09-05T09:36:10.203Z","comments":true,"path":"2020/07/15/笔记/ES6笔记/","link":"","permalink":"https://easyremember.cn/2020/07/15/笔记/ES6笔记/","excerpt":"","text":"ES6笔记变量let和constvar存在的问题 可以重复声明 无法限制修改 没有块级作用域 ES6新的定义变量 let 不能重复声明 变量，可以修改 块级作用域 const 不能重复声明 常量，不能修改 块级作用域 最大的区别：const一经定义值不能再变 函数箭头函数let show = function(n1,n2) { return n1-n2; } ----------等价-------------- let show = (n1, n2) =&gt; { return n1-n2; } 如果只有一个参数，()可以省略 let show = (n) =&gt; { return n; } --------省略-------- let show = n =&gt; { return n; } 如果只有一个return，{}可以省略 let show = n =&gt; { return 2*n; } -------省略-------- let show = n =&gt; 2*n; 箭头函数的this不会变：this指向的是当前对象，传统的function需要定义一个const that= this才能在里面的函数访问到最外层的this，箭头函数不会改变this指向，也就是说，无需定义that就可以用this访问原来的对象 箭头函数的优势和劣势 参数...args接收参数 命名随意，但必须放到参数最后，用于收集剩余参数 let show = function (a, b, ...args) { alert(a); alert(b); alert(args); } show(14,2,3,4,5); 多余的参数将会由args接收 展开数组 展开后效果跟直接把数组放在那一样 let arr = [1,2,3,4]; show(...arr);// == show(1,2,3,4) ------------------- let arr1=[1,2,3]; let arr2=[4,5,6]; let arr=[...arr1,...arr2]; // == let arr=[1,2,3,4,5,6]; 默认参数let show = function (a, b=5, c=10) { XXX } show(12); 当传的参数只有一个的时候，b默认是5，c默认是10； 当传参数大于一位时，会依次顶替默认参数 解构赋值左右两边结构必须一样 let [a, b, c] = [1,2,3] let {a,b,c} = {a:1,b:2,c:3} 右边必须合法 声明和赋值不能分开 let [a, b] = [5, 12];// 合法 ------------------------ let [a, b]; [a, b] = [5, 12];// 报错，解构赋值声明和赋值不能分开 数组map映射————一个对一个 let arr = [1, 2, 3, 4]; let result = arr.map(item =&gt; item * 2); // result 2,4,6,8 reduce汇总————一堆出来一个 let arr= [12, 8, 9, 16]; let result = arr.reduce( function (tmp, item, index) { return tmp + item; }) function中的三个参数分别是存储的和的中间数、要计算的数、索引 filter过滤器————保留一部分 let arr = [10,3,16,15,21,20]; let result = arr.filter(item =&gt; { if(item % 3 == 0) { return true; } return false; }); alert(result); -------------------------------- // json类型 let arr = [ {name: &#39;tom&#39;, price: 75}, {name: &#39;jerry&#39;, price: 60} ]; let result = arr.filter(item =&gt; { return item.price&gt;65; }); console.log(result); 当filter中的方法返回true的时候数据保留，返回false数据删除 forEach循环（迭代）————每一项进行操作 吧数组中的每一项都放到方法中执行 字符串两个新方法startsWith 匹配前面的字符串，相同返回true，不相同返回false endWith 匹配末尾的字符串，相同返回true，不相同返回false 应用：检测文件后缀 字符串模板字符串拼接 let a = &#39;AScri&#39;; let str = `ECM${a}pt6`; alert(str); // str=ECMAScript6 注意：插入字符串的字符串要用反单引号（数字键盘1左边的那个） 应用，拼接字符串 let html = `&lt;div&gt; &lt;h1&gt;${title}&lt;/h1&gt; &lt;p&gt;${content}&lt;/p&gt; &lt;/div&gt;`; 优势：直接把字符串插到字符串中；可以折行 面向对象语法class User { constructor(name, age) { this.name = name; this.age = age; } showName() { alert(this.name); } showAge() { alert(this.age); } } var user = new User(&#39;Tom&#39;, 18); user.showName(); user.showAge(); 对象创建关键字class，相当于java的类 构造器关键字constructor，相当java的构造函数 方法直接写在class里面，不需要加function 继承class VipUser extends User { constructor(name, age, level) { super(name, age); this.level = level; } showLevel() { alert(this.level); } } var vip = new VipUser(&#39;Tom&#39;, 18, 3); vip.showName(); vip.showAge(); vip.showLevel(); 继承关键字extens，相当于java的继承 构造函数中使用super关键字，调用父类的构造函数 添加新的属性和新的方法 JSON标准写法 只能用双引号 所有名字都必须用引号括起来 { &quot;a&quot;: &quot;abx&quot;, &quot;b&quot;: 12, &quot;c&quot;: true } 格式化为字符串let json = {a: 11, b: 12}; alert(JSON.stringify(json)); JSON.stringify()得到的结果是一个字符串 格式化为JSONlet str = &#39;{&quot;a&quot;: 11, &quot;b&quot;: 12}&#39;; console.log(JSON.parse(str)); JSON.parse()得到的结果是一个json对象，但是，字符串的内容必须符合json格式标准，另外，双引号的外面是单引号 简写属性名简写 let a = 12; let b = 5; let json = {a, b, c: 15}; console.log(json); 当已经存在的值和json属性名一样的时候，可以只写值，不一样的可以按照json格式添加 这里的json指的是json字面量 方法简写 let json = { a: 12, show() { console.log(this.a); } } json.show(); 方法可以只写方法名，省略 function Promise作用：消除异步操作，用同步的方式来写异步代码 异步：操作之间没啥关系，同时进行多个操作；代码复杂 同步：同时只能做一件事，前面的事没干完后面的事不能开始；代码简单 封装ajax（基于jquery） let ajax = new Promise(function (resolve, reject) { $.ajax({ url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); ajax.then(result =&gt; { alert(result); }, err =&gt; { console.log(err); }) Promise.all()当有两个Promise对象时，可以使用Promisr.all()处理两个Promise对象 Promise.all([ ajax1, ajax2 ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 这里注意，当使用.all处理多个Promise对象时，有一个出错就会报错，全部成功才会执行成功的回调函数 有多个ajax请求不同地址的时候可以，再次封装 function createPromise(url) { return new Promise(function(resolve, reject) { $.ajax({ url, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); } Promise.all([ createPromise(&#39;js/arr.txt&#39;), createPromise(&#39;js/arr2.txt&#39;) ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 以上只是示例，jquery的作者当然想到了这一点，$.ajax()是有返回值的（高版本，低版本可能没有） let p = $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}); 可以将 $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}) 放到Promise.all()里面，代替上面的createPromise方法 Promise.race()同时处理多个Promise对象，有一个先完成的就停止 应用场景，同时向多个负载发送请求 Promise链式调用let test = new Promise((resolve, reject) =&gt; { let random = Math.random() if (random &gt; 0.5) { resolve(&#39;大于0.5&#39;) } else { reject(&#39;小于等于0.5&#39;) } }) let p = test.then((result) =&gt; { console.log(result) return result }).catch((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(&#39;last&#39;, result) }) console.log(p) ------------------------- Promise { &lt;pending&gt; } // p 大于0.5 // 或者小于，下同 大于0.5 last 大于0.5 promise 的 then 方法里面可以继续返回一个新的 promise 对象 下一个 then 方法的参数是上一个 promise 对象的 resolve 参数 catch 方法的参数是其之前某个 promise 对象的 rejecte 参数 一旦某个 then 方法里面的 promise 状态改变为了 rejected，则promise 方法连会跳过后面的 then 直接执行 catch；如果状态一直为fulfilled，catch里面的的代码不执行 catch 方法里面依旧可以返回一个新的 promise 对象 promies的三种状态是未决的pending（进行中），和已决的fulfilled（成功）/rejected（失败），reslove和reject是成功和失败的参数，在promies里调用参数之后then方法才会执行 参考资料： 深入理解Promise三种状态与链式调用 Promise对象then方法链式调用 生成器函数generator 普通函数：一直执行到最后 generator函数：中间可以暂停 function *show() { alert(&#39;1&#39;); yield; alert(&#39;2&#39;); } let obj = show(); obj.next(); obj.next(); 直接运行show()并不会有任何反应，用show来创建一个对象，用next方法可以执行，遇到yield停下，再执行next可以继续运行之后的部分 原理是把一个大函数的代码切分成多个小函数，每next一次执行一次 一个生成器中可以存在多个yield；注意函数命名方式 function *show(){}，带有星号 yield可以传参 第一个next无法传参，可以理解为generator的启动器，第二个next开始向第一个yield传参 function *show() { alert(&#39;1&#39;); let a = yield; alert(a); } let obj = show(); obj.next(); obj.next(10); -------------------------- // 打印结果 a=10 有返回值 function *show() { alert(&#39;1&#39;); let a = yield &#39;axc&#39; + &#39;ac&#39;; alert(a); // 10 // 如果这里return 55，那么下边b1的value就是55 } let obj = show(); let a1 = obj.next(); console.log(a1); // {value: &quot;axcac&quot;, done: false} let b1 = obj.next(10); console.log(b1); // {value: undifind, done: true} 一个yield相当于一个被分解成小函数的return 总结：第一个yield返回的值给了第一个next，第二个next的参数给了第一个yield 附：ES7 async awaitasync function doSome() { try { let data1 = await function(data); let data2 = await function(data1); let data3 = await function(data2); } catch(err) { console.log(&quot;Error:&quot; + err); } } 用同步的方式实现异步 await的返回值是promise；await后面可以用Promise.all()执行多个Promise操作 awat 外面必须包裹着async， 把await和成功后的操作放到try里，失败的放在catch 参考资料： async和await","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"VS Code 快捷键","slug":"资源/VS Code 快捷键","date":"2020-07-14T07:29:20.384Z","updated":"2020-09-05T09:40:22.620Z","comments":true,"path":"2020/07/14/资源/VS Code 快捷键/","link":"","permalink":"https://easyremember.cn/2020/07/14/资源/VS Code 快捷键/","excerpt":"","text":"VS Code 快捷键打开一个新窗口 Ctrl+Shift+N 关闭窗口 Ctrl+Shift+W 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 复制或剪切当前行/当前选中内容 Ctrl+C 、 Ctrl+V 代码格式化： Shift+Alt+F 上下移动一行 Alt+Up 或 Alt+Down 向上向下复制一行 Shift+Alt+Up 或 Shift+Alt+Down 在当前行下方插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 移动到行首 Home 移动到行尾 End 移动到文件结尾 Ctrl+End 移动到文件开头 Ctrl+Home 移动到定义处 F12 定义处缩略图 只看一眼而不跳转过去 Alt+F12 找到所有的引用 Shift+F12 同时修改本文件中所有匹配的 Ctrl+F12 重命名 比如要修改一个方法名，可以选中后按 F2，输入新名字，回车，则所有该方法的引用也都同步更新了 跳转到下一个 Error 或 Warning 当有多个错误时可以按 F8 逐个跳转 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Hello World","slug":"生活/hello-world","date":"2020-07-14T07:29:20.383Z","updated":"2020-09-05T09:36:29.977Z","comments":true,"path":"2020/07/14/生活/hello-world/","link":"","permalink":"https://easyremember.cn/2020/07/14/生活/hello-world/","excerpt":"","text":"2020-07-13 博客诞生","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://easyremember.cn/tags/hello/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]}]}