{"meta":{"title":"前端小枫","subtitle":"","description":"","author":"小枫","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-07-13T12:13:10.594Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-07-13T12:13:10.595Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-13T12:13:10.596Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-07-13T12:13:10.595Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"思途实训day2","slug":"STDay 2","date":"2020-07-22T08:57:04.870Z","updated":"2020-07-22T08:57:39.828Z","comments":true,"path":"2020/07/22/STDay 2/","link":"","permalink":"/2020/07/22/STDay 2/","excerpt":"","text":"Day 2字体选择： 中文：微软雅黑， 宋体，黑体 英文：arial 字体大小： 网页最小字号：12px， 不重要信息 一般用的最小字号：14px 精确抠图解锁原背景，新建图层填充鲜艳的颜色，例如绿色 用魔棒工具选择背景色，调整容差值，右键选择【调整边缘】 调整参数 菱形方格 制作一个这样的菱形方格 用矩形工具选择一个矩形框填充一个颜色，【ctrl】+【T】自由变换，按住shift旋90度 在图层调节描边，内阴影和投影 就可以看到效果图中的样式 图层蒙版将要贴入的图片拖拽至目标图层上方 注意在图层区域要将两图层放在一起 左上角有自动选择，点一下就可以定位图层 在两图层之间按住【alt】+鼠标左键 图层区会变成 显示的样式就会变成 图标绘制 锚点工具使用 首先利用椭圆工具绘制黄色圆形，然后复制两份 利用圆角矩形工具绘制蓝色矩形，绘制完成之后按【A】键选中元素出现锚点，按住【ctrl】用鼠标拖拽锚点成为一个梯形 在梯形内绘制三个圆角矩形，填充背景色构造成镂空的感觉 绘制底座，使用圆角矩形，使用锚点工具选择右上角两个点，【delete】，然后将描边改为白色 使用钢笔工具绘制上面的把手，钢笔工具点击一个点，再点第二个点不要松手，调整弧度至合理，使用上面底座相同的配置即可 钢笔工具在使用的时候如果出现角度很别扭的时候，可以在上一个点调好之后不松手，按住【alt】鼠标移动调节手柄 切图将所有的背景色全部隐藏，用切片工具画出切片区域，存储为web格式","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"/tags/思途实训/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"思途实训day1","slug":"STDay 1","date":"2020-07-22T07:27:01.446Z","updated":"2020-07-22T07:38:21.191Z","comments":true,"path":"2020/07/22/STDay 1/","link":"","permalink":"/2020/07/22/STDay 1/","excerpt":"","text":"Day 1PhotoShop操作快捷键 图层复制：【Ctrl】+【J】 自由变换：【Ctrl】+【T】 画笔工具：【B】，画笔调节：粗——右中括号，细——左中括号 放大：【ctrl】+【space】，缩小：【ctrl】+【alt】+【space】，抓手：【space】 盖印：【ctrl】+【alt】+【shift】+【e】 首选项：【ctrl】+【k】 填充前景色：【alt】+【delete】，填充背景色：【ctrl】+【delete】 移动工具：【v】 编组：【ctrl】+【g】 制作大头像调节图层素材图片 1 复制一个图层（可使用ctrl+j，也可以拖拽图层到下方的新建图层图标） 2 ctrl+t自由变换图层，缩放到合适的比例（按住shift等比缩放） 3 调节新图层透明度，50%-60%合适 4 将两图层下巴对齐 5 在小图层上新建蒙版 6 用黑色画笔将大图层头部涂黑，涂完之后将不透明度调至100%，如果有多余部分使用白色画笔涂回去（硬度调为0） 7 使用裁切工具只保留需要的部分，盖印生成图层 成果图如下 图层修饰 滤镜中点开液化 使用膨胀工具在两眼位置分别点击两下将眼部放大 使用褶皱工具将鼻子和嘴缩小 使用左推工具将脸收一下 如果拖坏了可以使用重建工具将要恢复的地方涂一下 GIF制作窗口打开时间轴，新建帧动画 在图层中控制要显示的帧然后添加关键帧 调节每一帧的时间 导出：存储为web格式，调节为GIF格式 网页设计项目立项——分析市场环境——解决用户痛点 仿照图 自己做的设计图： 渐变色：在选区内添加渐变图层，否则会使整个背景全部渐变 选择多个图层：选中第一个图层，按住shift选中最后一个图层 要选中某一图层的某一部分：先用多边形框选工具选出大致部分，然后ctrl+alt+shift+点击要选中部分的图层","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"/tags/思途实训/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Typora图片自动上传到图床","slug":"Typora图片自动上传到图床","date":"2020-07-15T11:50:22.787Z","updated":"2020-07-15T13:53:48.283Z","comments":true,"path":"2020/07/15/Typora图片自动上传到图床/","link":"","permalink":"/2020/07/15/Typora图片自动上传到图床/","excerpt":"","text":"Typora图片自动上传到图床你是否还在为找不到可靠的图床而烦恼 是否害怕图床网站关闭资源丢失 是否担心资源不能管理而发愁 今天他来了 1 下载安装picGo地址在这里，根据需要的版本进行下载 下载完成后进行安装 安装完之后在桌面右下角图标打开picGo详细界面 2 配置picGo图床+giteepicGo支持多个图床 这里主要说一下gitee新建一个公开的仓库，私有的在相册和Typora无法显示 搜索插件gitee（需要安装Node环境） 据说是两个都可以，我只试过了gitee，安装好之后在上面的图床列表里就会出现gitee图床 这里是配置信息 owner：gitee用户名 repo：gitee仓库名 path：路径，存放到根目录可以不用写 token：gitee个人令牌 message：可以不写 关于gitee个人令牌的获取 点开gitee的设置，在左侧栏找到私人令牌，然后点击生成新令牌 描述可以随便写一下，然后点击确认会生成一个token 将token复制到picGo中就可以了 3 配置Typora+picGo在Typora的偏好设置中将插入图片改为上传图片，上传服务修改为picGo App，并选择到安装目录 点击验证 如果出现false情况，看一下连接中的端口号，然后到picGo的设置中找到Server服务 将端口号修改一致 然后保存，再试一下验证","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ES6笔记","slug":"ES6笔记","date":"2020-07-15T07:24:55.780Z","updated":"2020-07-18T11:12:44.926Z","comments":true,"path":"2020/07/15/ES6笔记/","link":"","permalink":"/2020/07/15/ES6笔记/","excerpt":"","text":"ES6笔记变量let和constvar存在的问题 可以重复声明 无法限制修改 没有块级作用域 ES6新的定义变量 let 不能重复声明 变量，可以修改 块级作用域 const 不能重复声明 常量，不能修改 块级作用域 最大的区别：const一经定义值不能再变 函数箭头函数let show = function(n1,n2) { return n1-n2; } ----------等价-------------- let show = (n1, n2) =&gt; { return n1-n2; } 如果只有一个参数，()可以省略 let show = (n) =&gt; { return n; } --------省略-------- let show = n =&gt; { return n; } 如果只有一个return，{}可以省略 let show = n =&gt; { return 2*n; } -------省略-------- let show = n =&gt; 2*n; 箭头函数的this不会变：this指向的是当前对象，传统的function需要定义一个const that= this才能在里面的函数访问到最外层的this，箭头函数不会改变this指向，也就是说，无需定义that就可以用this访问原来的对象 箭头函数的优势和劣势 参数...args接收参数 命名随意，但必须放到参数最后，用于收集剩余参数 let show = function (a, b, ...args) { alert(a); alert(b); alert(args); } show(14,2,3,4,5); 多余的参数将会由args接收 展开数组 展开后效果跟直接把数组放在那一样 let arr = [1,2,3,4]; show(...arr);// == show(1,2,3,4) ------------------- let arr1=[1,2,3]; let arr2=[4,5,6]; let arr=[...arr1,...arr2]; // == let arr=[1,2,3,4,5,6]; 默认参数let show = function (a, b=5, c=10) { XXX } show(12); 当传的参数只有一个的时候，b默认是5，c默认是10； 当传参数大于一位时，会依次顶替默认参数 解构赋值左右两边结构必须一样 let [a, b, c] = [1,2,3] let {a,b,c} = {a:1,b:2,c:3} 右边必须合法 声明和赋值不能分开 let [a, b] = [5, 12];// 合法 ------------------------ let [a, b]; [a, b] = [5, 12];// 报错，解构赋值声明和赋值不能分开 数组map映射————一个对一个 let arr = [1, 2, 3, 4]; let result = arr.map(item =&gt; item * 2); // result 2,4,6,8 reduce汇总————一堆出来一个 let arr= [12, 8, 9, 16]; let result = arr.reduce( function (tmp, item, index) { return tmp + item; }) function中的三个参数分别是存储的和的中间数、要计算的数、索引 filter过滤器————保留一部分 let arr = [10,3,16,15,21,20]; let result = arr.filter(item =&gt; { if(item % 3 == 0) { return true; } return false; }); alert(result); -------------------------------- // json类型 let arr = [ {name: &#39;tom&#39;, price: 75}, {name: &#39;jerry&#39;, price: 60} ]; let result = arr.filter(item =&gt; { return item.price&gt;65; }); console.log(result); 当filter中的方法返回true的时候数据保留，返回false数据删除 forEach循环（迭代）————每一项进行操作 吧数组中的每一项都放到方法中执行 字符串两个新方法startsWith 匹配前面的字符串，相同返回true，不相同返回false endWith 匹配末尾的字符串，相同返回true，不相同返回false 应用：检测文件后缀 字符串模板字符串拼接 let a = &#39;AScri&#39;; let str = `ECM${a}pt6`; alert(str); // str=ECMAScript6 注意：插入字符串的字符串要用反单引号（数字键盘1左边的那个） 应用，拼接字符串 let html = `&lt;div&gt; &lt;h1&gt;${title}&lt;/h1&gt; &lt;p&gt;${content}&lt;/p&gt; &lt;/div&gt;`; 优势：直接把字符串插到字符串中；可以折行 面向对象语法class User { constructor(name, age) { this.name = name; this.age = age; } showName() { alert(this.name); } showAge() { alert(this.age); } } var user = new User(&#39;Tom&#39;, 18); user.showName(); user.showAge(); 对象创建关键字class，相当于java的类 构造器关键字constructor，相当java的构造函数 方法直接写在class里面，不需要加function 继承class VipUser extends User { constructor(name, age, level) { super(name, age); this.level = level; } showLevel() { alert(this.level); } } var vip = new VipUser(&#39;Tom&#39;, 18, 3); vip.showName(); vip.showAge(); vip.showLevel(); 继承关键字extens，相当于java的继承 构造函数中使用super关键字，调用父类的构造函数 添加新的属性和新的方法 JSON标准写法 只能用双引号 所有名字都必须用引号括起来 { &quot;a&quot;: &quot;abx&quot;, &quot;b&quot;: 12, &quot;c&quot;: true } 格式化为字符串let json = {a: 11, b: 12}; alert(JSON.stringify(json)); JSON.stringify()得到的结果是一个字符串 格式化为JSONlet str = &#39;{&quot;a&quot;: 11, &quot;b&quot;: 12}&#39;; console.log(JSON.parse(str)); JSON.parse()得到的结果是一个json对象，但是，字符串的内容必须符合json格式标准，另外，双引号的外面是单引号 简写属性名简写 let a = 12; let b = 5; let json = {a, b, c: 15}; console.log(json); 当已经存在的值和json属性名一样的时候，可以只写值，不一样的可以按照json格式添加 这里的json指的是json字面量 方法简写 let json = { a: 12, show() { console.log(this.a); } } json.show(); 方法可以只写方法名，省略 function Promise作用：消除异步操作，用同步的方式来写异步代码 异步：操作之间没啥关系，同时进行多个操作；代码复杂 同步：同时只能做一件事，前面的事没干完后面的事不能开始；代码简单 封装ajax（基于jquery） let ajax = new Promise(function (resolve, reject) { $.ajax({ url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); ajax.then(result =&gt; { alert(result); }, err =&gt; { console.log(err); }) Promise.all()当有两个Promise对象时，可以使用Promisr.all()处理两个Promise对象 Promise.all([ ajax1, ajax2 ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 这里注意，当使用.all处理多个Promise对象时，有一个出错就会报错，全部成功才会执行成功的回调函数 有多个ajax请求不同地址的时候可以，再次封装 function createPromise(url) { return new Promise(function(resolve, reject) { $.ajax({ url, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); } Promise.all([ createPromise(&#39;js/arr.txt&#39;), createPromise(&#39;js/arr2.txt&#39;) ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 以上只是示例，jquery的作者当然想到了这一点，$.ajax()是有返回值的（高版本，低版本可能没有） let p = $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}); 可以将 $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}) 放到Promise.all()里面，代替上面的createPromise方法 Promise.race()同时处理多个Promise对象，有一个先完成的就停止 应用场景，同时向多个负载发送请求 Promise链式调用let test = new Promise((resolve, reject) =&gt; { let random = Math.random() if (random &gt; 0.5) { resolve(&#39;大于0.5&#39;) } else { reject(&#39;小于等于0.5&#39;) } }) let p = test.then((result) =&gt; { console.log(result) return result }).catch((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(&#39;last&#39;, result) }) console.log(p) ------------------------- Promise { &lt;pending&gt; } // p 大于0.5 // 或者小于，下同 大于0.5 last 大于0.5 promise 的 then 方法里面可以继续返回一个新的 promise 对象 下一个 then 方法的参数是上一个 promise 对象的 resolve 参数 catch 方法的参数是其之前某个 promise 对象的 rejecte 参数 一旦某个 then 方法里面的 promise 状态改变为了 rejected，则promise 方法连会跳过后面的 then 直接执行 catch；如果状态一直为fulfilled，catch里面的的代码不执行 catch 方法里面依旧可以返回一个新的 promise 对象 promies的三种状态是未决的pending（进行中），和已决的fulfilled（成功）/rejected（失败），reslove和reject是成功和失败的参数，在promies里调用参数之后then方法才会执行 参考资料： 深入理解Promise三种状态与链式调用 Promise对象then方法链式调用 生成器函数generator 普通函数：一直执行到最后 generator函数：中间可以暂停 function *show() { alert(&#39;1&#39;); yield; alert(&#39;2&#39;); } let obj = show(); obj.next(); obj.next(); 直接运行show()并不会有任何反应，用show来创建一个对象，用next方法可以执行，遇到yield停下，再执行next可以继续运行之后的部分 原理是把一个大函数的代码切分成多个小函数，每next一次执行一次 一个生成器中可以存在多个yield；注意函数命名方式 function *show(){}，带有星号 yield可以传参 第一个next无法传参，可以理解为generator的启动器，第二个next开始向第一个yield传参 function *show() { alert(&#39;1&#39;); let a = yield; alert(a); } let obj = show(); obj.next(); obj.next(10); -------------------------- // 打印结果 a=10 有返回值 function *show() { alert(&#39;1&#39;); let a = yield &#39;axc&#39; + &#39;ac&#39;; alert(a); // 10 // 如果这里return 55，那么下边b1的value就是55 } let obj = show(); let a1 = obj.next(); console.log(a1); // {value: &quot;axcac&quot;, done: false} let b1 = obj.next(10); console.log(b1); // {value: undifind, done: true} 一个yield相当于一个被分解成小函数的return 总结：第一个yield返回的值给了第一个next，第二个next的参数给了第一个yield 附：ES7 async awaitasync function doSome() { try { let data1 = await function(data); let data2 = await function(data1); let data3 = await function(data2); } catch(err) { console.log(&quot;Error:&quot; + err); } } 用同步的方式实现异步 await的返回值是promise；await后面可以用Promise.all()执行多个Promise操作 awat 外面必须包裹着async， 把await和成功后的操作放到try里，失败的放在catch 参考资料： async和await","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"VS Code 快捷键","slug":"VS Code 快捷键","date":"2020-07-14T07:29:20.384Z","updated":"2020-07-18T11:11:16.205Z","comments":true,"path":"2020/07/14/VS Code 快捷键/","link":"","permalink":"/2020/07/14/VS Code 快捷键/","excerpt":"","text":"VS Code 快捷键打开一个新窗口 Ctrl+Shift+N 关闭窗口 Ctrl+Shift+W 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 复制或剪切当前行/当前选中内容 Ctrl+C 、 Ctrl+V 代码格式化： Shift+Alt+F 上下移动一行 Alt+Up 或 Alt+Down 向上向下复制一行 Shift+Alt+Up 或 Shift+Alt+Down 在当前行下方插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 移动到行首 Home 移动到行尾 End 移动到文件结尾 Ctrl+End 移动到文件开头 Ctrl+Home 移动到定义处 F12 定义处缩略图 只看一眼而不跳转过去 Alt+F12 找到所有的引用 Shift+F12 同时修改本文件中所有匹配的 Ctrl+F12 重命名 比如要修改一个方法名，可以选中后按 F2，输入新名字，回车，则所有该方法的引用也都同步更新了 跳转到下一个 Error 或 Warning 当有多个错误时可以按 F8 逐个跳转 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-14T07:29:20.383Z","updated":"2020-07-15T09:59:41.550Z","comments":true,"path":"2020/07/14/hello-world/","link":"","permalink":"/2020/07/14/hello-world/","excerpt":"","text":"2020-07-13 博客诞生","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"hello","slug":"hello","permalink":"/tags/hello/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}