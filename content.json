{"meta":{"title":"前端小枫","subtitle":"","description":"","author":"小枫","url":"https://fengjing95.github.io"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"about/index.html","permalink":"https://fengjing95.github.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"bangumi/index.html","permalink":"https://fengjing95.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"client/index.html","permalink":"https://fengjing95.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-07-13T12:13:10.594Z","comments":true,"path":"comment/index.html","permalink":"https://fengjing95.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-07-13T12:13:10.595Z","comments":false,"path":"lab/index.html","permalink":"https://fengjing95.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"donate/index.html","permalink":"https://fengjing95.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-07-13T12:13:10.595Z","comments":true,"path":"links/index.html","permalink":"https://fengjing95.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"rss/index.html","permalink":"https://fengjing95.github.io/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-13T12:13:10.596Z","comments":false,"path":"music/index.html","permalink":"https://fengjing95.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"tags/index.html","permalink":"https://fengjing95.github.io/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://fengjing95.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"video/index.html","permalink":"https://fengjing95.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"高级组件provide/inject","slug":"高级组件provide-inject","date":"2020-08-12T06:56:52.036Z","updated":"2020-08-12T06:58:28.180Z","comments":true,"path":"2020/08/12/高级组件provide-inject/","link":"","permalink":"https://fengjing95.github.io/2020/08/12/高级组件provide-inject/","excerpt":"","text":"高级组件provide / inject官方文档介绍 类型 provide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是： 一个字符串数组，或 一个对象，对象的 key 是本地的绑定名，value 是： 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或 一个对象，该对象的： from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol) default 属性是降级情况下使用的 value 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 人话开始简单的来说就是在父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量。 示例父组件中使用provide定义一个变量 provide: { father: &quot;demo&quot;, }, 子组件使用inject引入变量 inject: [ &quot;father&quot; ], 再来看一下浏览器效果 可以看到浏览器的控制台成功的打印出了这个变量的值 上面提到，这种方式绑定的变量不是响应式的，我们来尝试一下 首先给父组件添加按钮绑定事件修改provide的值 provideHandle() { this.father = &quot;new demo&quot;; console.log(this.father); }, 然后来看效果 可以看到当点击按钮时，父组件的值已经改变，但是子组件中显示的依旧是原来的‘demo’ 响应方法：将父组件this对象作为返回值传递给子组件 废话少说，看效果 可以看到，子组件中的数据相应的发生了变化 更多示例","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Express中使用Sequelize实现ORM","slug":"Express中使用Sequelize实现ORM","date":"2020-08-10T06:33:37.962Z","updated":"2020-08-12T07:00:47.431Z","comments":true,"path":"2020/08/10/Express中使用Sequelize实现ORM/","link":"","permalink":"https://fengjing95.github.io/2020/08/10/Express中使用Sequelize实现ORM/","excerpt":"","text":"Express中使用Sequelize实现ORM起步第一步当然是环境，首先使用Express生成器安装express环境 express myapp // myapp，你自己的项目名称（需要全局安装express） npm install 然后安装sequelize npm install --save sequelize npm install --save mysql2 // 驱动，这里主要说mysql，其他的类型见官网文档 连接连接到数据库必须有sequelize实例，实例化方法如下 const connect = new DB(&#39;dbname&#39;, &#39;username&#39;, &#39;password&#39;, { host: &#39;localhost&#39;, dialect: &#39;mysql&#39; }) 配置好实例之后可以使用.authenticate()来测试连接 connect.authenticate().then(() =&gt; { console.log(&#39;连接成功&#39;) }).catch(error =&gt; { console.error(&#39;连接失败:&#39;, error); }) 关闭连接 默认情况下，Sequelize将使连接保持打开状态，并对所有查询使用相同的连接。如果需要关闭连接，请调用sequelize.close()（它是异步的并返回Promise） 模型基础定义模型 模型是Sequelize的本质。模型是代表数据库中表的抽象。在Sequelize中，它是扩展Model的类 使用sequelize.define方法来定义模型，sequelize会根据定义的模型名称的复数自动建表 const Book = connect.define(&#39;Book&#39;, { bookName: DB.STRING, // 属性名： 数据类型 bookCounts: DB.INTEGER, detail: DB.STRING, }, { timestamps: false // 自动生成createAt和updateAt }) 此外也可以直接提供表名 sequelize.define(&#39;Book&#39;, { // ... attributes }, { tableName: &#39;literature&#39; }); 更多数据类型： // CHAR Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.TEXT(&#39;tiny&#39;) // TINYTEXT // NUMBER Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 10) // FLOAT(11,10) Sequelize.DOUBLE // DOUBLE Sequelize.DOUBLE(11) // DOUBLE(11) Sequelize.DOUBLE(11, 10) // DOUBLE(11,10) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) // TIME Sequelize.DATE // mysql / sqlite 为 DATETIME, postgres 为带时区的 TIMESTAMP Sequelize.DATE(6) // DATETIME(6) 适用 mysql 5.6.4+. 小数秒支持最多6位精度 Sequelize.DATEONLY // DATE 不带时间. // BOOLEAN Sequelize.BOOLEAN // TINYINT(1) //ENUM Sequelize.ENUM(&#39;value 1&#39;, &#39;value 2&#39;) // 一个允许值为&#39;value 1&#39;和&#39;value 2&#39;的ENUM // blob Sequelize.BLOB // BLOB (PostgreSQL 为 bytea) Sequelize.BLOB(&#39;tiny&#39;) // TINYBLOB (PostgreSQL 为 bytea. 其余参数是 medium 和 long) // GEOMETRY Sequelize.GEOMETRY // Spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. Sequelize.GEOMETRY(&#39;POINT&#39;) // 带有 geometry 类型的 spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. Sequelize.GEOMETRY(&#39;POINT&#39;, 4326) // 具有 geometry 类型和 SRID 的 spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. // unsigned 和 zerofill 属性 Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL 数据类型来源，掘金，云影sky的详细易用的 Sequelize 解读 模型同步使用model.async()方法来将模型与数据库同步 User.sync() -如果不存在则创建表（如果已经存在则不执行任何操作） User.sync({ force: true }) -这将创建表，如果该表已经存在，则将其首先删除 User.sync({ alter: true }) -这将检查数据库中表的当前状态（它具有哪些列，它们的数据类型等），然后在表中进行必要的更改以使其与模型匹配 创建模型实例使用model.build方法来创建模型实例 const jsBook = Book.build({ bookName: &#39;你不知道的JS&#39;, bookCounts: 3, detail: &#39;JS 进阶系列&#39;, }) 上面的创建实例之后使用jsBook.save();方法来保存到数据库 模型查询INSERT查询上面的模型保存还有一种简便方法，直接使用model.create方法，直接保存到数据库 Book.create({ bookName: &#39;你不知道的JS&#39;, bookCounts: 3, detail: &#39;JS 进阶系列&#39;, }) 可以看到数据库中已经生成了这条记录 控制台可以看到sql语句 SELECT查询find查询使用findAll方法查询整个表 Book.findAll() 效果图 可以使用attributes选项来进行列查询，数组中列出要查询的字段名 Book.findAll({ attributes: [&#39;id&#39;, &#39;bookName&#39;], }) 效果图 使用exclude删除一些选定的属性 Book.findAll({ attributes: { exclude: [&#39;bookCounts&#39;] }, }) 效果图 其他find查询 findByPk：使用提供的主键仅从表中获得一个条目 findOne：获取它找到的第一个条目（如果提供的话，它满足可选的查询选项） findOrCreate：查询不到实例就创建一个，返回值是实例（查到的或者创建的）和一个布尔值（创建为true） findAndCountAll：查询并计数，有两个返回值，一个是查询到的记录另一个是count where子句使用where选项可以进行where查询 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, id: 1 } }) // SELECT * FROM books WHERE bookName = &#39;你不知道的JS&#39; AND id = 1; 效果如图 有了AND就有OR，使用Op.or来进行or操作 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, id: { [Op.or]: [1, 2] } } }) // SELECT * FROM books WHERE bookName = &#39;你不知道的JS&#39; AND (id = 1 OR id = 2); 效果图 AND也可以使用Op.and来操作，但是易读性不强（不常用） Book.findAll({ where: { [Op.and]: [ { bookName: &#39;你不知道的JS&#39; }, { id: { [Op.or]: [1, 2] } } ] } }) sequelize提供了更多运算 const { Op } = require(&quot;sequelize&quot;); Post.findAll({ where: { [Op.and]: [{ a: 5 }, { b: 6 }], // (a = 5) AND (b = 6) [Op.or]: [{ a: 5 }, { b: 6 }], // (a = 5) OR (b = 6) someAttribute: { // Basics [Op.eq]: 3, // = 3 [Op.ne]: 20, // != 20 [Op.is]: null, // IS NULL [Op.not]: true, // IS NOT TRUE [Op.or]: [5, 6], // (someAttribute = 5) OR (someAttribute = 6) // Using dialect specific column identifiers (PG in the following example): [Op.col]: &#39;user.organization_id&#39;, // = &quot;user&quot;.&quot;organization_id&quot; // Number comparisons [Op.gt]: 6, // &gt; 6 [Op.gte]: 6, // &gt;= 6 [Op.lt]: 10, // &lt; 10 [Op.lte]: 10, // &lt;= 10 [Op.between]: [6, 10], // BETWEEN 6 AND 10 [Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15 // Other operators [Op.all]: sequelize.literal(&#39;SELECT 1&#39;), // &gt; ALL (SELECT 1) [Op.in]: [1, 2], // IN [1, 2] [Op.notIn]: [1, 2], // NOT IN [1, 2] [Op.like]: &#39;%hat&#39;, // LIKE &#39;%hat&#39; [Op.notLike]: &#39;%hat&#39;, // NOT LIKE &#39;%hat&#39; [Op.startsWith]: &#39;hat&#39;, // LIKE &#39;hat%&#39; [Op.endsWith]: &#39;hat&#39;, // LIKE &#39;%hat&#39; [Op.substring]: &#39;hat&#39;, // LIKE &#39;%hat%&#39; [Op.iLike]: &#39;%hat&#39;, // ILIKE &#39;%hat&#39; (case insensitive) (PG only) [Op.notILike]: &#39;%hat&#39;, // NOT ILIKE &#39;%hat&#39; (PG only) [Op.regexp]: &#39;^[h|a|t]&#39;, // REGEXP/~ &#39;^[h|a|t]&#39; (MySQL/PG only) [Op.notRegexp]: &#39;^[h|a|t]&#39;, // NOT REGEXP/!~ &#39;^[h|a|t]&#39; (MySQL/PG only) [Op.iRegexp]: &#39;^[h|a|t]&#39;, // ~* &#39;^[h|a|t]&#39; (PG only) [Op.notIRegexp]: &#39;^[h|a|t]&#39;, // !~* &#39;^[h|a|t]&#39; (PG only) [Op.any]: [2, 3], // ANY ARRAY[2, 3]::INTEGER (PG only) // In Postgres, Op.like/Op.iLike/Op.notLike can be combined to Op.any: [Op.like]: { [Op.any]: [&#39;cat&#39;, &#39;hat&#39;] } // LIKE ANY ARRAY[&#39;cat&#39;, &#39;hat&#39;] // There are more postgres-only range operators, see below } } }); UPDATE查询使用model.update方法来进行数据更新 Book.update({ bookCounts: 5 }, { where: { id: 2 } }) // UPDATE books SET bookCounts =5 WHERE id = 2; 修改后的数据如下 DELETE查询使用model.destory方法进行删除操作 Book.destory({ where: { id: 2 } }) 限制和分页使用limit和offset选项进行限制/分页 limit：每一页的记录数量限制 offset：第几页，从0开始 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, }， offset: parseInt(req.query.page) ? parseInt(req.query.page) : 0, limit: 1 }) 实用方法 进阶用法getter&amp;setter 事务","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://fengjing95.github.io/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"TypeScript学习笔记","slug":"TypeScript学习笔记","date":"2020-08-06T15:25:45.926Z","updated":"2020-08-06T15:28:43.822Z","comments":true,"path":"2020/08/06/TypeScript学习笔记/","link":"","permalink":"https://fengjing95.github.io/2020/08/06/TypeScript学习笔记/","excerpt":"","text":"TypeScript学习笔记1 简介TypeScript是由微软推出的编程语言，是javascript的超集，遵循ES5、ES6规范，拓展了js的语法 TypeScript更像是java等后端语言，可以开发大型企业项目，最新的前端框架基本都是使用了TS 2 安装npm install -g typescript cnpm以及yarn安装方式一样 3 编译及配置3.1 编译浏览器不识别ts代码，需要将ts代码编译为ES5的代码 新建index.ts脚本，编写代码 console.log(&quot;hello TS&quot;); 使用 tsc index.ts 命令进行编译 编译完成之后会生成index.js脚本，内容是 这一段代码看不出差别，来一段ts语法的代码 let str:String = &#39;feng&#39;; console.log(str); 再来看看编译出来的js脚本 3.2 在vscode中配置自动编译每次写完代码手动保存很不方便，可以使用配置文件自动生成js 在根目录下运行命令 tsc --init生成配置文件tsconfig.json 将outDir一行的注释打开，目录修改为要输出到的目录，不修改也可 点击选项卡终端-&gt;运行任务-&gt;typescript-&gt;tsc监视，然后再编写ts代码保存时就可以自动生成js了 4 数据类型ts为了使编写代码更规范增加了类型校验mts主要提供了以下几种类型的数据 布尔类型（boolean） 数字类型（number） 字符串类型（string） 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 4.1 布尔类型在变量标识符之后声明变量类型为boolean，那么这个变量只能接受布尔类型的赋值，如果赋值为其他类型的数据，在编译时会报错，例如 let isReal: boolean = 123; 定义布尔类型的变量isReal，然后为其赋值数字123，在编译时会抛出下面错误 意思是’123’不能赋值给boolean类型的变量 4.2 数值类型规则同布尔类型，声明的标识符是number 整形和浮点型都可以用number声明 4.3 字符串类型声明的标识符是string 4.4 数组类型声明方式有两种： 使用中括号 let arr:number[] = [1,2,3] // 数字类型的数组不能出现其它数据类型 使用泛型声明 let arr: Array&lt;number&gt; = [1, 2, 3] 4.5 元组类型let tuple:[string, number, boolean] = [&#39;feng&#39;, 11, true] 元组也是一种数组，可以指定数组的每一项的数据类型 4.6 枚举类型枚举类型用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。 枚举类型可以手动设置值 enum Flag { success = 1, error = -1 } let f: Flag = Flag.success console.log(f);// 1 // 另外一种手动设置的方式，只定义第一项，后面的依次递增 enum Animal { cat = 2, dog, snake } var a: Animal = Animal.snake; console.log(a); // 4 // 自定义值可以在任意位置，上面的代码汇中如果只定义dog=2，那么snake就是3 也可以使用默认值，默认值就是索引值 enum Color { blue, red, green } const c: Color = Color.blue; console.log(c); // 0 4.7 任意类型在上面的基本类型中，一旦定义了类型就不能再赋值其他类型的数据，否则就会报错 那如果想给一个变量赋值多种类型的数据就需要用到any来声明变量了 在ts文件中写入以下代码 var node = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 保存时会抛出以下错误 编译之后代码是可以运行的，但是存在问题 意思是node是一个Object类型，这时再给node声明Object类型 var node:Object = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 这时还会报错，因为进本数据类型中没有Object，这时就可以使用any类型了 var node: any = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 4.8 null和undefinednull和undefined是其他数据类型的子类 undefined声明变量是undefined类型之后，变量undefined不会报错，例如 但如果定义了undefined类型就不会报错 undefined一般用于联合类型 var num: number | undefined; num = 123; console.log(num); num可以是number类型，也可以是undefined null变量声明null之后只能为空值，如果为变量赋值就会报错 等于空值时不会报错 4.9 void类型用于定义没有返回值的方法 ((): void =&gt; { console.log(&#39;void&#39;); })() lambda表达式的写法 4.10 never类型其他类型，表示从不会出现（包括null和undefined的子类型），被never声明的变量只能被never类型的数据赋值 5 函数5.1 声明函数5.1.1 命名函数在TypeScript中声明函数时，要声明参数类型以及函数返回值类型 没有返回值使用void进行声明 function run(): string { return &#39;string&#39; } 在声明函数返回值类型之后，返回值的类型必须是声明的类型，否则报错 5.1.2 匿名函数在TypeScript中定义匿名函数也需要声明返回值类型 var func2 = function (): number { return 123; } 同样，返回值需要符合声明的返回值类型，不一致则会报错 5.2 传参定义一个方法，接收一个firstname和一个lastname，返回一个fullname function getName(firstname: string, lastname: string): string { return `${firstname}--${lastname}` } console.log(getName(&#39;Chan&#39;, &#39;Jack&#39;)); // Chan--Jack 匿名函数同样的在参数后声明类型 5.2.1 可选参数在func3中，有两个参数，现在调用func3，只传一个参数 function func3(name: string, age: number): void { console.log(name + &quot;--&quot; + age); } func3(&#39;zhangsan&#39;); 编译时会报错，原因是少了一个参数 在可选参数后添加?，表示参数可以有也可以没有 可选参数必须放到参数的最后面 5.2.2 默认参数在ES5中不可以设置默认参数，在ES6和TS中可以设置默认参数 function func3(name: string, age: number=20): void { console.log(name + &quot;--&quot; + age); } func3(&#39;zhangsan&#39;); // zahngsan--20 当默认参数在最后时，设置默认参数之后可以不传参数，使用默认的值，当默认参数在前面时必须传参数 5.2.3 剩余参数当不确定参数的数量时，可以使用ES6的扩展运算符（...） function getSum(...args: number[]): void { var result: number = 0; args.forEach(element =&gt; { result += element }); console.log(result); } getSum(1, 2, 3, 4) // 10 getSum(1, 2, 3, 4, 5) // 15 也可以固定前几个参数，然后后面的用扩展运算符接收 function getSum2(a: number, ...args: number[]): void { var result: number = a; args.forEach(element =&gt; { result += element }); console.log(result); } getSum2(1, 2, 3, 4) // 10 5.3 函数重载 java中的重载：两个或两个以上同名函数，但是他们接收的参数不一样，这时会出现函数重载 TypeScript中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的 function getInfo(name: string): string; function getInfo(age: number): string; function getInfo(str: any): any { if (typeof str === &#39;string&#39;) { return &#39;我叫&#39; + str } else { return &#39;我的年龄是&#39; + str } } console.log(getInfo(&#39;zahngsan&#39;)); console.log(getInfo(12)); 来看下结果 显然，ts在通过这种方式为一个函数实现了两种功能，但是，传参的类型必须在重载的函数参数之内，如果匹配不到就会报错 6 类6.1 对比ES56.1.1 定义类在ES5中使用构造函数创建对象，直接在function内部添加属性和方法 function Person() { this.name = &#39;zhangsan&#39; this.getInfo = function () { console.log(this.name); } } var p = new Person(); p.getInfo(); // zhangsan 还可以通过原型链的方式给对象添加属性和方法 Person.prototype.age = 20; Person.prototype.getAge = function () { console.log(this.age); } var p = new Person(); p.getAge(); // 20 但是，使用原型链添加的引用类型属性会被所有实例共享，意思就是当某一实例的该属性变化时，其他实例的属性都会改变 Person.prototype.friends = [&#39;f1&#39;, &#39;f2&#39;]; Person.prototype.getFriends = function () { console.log(this.friends); } var p = new Person(); p.getFriends(); var p2 = new Person(); p2.friends.push(&#39;f3&#39;); p.getFriends(); p2.getFriends(); 可以看到，改变一个实例的引用类型的属性，另一个实例也变了；基本数据类型不存在这种问题 6.1.2 静态方法ES5中给对象添加静态方法非常简单 Person.static = function () { console.log(&#39;静态方法&#39;); } Person.static(); // 静态方法 静态方法不需要实例化就可以调用，并且，对象实例不可以调用静态方法 6.1.2 继承ES5中通过对象冒充来实现继承 function People() { Person.call(this); } var peo = new People(); peo.getInfo(); // zhangsan 此外也可以通过原型的方法来实现继承 function People() { } People.prototype = new Person(); var peo = new People(); peo.getInfo(); 但是在实例化子类时无法给父类传参 function Person(name) { this.name = name; this.getInfo = function () { console.log(this.name); } } function People() { } People.prototype = new Person(); var peo = new People(&#39;zhangsan&#39;); peo.getInfo(); // undefined 然后就有了原型链+构造函数的组合继承模式——寄生组合继承 function People(name) { Person.call(this, name) } People.prototype = Person.prototype; var peo = new People(&#39;zhangsan&#39;); peo.getInfo(); // zhangsan 6.2 TypeScript中的类6.2.1 定义类在TS中，使用class关键字来定义类，类需要实例化时需要添加构造器 class Person { name: string; // 属性 constructor(n: string) { // 构造函数，实例化时触发 this.name = n; } getName(): string { return this.name; } setName(name: string): void { this.name = name } } var p: Person = new Person(&#39;李四&#39;); console.log(p.getName()); // 李四 p.setName(&#39;张三&#39;); console.log(p.getName()); // 张三 拓展——params方式实例化class Article { title: string | undefined; desc: string | undefined; status: number | undefined constructor(params: { title: string | undefined, desc: string | undefined, status?: number | undefined }) { this.title = params.title; this.desc = params.desc; this.status = params.status; } } var newArticle: Article = new Article({ title: &#39;大事件&#39;, desc: &#39;都是小事&#39; }) console.log(newArticle); 通过向构造器传入json对象，然后使用索引值来实例化对象 6.2.2 继承TS中继承有专门的关键字extends，需要配合super初始化父类构造函数来实现继承 class People extends Person { constructor(name: string) { super(name); } } var peo = new People(&#39;王五&#39;); console.log(peo.getName()); // 王五 6.2.3 修饰符 public：公有，在类里面、子类、外部都可以访问 protected：保护，在类里面，子类中可以访问 private：私有，只有类里面可以访问 属性不加修饰符默认是public 6.2.4 静态属性&amp;静态方法使用static修饰符声明静态方法，但是静态方法无法直接获取类中的属性，只能获取静态属性（同样用static修饰） class Person { name: string; static age: number = 20; constructor(n: string) { // 构造函数，实例化时触发 this.name = n; } getName(): string { return this.name; } setName(name: string): void { this.name = name } static log(): void { console.log(`年龄是${this.age}`); } } Person.log(); // 年龄是20 6.2.5 多态父类定义一个方法不去实现，让继承他的子类去实现，每一个子类有不同的表现 class Animals { name: string; constructor(name: string) { this.name = name; } getInfo(): void { } } class Dog extends Animals { constructor(name: string) { super(name); } getInfo(): void { console.log(this.name + &#39;是一只狗&#39;); } } class Cat extends Animals { constructor(name: string) { super(name); } getInfo(): void { console.log(this.name + &#39;是一只猫&#39;); } } var cat: Cat = new Cat(&#39;kitty&#39;); cat.getInfo(); // kitty是一只猫 var dog: Dog = new Dog(&#39;Tony&#39;); dog.getInfo(); // Tony是一只狗 这段代码中有一个父类Animals，两个子类Dog和Cat分别继承Animals，Animals定义了一个getInfo方法，两个子类中分别重写了这个方法，实现了不同的功能 6.2.6 抽象类 提供其他类继承的基类，不能被实例化；用absort关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现；抽象方法只能放在抽象类中 abstract class AbstractAnimals{ abstract func1(): void; abstract func2(): string; } class Mouse extends AbstractAnimals{ func1(): void { console.log(&#39;function 1&#39;); } func2(): string { return &#39;function 2&#39; } } 7 接口 在面向对象程序设计中，接口是一种规范的定义，它规定了行为和动作的规范，起到了限制和规范的作用。接口定义了某一批类需要遵守的规范，不关心这些类内部的状态数据，也不关心方法实现细节，只规定类需要提供哪些方法。类似于java中的类，更加灵活。 定义接口关键字：interface 7.1 属性接口属性接口就是对json格式的限制 interface FullName { firstName: string; lastName: string; } function getFullName(name: FullName) { return `${name.firstName}----${name.lastName}` } console.log(getFullName({ firstName: &#39;zhang&#39;, lastName: &#39;san&#39; })); // zhang----san 在这段代码中，定义了一个FullName接口，方法getFullName参数name要满足这个接口，如果不满足接口定义的规则就会报错 并且，参数必须且只能有接口定义的 数据项，如果参数一用对象，name该对象必须包含接口定义的项并且符合数据类型限制 可以使用 ? 定义可选属性，用法同可选参数 7.2 函数类型接口对方法传入的参数以及返回值进行约束 interface FuncRule { (key: string, value: string): string; } var funcIn: FuncRule = function (key: string, value: string): string { return `${key}---${value}` } console.log(funcIn(&#39;name&#39;, &#39;张三&#39;)); 接口中规定了两个参数和他们的类型以及返回值的类型，实现这个接口的函数就必须有这两个参数和返回值。参数类型不符合规定就会报错 7.3 可索引接口对数组、对象的约束 7.3.1 对数组的约束interface UserArr{ [index:number]:string; } var arr:UserArr=[&#39;aa&#39;, &#39;bb&#39;] console.log(arr[0]) 接口规定了索引值是number类型，value是string类型（开始这里没看懂，数组的索引还能不是number？？？继续往下看） 7.3.2 对对象的约束interface UserObj{ [index:string]:string } var arr:UserObj = { name: &#39;alex&#39; } 这里明白了，对数组的约束和对对象的约束不是具体的分类，索引值是number就限定了数组，索引值是string就限定了对象 7.4 类类型接口类类型约束和抽象有些类似，这里最接近于java中的接口类 // 接口 interface AnimalsInterface { name: string; eat(food: string): void; } // 实现类 class Tigger implements AnimalsInterface { name: string; constructor(name: string) { this.name = name; } eat(food: string): void { console.log(`${this.name}吃的是${food}。`); } } // 实例化 var t: Tigger = new Tigger(&#39;泰哥&#39;); t.eat(&#39;猪肉&#39;); // 泰哥吃的是猪肉。 在实现接口方法的时候，参数可以没有 7.5 接口扩展（接口继承）interface Animals { eat(): void; } interface People extends Animals { name: string; work(): void; } class Chinese implements People { name: string; constructor(name: string) { this.name = name; } work(): void { console.log(this.name + &#39;可以工作&#39;); } eat(): void { console.log(this.name + &#39;吃大餐&#39;); } } var ming: Chinese = new Chinese(&#39;小明&#39;); ming.work(); 接口People继承了接口Animals，在实现People接口的时候，需要同时实现Animals中定义的内容，如果去掉了Animals中的方法就会报错 8 泛型 泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。将类型参数化以达到代码复用提高软件开发工作效率的一种数据类型。泛型类]是引用类型，是堆对象，主要是引入了类型参数这个概念。 ——百度百科《泛型》 8.1 泛型变量先来看个例子 function getValue&lt;T&gt;(value: T): string { return &#39;获得的值是&#39; + value; } console.log(getValue&lt;number&gt;(12345)); 定义方法时规定了泛型T，传参时使用泛型规定类型 8.2 泛型类java中的ArrayList就是这种东西 class ArrayList&lt;T&gt; { private list: T[] = []; add(item: T): void { this.list.push(item); } getList(): T[] { return this.list; } } var arr = new ArrayList&lt;number&gt;(); arr.add(1); arr.add(4); console.log(arr.getList()); 这里用number类型做了个例子，泛型可以是任意类型，类也可以 使用上文7.5中的Chinese类来示范 // 实例化对象 var ming: Chinese = new Chinese(&#39;小明&#39;); var hong: Chinese = new Chinese(&#39;小红&#39;); // 将对象添加进list var arr = new ArrayList&lt;Chinese&gt;(); arr.add(ming); arr.add(hong); console.log(arr.getList()); 8.3 泛型接口在定义接口时使用泛型，实现接口时相应的需要用泛型实现，调用方法时可以根据需要规定数据的类型 interface ConfigFn { &lt;T&gt;(value: T): T; // 最后一个T是返回值类型，可以是其他的 } var getData: ConfigFn = function &lt;T&gt;(name: T): T { return name; } console.log(getData&lt;string&gt;(&#39;张三&#39;)); 9 装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器装饰器的写法：普通装饰器（无法传参） 、 装饰器工厂（可传参） 装饰器是过去几年中js最大的成就之一，已是ES7的标准特性之一 9.1 类装饰器装饰器本身是一个函数，装饰器通过@符号来使用 function logClass(params: any) { params.prototype.name = &#39;装饰器&#39;; params.prototype.run = function () { console.log(&#39;这是一个装饰器&#39;); } } @logClass class Log { constructor() { } getData() { } } var log: any = new Log(); // 这里变量类型声明any log.run(); // 这是一个装饰器 9.1.1 装饰器工厂装饰器工厂可以传参，通过闭包的方式进行操作 function logClass(params?: any) { return function (target: any) { console.log(params); } } @logClass(&#39;get&#39;) class Log { constructor() { } } var log: any = new Log(); // get 这里调用装饰器的时候方法立即执行 function logClass(params?: any) { return function (target: any) { target.prototype.pro = params; } } @logClass(&#39;post&#39;) class Log { constructor() { } } var log: any = new Log(); console.log(log.pro); 上面这一段代码通过装饰器动态给类添加属性，在调用构造器的时候一定要加括号，参数可选时没有参数也要带括号 9.1.2 重载构造函数 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数； 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明； function logClass(target: any) { return class extends target { url = &#39;newValue&#39; getData() { console.log(&#39;getData:&#39;, this.url); } } } @logClass class HttpClient { public url: string | undefined; constructor() { this.url = &#39;value&#39; } getData() { console.log(this.url); } } var http = new HttpClient(); http.getData(); //getData: newValue 装饰器返回的就是HttpClient的子类，因此TS可以自动推导 http 的类型； 重载时必须将类里面的所有属性几方法重载 9.2 属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入两个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 成员的名字； function LogProperty(params: any) { return function (target: any, attr: any) { console.log(target); console.log(attr); } } class User { @LogProperty(&#39;zhangsan&#39;) name: string; constructor() { } } 从图中可以看到属性装饰器传入的两个参数 function LogProperty(params: any) { return function (target: any, attr: any) { target[attr] = params; } } class User { @LogProperty(&#39;zhangsan&#39;) name: string | undefined; constructor() { } getName(): void { console.log(this.name); } } var u = new User(); u.getName(); // zhangsan 9.3 方法装饰器方法装饰器被应用到方法的属性描述符上，可以用来监视、修改、替换方法的定义。方法装饰器会在运行时传入3个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 成员的名字； 成员的属性描述符； function get(params: any) { return function (target: any, methodName: any, desc: any) { console.log(target); console.log(methodName); console.log(desc); } } class HttpClient { url: string | undefined; constructor() { } @get(&#39;/user&#39;) getData() { console.log(&#39;getData: &#39;, this.url); } } 可以从打印结果看到方法装饰器的三个参数 function get(params:any) { return function(target:any, methodName:any, desc:any) { var oldMethod = desc.value; desc.value = function(...args:any[]) { let newArgs = args.map((item)=&gt;{ return String(item); }); oldMethod.apply(this, newArgs); } } } class HttpClient { constructor() { } @get(&#39;http://baidu.com&#39;) getData(...args:any[]) { console.log(&#39;getData: &#39;, args); } } var http = new HttpClient(); http.getData(1, 2, true); // getData: [&quot;1&quot;, &quot;2&quot;, &quot;true&quot;] 9.4 参数装饰器参数装饰器表达式会在运行时被调用，可以为类的原型增加一些元素数据，传入3个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 方法名称，如果装饰的是构造函数的参数，则值为undefined 参数在函数参数列表中的索引； function logParams(params:any) { return function(target:any, methodName:any, paramIndex:any) { console.log(target) // { constructor:f, getData:f } console.log(methodName) // getData console.log(paramIndex) // 0 } } class HttpClient { constructor() { } getData(@logParams(&#39;uuid&#39;) uuid:any) { console.log(uuid); } } 参数装饰器只能用来监视一个方法的参数是否被传入 9.5 装饰器执行顺序多个装饰器同时装饰到一个声明上，语法支持从左到右，或从上到下书写； 不同装饰器的执行顺序：属性装饰器 &gt; 方法装饰器 &gt; 参数装饰器 &gt; 类装饰器；","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"Vue组件通信","slug":"Vue组件通信","date":"2020-08-04T13:44:18.572Z","updated":"2020-08-04T13:45:42.022Z","comments":true,"path":"2020/08/04/Vue组件通信/","link":"","permalink":"https://fengjing95.github.io/2020/08/04/Vue组件通信/","excerpt":"","text":"Vue组件间通信Vue中组件的通信方式大致有：父——子、子——父、兄弟之间的通信 父子传值父——子父组件向子组件传值的时候，使用v-bind绑定属性，携带要发送的数据，子组件通过props接收这个数据（要跟属性名相同） Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; &lt;Son :fromFather=&quot;fromFatherM&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFatherM: &quot;父组件的消息&quot;, }; }, }; &lt;/script&gt; 为了容易区分属性名和数据，数据后加了个M，子组件接收数据时要使用这里面的属性名 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, // 接收参数并指定类型 }, data() { return {}; }, }; &lt;/script&gt; 效果如图 子——父子组件向父组件发送数据要通过方法来完成，父组件引用子组件的时候向子组件传递一个方法，子组件通过触发事件向方法中传参来向父组件发行数据 Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; 接收：{{sonData}} &lt;Son :fromFather=&quot;fromFather&quot; @receive=&quot;receiveData&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFather: &quot;父组件的消息&quot;, sonData: &quot;&quot;, }; }, methods: { receiveData(d) { // 接收数据并赋值 this.sonData = d; }, }, }; &lt;/script&gt; 使用@receive绑定事件，子组件发出数据时需要向这个绑定事件提交 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;input type=&quot;text&quot; v-model=&quot;fromSon&quot; /&gt; &lt;button @click=&quot;sonHandle&quot;&gt;send&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, }, data() { return { fromSon: &quot;&quot;, }; }, methods: { sonHandle() { this.$emit(&quot;receive&quot;, this.fromSon); // 发送数据的事件 }, }, }; &lt;/script&gt; 效果如图 使用$parent和$children官方文档中还给出了一对API mounted() { console.log(this.$parent.id + &quot;$parent&quot;); }, mounted() { console.log(this.$children[0].id + &quot;$children&quot;); }, 这里一定要注意获取的数组 还可以通过$refs来获取，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 可以获取 上面三种方式的结果如图 兄弟组件兄弟组件传值可以借助一个空白组件，如果项目较大，可以使用Vue官方状态管理Vuex，之后会发Vuex的介绍","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"JS正则表达式","slug":"JS正则表达式","date":"2020-08-03T16:26:08.012Z","updated":"2020-08-03T16:32:24.560Z","comments":true,"path":"2020/08/04/JS正则表达式/","link":"","permalink":"https://fengjing95.github.io/2020/08/04/JS正则表达式/","excerpt":"","text":"JS正则表达式创建正则的两种方式： 创建字面量正则表达式，使用//包裹 let reg = /\\w/ 创建正则表达式对象，使用new RegExp() let reg = new RegExp(/\\w/) 选择符 |“I” 左右两边匹配到一个就算是true let str = &#39;张三：010-1568413，李四：020-1586640&#39; let reg = /(010|020)\\-\\d{7,8}/ console.log(reg.test(str)); // true 转义在字符串中\\d和d是一样的 console.log(&#39;\\d&#39; === &#39;d&#39;) // true 在创建字面量的时候直接使用//创建，或者在字符串中转义 let str = &#39;123.abc&#39; let reg = &quot;\\\\d+\\\\.\\\\w+&quot; let reg2 = /\\d+\\.\\w+/ console.log(str.match(reg)); console.log(str.match(reg2)); 边界以^开始，以$结束，可用于检测网址开头和文件后缀 ^开始边界let str = &#39;http:www.easyremember.cn&#39; let reg = /^https?:www\\..+/ console.log(reg.test(str)); // true $结束边界let str = &#39;C://Users/All Users/abc.txt&#39; let str2 = &#39;C://Users/All Users/abc.log&#39; let reg = /\\.txt$/ console.log(reg.test(str)); // true console.log(reg.test(str2)); // false 元字符\\w：所有的字母、数字、下划线 \\W：所有的非数字、字母、下划线 \\d：所有的数字 \\D：所有的非数字 \\s：所有的空白字符，换行、空格等 \\S：所有的非空白字符 .：除换行以外的任意字符 模式修饰符 i：不区分大小写 g：全局匹配 y：从lastIndex开始匹配 u：处理UTF-16编码字符 m：多行处理 s：单行处理，忽略换行符 原子表 原子表 说明 [] 只匹配其中的一个原子 [^] 只匹配”除了”其中字符的任意一个原子 [0-9] 匹配0-9任何一个数字 [a-z] 匹配小写a-z任何一个字母 [A-Z] 匹配大写A-Z任何一个字母 Tips:\\d == [0-9] \\D == [^0-9] 原子组使用（）包裹 引用分组：引用之前原子组匹配到的内容，\\1\\2…… let str = &#39;abc123.c123&#39; let reg = /([a-z]\\d+)\\.\\1/g console.log(str.match(reg)); // [&quot;c123.123&quot;] 分组别名 为不同分组命名，使用?&lt;&gt;命名，使用$&lt;&gt;引用 let str = &#39;abc123.c123&#39; let reg = /(?&lt;init&gt;[a-z]\\d+)\\.\\1/g // console.log(str.match(reg)); console.log(str.replace(reg, `&lt;p&gt;$&lt;init&gt;&lt;/p&gt;`)); 重复+：重复一次或多次 *：重复零次或多次 ?：重复零次或一次 {n}：重复n次 {n,}：重复n次或更多次 {n,m}：重复n次到m次 let str = &#39;1234&#39; let reg = /\\d/ let reg2 = /\\d+/let reg3 = /^\\d{1,2}$/ console.log(str.match(reg)); console.log(str.match(reg2)); console.log(reg3.test(str)); 字符方法search返回要搜索内容的索引，没有返回-1 let str = &#39;abcdef&#39; console.log(str.search(&#39;ef&#39;));// 4 console.log(str.search(/\\w/)); // 0 console.log(str.search(&#39;efg&#39;)); // -1 match使用字符串或者正则表达式匹配，返回匹配的内容，匹配不到返回null let str = &#39;abcdef&#39;console.log(str.match(&#39;ef&#39;)); // ef console.log(str.match(/\\w+/)); // abcdef matchAll：返回一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` for (let s of str.matchAll(reg)) { console.log(s); } split：使用字符分割字符串 let str = &#39;abc/def/123&#39; console.log(str.split(&#39;/&#39;)); // [&quot;abc&quot;,&quot;def&quot;,&quot;123&quot;] replace替换字符为 let str = &#39;abc/def/123&#39; console.log(str.replace(/\\W/g, &#39;-&#39;)); // abc-def-123 正则方法test检测字符串是否符合要求，返回值是一个布尔值 exec不使用全局匹配与match相同，使用全局匹配会匹配完全部字符串，返回结果是一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` console.log(reg.exec(str)); console.log(reg.exec(str)); 断言?=exp相当于if，但是是后置的例如 &lt;main&gt; 中国努力建设有中国特色社会主义&lt;/main&gt; &lt;script type=&quot;text/javascript&quot;&gt; let reg = /中国(?=特色)/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) &lt;/script&gt; ?&lt;=exp前置断言 let reg = /(?&lt;=有)中国/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) 效果跟前面的?=效果是一样的 ?!exp后面不能出现exp匹配到的内容 ?&lt;!exp前面不能出现exp匹配到的内容","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"let、const和var的区别","slug":"let、const和var","date":"2020-08-02T11:09:59.170Z","updated":"2020-08-02T11:11:39.247Z","comments":true,"path":"2020/08/02/let、const和var/","link":"","permalink":"https://fengjing95.github.io/2020/08/02/let、const和var/","excerpt":"","text":"let、const和var作用域var作用于全局，先来看一个例子 for (var i = 0; i &lt; 5; i++) { var a = 1; } console.log(a, i); // 1 5 跳出了for循环之外a依旧可以访问，用于控制循环的i也能够访问，i=5循环跳出，所以i是5 再来看一下把var改成const for (var i = 0; i &lt; 5; i++) { const a = 1; } console.log(a, i); // Uncaught ReferenceError: a is not defined 这时a是块级作用域，除了循环之后就访问不到了，再来看i，把i改成const声明 Uncaught TypeError: Assignment to constant variable. const属于常量，赋值之后不能改变，这里应该用let，let是变量 重复声明var b = 1; var b = 2; console.log(b); // 2 用var可以重复声明，再来试一下const const b = 1; const b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 可以看出const不可以重复声明，再来试一下let let b = 1; let b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 由此可以看出，const和let不可以重复声明 总结cosnt和let是ES6新出的块级作用域，不可以重复声明，此外 const b; b = 2; console.log(b); // Uncaught SyntaxError: Missing initializer in const declaration const不可以先声明后赋值，let可以 上面说到const不可以重新赋值，有一种情况例外 const b = { a: &#39;a&#39; }; b.a = &#39;b&#39;; console.log(b); 来看一下结果 可以看到值已经发生了改变","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Less预编译使用","slug":"Less预编译","date":"2020-08-02T06:11:51.895Z","updated":"2020-08-02T06:13:59.998Z","comments":true,"path":"2020/08/02/Less预编译/","link":"","permalink":"https://fengjing95.github.io/2020/08/02/Less预编译/","excerpt":"","text":"less预编译1 初见lessless是一门向后兼容的 CSS 扩展语言。 HTML标签不能直接识别less样式，需要引入less.js来编译 引入样式文件 &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt; 引入编译脚本 &lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 但是，这种方式是运行时编译，不是预编译，在VSCode插件商店中搜索less下载对应的编译插件 每次保存less文件时就可以自动编译出css文件 2 less语法2.1 注释less有两种注释 常规的css注释 /* 可见注释，会被编译到css文件中 */ 编译后不可见注释 // 不可见注释，不会被编译到css文件中 2.2 变量使用@符号声明变量，样式中可以引用，less的变量都是块级作用域，直接上代码，一目了然 less块级作用域：首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承 @width: 10px; @height: @width + 10px; .box { width: @width; height: @height; } 编译结果为 属性名和选择器也可以用变量，但是在引用的时候需要用 {}包裹起来，上代码 @width: 10px; @height: @width + 10px; @m: margin; @selector: #nav; .box { @{m}: 10px; width: @width; height: @height; } @{selector} { color: red; } 来看下编译后的，属性和选择器引用很少使用 变量延迟加载 .over { @var: 1; .three { @var: 2; brass: @var; @var: 3; } one: @var; } one属性是在over作用域中的，跟brass无关，所以one的值是1；在brass作用域中，要等变量先加载完再引用，这就是延迟加载，所以three的值是3 2.3 嵌套前面的代码已经能够体现嵌套规则了，可以根据HTML的层级关系来嵌套css样式，伪类选择器也是可以嵌套的 .box { width: @width; height: @height; background-color: pink; :hover { background-color: deeppink; } } 编译结果是这样的 注意这里多了一个空格，这样是不生效的，那怎么样去掉这个空格呢，使用&amp;取消父子关系，让两个类挨在一起 .box { width: @width; height: @height; background-color: pink; &amp;:hover { background-color: deeppink; } } 再来看结果 空格没了 2.3.1 @嵌套和冒泡@ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变 例如 .component { width: 600px; @media (min-width: 768px) { width: 300px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } @media (min-width: 1280px) { width: 800px; } } 这段代码在component类中嵌套了三个媒体查询，编译之后media会编译到最外层 2.4 混合2.4.1 混合混合就是将一系列属性从一个规则集引用到另一个规则集的方式，简单来说已定义的类可以在另一个类中进行引用 .border { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 结果 引用混合的时候，混合没有参数时，括号可以加也可以不加；混合需要使用默认参数时，括号必须加 2.4.2 不编译的混合如果只想定义一个混合，在选择其后面加一个括号，那么这个混合不会被编译 .border() { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 编译结果只有.border-2这个类 2.4.3 带参数的混合类似于js定义方法一样接收参数，然后进行编译（但是，他不叫函数，叫混合） .bar(@w, @h, @color) { width: @w; height: @h; color: @color; } .nav-bar { .bar(100px, 200px, #409eff); } 在引用bar的时候将参数填入，然后进行编译 可以设置参数的默认值，可以传递命名参数 .bar(@w: 10px, @h:10px, @color:green) { width: @w; height: @h; color: @color; } .nav-bar { .bar(@color: #409eff); } 结果 当引用混合的时候不加任何参数就会全部使用默认值 2.4.4 匹配模式根据标识匹配混合，下面定义了4种样式，分别是上右下左边框 .border-style(@_, @w, @h, @c) { border-style: solid; } .border-style(T, @w, @h, @c) { width: @w; height: @h; border-color: @c transparent transparent transparent; } .border-style(R, @w, @h, @c) { width: @w; height: @h; border-color: transparent @c transparent transparent; } .border-style(B, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent @c transparent; } .border-style(L, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent transparent @c; } .border-3 { .border-style(B, 100px, 100px, #000); } 匹配效果如图 注意代码开始的地方 .border-style(@_, @w, @h, @c) { border-style: solid; } 这一段，@_用来匹配L、R、B、T标识，每次使用匹配模式时自动带上这段公共代码 2.4.5 @arguments@arguments包含传进来的所有参数 .border_arg(@w:30px,@c:red,@sty:solid){ border:@arguments; } .test_arguments{ .border_arg(); } 结果如图 2.5 运算 算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。计算的结果以最左侧操作数的单位类型为准。如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px 到 cm 或 rad 到 % 的转换 @color: #224488 / 2; //结果是 #112244 background-color: #112244 + #111; // 结果是 #223355,#111-&gt;#111111 2.6 转义当需要引入无效的CSS语法或Less不能识别的字符，就需要使用转义字符，在字符串前面加一个 ~，并将需要转义的字符串放在 “” 中 @min768: ~&quot;(min-width: 768px)&quot;; .element { @media @min768 { color: pink; } } // 结果 @media (min-width: 768px) { .element { color: pink; } } 在需要使用cacl()的时候less会自动编译括号里面的东西 使用转义来避免自动编译 .no { height: 100 +20px; width: ~&quot;cacl(200px + 20)&quot;; } 2.7 映射 Less 3.5 版本开始，可以将混合和规则集作为一组值的映射（map）使用 #colors() { primary: blue; secondary: green; } .button { color: #colors[primary]; border: 1px solid #colors[secondary]; } // 结果 .button { color: blue; border: 1px solid green; } 2.8 导入less文件导入可以省略后缀名 @import &quot;main&quot;; // mian.less @import &quot;style.css&quot;; 2.9 继承使用extend函数继承一个类 .middle { margin: 0 auto; } .footer:extend(.middle) { color: pink; } 编译之后的middle类将会变成两个类公共部分，用逗号连接","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"https://fengjing95.github.io/tags/css/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"动态控制输入框数量","slug":"动态控制输入框","date":"2020-08-01T14:00:17.672Z","updated":"2020-08-01T14:01:28.214Z","comments":true,"path":"2020/08/01/动态控制输入框/","link":"","permalink":"https://fengjing95.github.io/2020/08/01/动态控制输入框/","excerpt":"","text":"动态控制输入框在开发中经常会遇到根据情况动态控制输入框的情况，以前都是使用UI框架提供的组件，这次自己动手完成了一个简易的动态输入框 先来上效果 正片开始 加减号使用fontawesome的图标不多做赘述 先来看一下标签 &lt;div id=&quot;upload-problem-outin&quot; v-for=&quot;(item, index) in problem.sample&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.inputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输入样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.outputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输出样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;/div&gt; problem.sample是problem对象中的样例相关部分，格式如下 sample: [{ inputSample: &#39;&#39;, outputSample: &#39;&#39; }], 通过v-for遍历sample数组来渲染样例组数，通过数据绑定，控制sample数组的内容来实现样例组数的渲染 再来看一下控制的方法 addSample() { this.problem.sample.push({ inputSample: &#39;&#39;, outputSample: &#39;&#39; }) }, subSample() { if(this.problem.sample.length &lt; 2) { alert(&#39;至少保留一组&#39;) return } this.problem.sample.pop() } 触发增加事件时向原数组追加一个sample对象，触发减少事件时丢掉最后一项，智力有一个判断，即样例数不能少于1 大功告成","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue绑定不到组件","slug":"Vue子路由常见的问题","date":"2020-08-01T10:38:09.001Z","updated":"2020-08-01T10:39:27.068Z","comments":true,"path":"2020/08/01/Vue子路由常见的问题/","link":"","permalink":"https://fengjing95.github.io/2020/08/01/Vue子路由常见的问题/","excerpt":"","text":"Vue子路由常见的问题之前在进行开发的时候遇到了一个很玄学的问题，有一个页面需要设置二级路由，在设置二级路由之后浏览器却出现了报错 路由设置如下 报错信息 在查阅了相关资料之后找到了一种解决办法，component改为conponents 虽然没搞明白原理，先试试再说，浏览器正常不报错，但是！！！ 组件也没加载出来，TnT，这啥啊，治标不治本 然后我发现了这个 由于vue-router版本升级的原因需要手动添加.default来加载组件 原因如下 还有种方法 { path: &#39;back&#39;, name: &#39;back&#39;, component: resolve =&gt; require([&#39;@/components/Admin/Back&#39;], resolve), } 我试了下，我试了下这种方式也没问题，resolve是require的回调 还找到了一种说法 require 是 CommonJS 的模块导入方式，而组件定义时写的 export default 是 ES6 方式，因此require 导入的结果其实是一个含 default 属性的对象，所以 vue 中 component 用这个会报错，而恰好 vue 的命名视图组件注册用 components ，而官方也说了“如果 router-view 没有设置名字，那么默认为 default”，所以这两个default 正好对应起来，于是像楼主所说加了s就不会报错了。而合理的用法应该是 require(‘xxx.vue’).default 或是用 import","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue刷新页面","slug":"Vue页面刷新方法","date":"2020-07-31T14:14:47.733Z","updated":"2020-07-31T23:18:10.761Z","comments":true,"path":"2020/07/31/Vue页面刷新方法/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/Vue页面刷新方法/","excerpt":"","text":"Vue页面刷新方法在编写提交表单的时候，当表单提交上之后清空当前表单 开始的时候我想的是表单提交成功之后data中表单中有关表单内容的变量重新赋空值，但是这样太过麻烦 偶然间在一篇博客中发现可以通过路由跳转当前路由来清空页面 然后就想着搜集一下有没有其他方法，搜集之后总结在这里了 路由跳转this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.go(0) }) 通过this.$router.go(0)来刷新页面 location.reload()也可以实现刷新页面 但是这样或有一个空白的过程 通过空白组件刷新将上传成功之后的回调修改 this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.replace({ path: &#39;/admin/back&#39;, name: &#39;back&#39; }) }) 然后创建一个新的空白组件back.vue，script部分如下 // 用于刷新页面，没有实际意义 export default { name: &quot;Back&quot;, data() { this.$router.replace({ path: &#39;/admin/uploadProblem&#39;, name: &#39;UploadProblem&#39; }) return { } } } 效果如下，网上说会有路由的改变过程，我没有发现。。。 provide / inject 组合先修改一下app.vue，通过provide传递reload方法 export default { provide() { return { reload: this.reload() } }, name: &quot;Back&quot;, data() { return { isRouterAlive: true } }, methods: { reload() { this.isRouterAlive = false this.$nextTick(function() { this.isRouterAlive = true }) } } } 在需要重新加载的页面通过 inject: [&#39;reload&#39;],接收方法（网上叫它‘注入依赖’），然后就可以在方法中调用 this.reload()","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue点击切换导航栏样式","slug":"Vue点击切换导航栏样式","date":"2020-07-31T06:09:30.441Z","updated":"2020-07-31T06:16:16.925Z","comments":true,"path":"2020/07/31/Vue点击切换导航栏样式/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/Vue点击切换导航栏样式/","excerpt":"","text":"Vue点击切换导航栏样式导航栏内容如下 &lt;div class=&quot;collapse&quot;&gt; &lt;div class=&quot;links&quot;&gt; &lt;router-link v-for=&quot;link in linkLists&quot; :to=&quot;link.links&quot; :key=&quot;link.id&quot; exact&gt;{{link.show}} &lt;/router-link&gt; &lt;/div&gt; 效果如图 感觉太过简单，就想着加一个激活效果，开始想了很多种方法，但是都存着一定的缺陷，偶然间发现了router-link-active这个东西 可以给激活的router-link添加样式，尝试了一下 在links里面添加样式（使用的less预编译） .links { display: flex; margin-right: auto; a { color: #777; margin: 0 10px; } a:hover { color: #409eff; } .router-link-active { color: #409eff; } } 开始我以为完事了，但是却发现无论怎么切换首页一直处于激活状态，我开始面向百度解决问题 然后我发现了exact exact 是一个单独的属性 正确用法是 &lt;router-link to=&quot;/home&quot; active-class=&quot;bianlan&quot; exact&gt;。 这样，只有当路径刚好是 /home 时才会添加 bianlan 类名，而当路径是 /home/something 时则不会（因为不 exact） 在router-link标签中添加exact属性之后效果完美","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"JS递归、闭包、作用域链","slug":"JS递归、闭包、作用域链","date":"2020-07-31T04:14:58.555Z","updated":"2020-08-02T00:42:52.409Z","comments":true,"path":"2020/07/31/JS递归、闭包、作用域链/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/JS递归、闭包、作用域链/","excerpt":"","text":"JS递归、闭包、作用域链递归常规的递归函数function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } } console.log(func(4)); // 24 这是一个非常常见的递归函数，但是有一种情况会使得此方法出现错误。 var func2 = func; func = null; console.log(func2(4)); 将递归函数赋值给一个变量，然后把原函数赋值为null，这时候再调用就会报错 这是因为function属于引用类型，赋值时通过指针指向原函数，原函数发生改变，调用时就会出错 使用callee在上面的情况下，使用arguments.callee就可以解决，arguments.callee是一个指向正在执行函数的指针，将经典递归做以下改动 function func(number) { if (number &lt;= 1) { return 1; } else { return number * arguments.callee(number - 1); } } console.log(func(4)); //24 使用指针进行递归，无论怎么调用函数都不会出错，但是，在严格模式下使用arguments.callee会报错 命名函数表达式以上两种方法都存在这不同程度的缺陷，使用命名函数表达式可以达到指针的效果，亦可以同时运行在严格模式和非严格模式下 var func2 = (function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } }); var func3 = func2; func2 = null; console.log(func3(4)); 这时依旧可以正常显示结果 闭包 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 上面的递归最后一种方法就可以理解为一个闭包 闭包与变量经典的示例 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function () { return i; } } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } // 10,10,10,10,10,10,10,10,10,10 乍一看好像是for循环中每次循环将0-9赋值给数组的每一项，其实并不是，因为当前的newArray()正在执行，每个函数作用域链都保存着newArray()的活动对象，所以for循环中每次都是引用的同一个变量i，for循环结束之后，i是10，所以每个函数内部的i都是10。 再将返回i的函数包在一个匿名函数中，就可以达到互不影响的效果 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function (num: number) { return function () { return num; }; }(i) } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } 结果如下 在for循环中,自调用函数立即执行,获取实时地i赋值给num. 循环结束之后,返回result，在自调用函数执行之后，他的作用域就被销毁了，不会再被其他操作影响 this对象// 非严格模式 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return function () { return this.arg; }; } }; console.log(object.getArg()()); //window 为什么结果会是window呢，来看一下最后一行 // object.getArg()()相当于 var val = object.getArg(); val(); 把getArg返回的方法赋值给了val变量，然后执行函数。因为val在全局中，所以获得的arg是全局中的arg还有一种情况会出现问题 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return this.arg; } }; object.getArg() // object object.getArg() // object (object.getArg = object.getArg)() // window 第一种方法简单的调用了object的方法；第二种方法引用了object的方法，this对象能够维持；但是第三种是一个赋值语句，赋值语句是有返回值的，也就是等号右边，所以这里引用了方法，但不是object内部而是指向window 从这张图就可以看出赋值语句其实是有返回值的 解决方法 1 传递this指向var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { var _this = this; return function () { return _this.arg; }; } }; console.log(object.getArg()()); 将object的this传递到getArg之内，然后使用这个引用值获取arg 2 箭头函数也就是lambda表达式 var arg: string = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return () =&gt; { return this.arg } } } console.log(object.getArg()()); 箭头函数的一大特点就是不改变this的指向 内存泄漏闭包的缺陷在于会造成内存泄露，当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，比如通过node结点给html元素添加点击事件的时候，当事件添加完之后，存储node结点的变量会一直占用内存，造成内存泄漏 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; 存储divNode的内存将会无法释放也无法使用，怎么解决呢 在添加完事件之后将divNode手动赋值为空 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; divNode = null; 作用域链作用域 作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。 全局作用域一般全局作用域有以下几种情况 最外层函数和最外层函数外面定义的变量拥有全局作用域 所有未直接定义的变量 所有window对象 函数作用域声明在函数内部的变量，函数作用域一般只有代码片段中可以访问，比如函数内部 例如 function func1(a) { var b = a * 2; function func2(c) { console.log(a, b, c); } func2(b * 2); } func1(2) 这段代码中存在3个作用域 全局作用域，标识符func1 作用域func1，标识符a，b，func2 作用域func2，标识符c 作用域链 由多级作用域连续引用形成的链式结果，掌管一切变量的使用顺序： 先在局部找，没有，就延作用域向父级作用域找。 可以向上搜索，但不可以向下搜索 这种一层一层的关系，就是 作用域链 。","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Express+MySQL实现增删查改","slug":"Express+MySQL实现增删查改","date":"2020-07-28T13:56:38.115Z","updated":"2020-07-28T15:51:38.028Z","comments":true,"path":"2020/07/28/Express+MySQL实现增删查改/","link":"","permalink":"https://fengjing95.github.io/2020/07/28/Express+MySQL实现增删查改/","excerpt":"","text":"Express+MySQL实现增删查改现在Node后台开发在网上找到的资料基本都是用的MongoDB数据库，不太容易找到使用MySQL数据库的资料，所以我整理了一下这篇文章，将会讲解如何使用Express和MySQL来实现CRUD 环境搭建生成器可以直接使用Express生成器自动生成Express工程 $ npm install -g express-generator $ express --view=ejs myapp 手动搭建创建一个项目目录$ npm init 新建app.js入口文件 新建router.js路由文件 创建views文件夹，存放EJS模板文件（student.ejs, editStu.ejs） 新建public公共资源 views文件夹命名不可以是别的，会报错 安装第三方模块$ npm install express --save $ npm install mysql --save $ npm install ejs --save 编写代码编写入口文件实例化、模板引擎设置、静态资源、监听 const express = require(&#39;express&#39;); const app = express(); const stuRoute = require(&#39;/router&#39;) // 设置模板引擎 app.set(&quot;view engine&quot;, &quot;ejs&quot;); // 加载静态资源 app.use(express.static(&#39;public&#39;)); // 使用路由 app.use(stuRoute); // 监听 app.listen(3001, () =&gt; { console.log(&#39;启动成功&#39;); }) 编写路由文件const express = require(&#39;express&#39;); const route = express.Router(); const mysql = require(&#39;mysql&#39;); // 配置数据库,连接池模式 var pool = mysql.createPool({ connectionLimit: 10, // 连接数量 host: &#39;localhost&#39;, // 地址 user: &#39;liuhao&#39;, // 数据库用户名 password: &#39;123456&#39;, // 数据可密码 database: &#39;ssmbuild&#39; // 数据库名 }); route.get(&#39;/student&#39;, (req, res) =&gt; { console.log(&quot;/student:&quot;, req.query); const sql = &#39;select * from books where bookName = ?&#39;; let params = [&#39;java&#39;]; // 根据条件查询信息 pool.getConnection(function (err, connection) { if (err) throw err; // not connected! connection.query(sql, params, function (error, results, fields) { connection.release(); console.log(results); // 将数据传到ejs渲染 res.render(&#39;student&#39;, { res: [] }) if (error) throw error; }); }); }) module.exports = route; 效果展示查询结果 数据库数据 这里可以看到数据已经查询成功 本篇主要讲解mysql模块使用，对数据渲染不再赘述另外修改删除修改一下sql语句和params参数即可，开发时数据库部分一般会单独作为一个模块进行封装 现在大部分开发一般是返回json数据，后期会再进行记录","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"express","slug":"express","permalink":"https://fengjing95.github.io/tags/express/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"思途实训day5","slug":"STDay 5","date":"2020-07-26T13:40:01.320Z","updated":"2020-07-28T14:13:30.586Z","comments":true,"path":"2020/07/26/STDay 5/","link":"","permalink":"https://fengjing95.github.io/2020/07/26/STDay 5/","excerpt":"","text":"Day 5引入js尽量放在body标签的最后，先加载静态标签，再加载js脚本 jQuery表达式必须有分号 jQuery改变元素样式(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); })() click事件$(function () { $(&#39;button&#39;).click(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); }); }); 导航栏颜色修改 &lt;ul id=&quot;nav-ul&quot; onclick=&quot;navHandle()&quot;&gt; &lt;li id=&quot;li1&quot;&gt;首页&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;所有宝贝&lt;/li&gt; &lt;li id=&quot;li3&quot;&gt;每周一上新&lt;/li&gt; &lt;li id=&quot;li4&quot;&gt;生活馆&lt;/li&gt; &lt;li id=&quot;li5&quot;&gt;特惠&lt;/li&gt; &lt;li id=&quot;li6&quot;&gt;礼品区&lt;/li&gt; &lt;/ul&gt; function navHandle() { var nodeId = window.event.target.id; // console.log(node); $(&#39;#&#39; + nodeId).css({ &#39;color&#39;: &#39;#d62cc0&#39; }).siblings().css({ &#39;color&#39;: &#39;#ffffff&#39; }); } siblings()方法返回被选中元素的同级元素 鼠标经过和移出$(function() { $(&#39;#mouse&#39;).mouseenter(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;red&#39; }); }); }); $(function() { $(&#39;#mouse&#39;).mouseleave(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;#409eff&#39; }); }); }); 淡入淡出效果$(function() { $(&#39;.b-f-1&#39;).mouseenter(() =&gt; { $(&#39;#black1&#39;).fadeOut(500); }); }); $(function() { $(&#39;.b-f-1&#39;).mouseleave(() =&gt; { $(&#39;#black1&#39;).fadeIn(300); }); }); 滑动效果slideDown、slideUp $(function() { $(&#39;div&#39;).mouseenter(() =&gt; { $(&#39;div&#39;).slideDown(1000); }); }); $(function() { $(&#39;div&#39;).mouseleave(() =&gt; { $(&#39;div&#39;).slideUp(1000); }); }); 总结今天大概复习了一下jQuery，很多东西都忘了，需要再看一下","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day4","slug":"STDay 4","date":"2020-07-24T11:29:57.687Z","updated":"2020-07-28T14:13:32.824Z","comments":true,"path":"2020/07/24/STDay 4/","link":"","permalink":"https://fengjing95.github.io/2020/07/24/STDay 4/","excerpt":"","text":"Day4旋转+透明度div { width: 150px; height: 150px; border-radius: 50%; overflow: hidden; border: solid 3px #409eff; transition: 0.5s; opacity: 0.5; } div:hover { transform: rotate(200deg); opacity: 1; } 今日收获。。。就是个透明opacity 成果","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day3","slug":"STDay 3","date":"2020-07-24T01:17:51.174Z","updated":"2020-07-28T14:13:34.338Z","comments":true,"path":"2020/07/24/STDay 3/","link":"","permalink":"https://fengjing95.github.io/2020/07/24/STDay 3/","excerpt":"","text":"Day 3HTML标签。。。从0开始的那种。。。 css样式通配符选择器* { margin: 0; list-style: none; /* 去掉list圆点 */ text-decoration: none; /* 去掉下划线 */ } 列表右浮动只给父级不给子级背景图片引入背景图片必须设置高度，否则不显示 .binner { /* no-repeat不平铺 */ background: url(../img/TB183NQapLM8KJjSZFBSutJHVXa.jpg) no-repeat; height: 568px; background-size: 100% auto; /* 图片自适应 */ } 行高等于div高度时自动居中.nav-f { width: 660px; height: 120px; position: absolute; left: 168px; line-height: 120px; } 精灵图使用Photoshop信息面板配合精灵图设置图片 比如这张精灵图 .shopping { width: 30px; height: 30px; background: url(../img/icon.png); background-position: -16px -133px; } 引入图片之后将鼠标移至图标左上角，看到位置是X：16，Y：133，将图片位置设置为-16px,-133px，将图片沿着X轴Y轴移动之后，浏览器会自动根据设置的宽高从起点位置裁切","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"JS异步轮询","slug":"异步轮询","date":"2020-07-23T05:50:43.924Z","updated":"2020-07-23T05:52:50.933Z","comments":true,"path":"2020/07/23/异步轮询/","link":"","permalink":"https://fengjing95.github.io/2020/07/23/异步轮询/","excerpt":"","text":"异步轮询异步先来看一个例子 console.log(&#39;start&#39;) setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;) }, 4000) console.log(&#39;end&#39;) 这段代码的执行顺序是什么，你可能想到的结果是 start setTimeout end 但是，js是单线程的，不会因为一个任务而被阻塞，异步操作将会被放到队列中，等主线程执行完第一轮任务，然后再执行队列中的任务 这里稍微扯一下栈和队列 栈（stack） 栈是一种先进后出的数据结构，可以理解为一个桶，先放进的东西在最低下，后放的东西在最外面，外面的取完了之后才能拿出最先放进去的东西； 队列（queue） 队列是一种先进先出的数据结构，可以看做一个管道，先进的先出，后进的后出 回到正题，上面的例子中setTimeout是一个异步操作，被放到了队列中，当主线程执行完成之后再来执行队列中的任务，所以答案应该是 在js的队列中有两种划分，一种是宏任务（macrotask queue），一种是微任务（microtask queue），每一个事件循环（Event Loop）都有一个微任务，会有一个或多个宏任务，每一次事件循环都会首先执行微任务执行完后从宏任务取出一个加入到微任务然后执行，直至队列中所有的任务执行结束 宏任务 script(整体代码) setTimeout setInterval I/O UI交互事件 postMessage MessageChannel setImmediate(Node.js 环境) 微任务 Promise.then Object.observe MutaionObserver process.nextTick(Node.js 环境) Promise异步原理看完了，下面开始Promise let promise = new Promise((resolve, reject) =&gt; { // resolve(&quot;成功&quot;) // reject(&quot;失败&quot;) }) console.log(promise) 先来看一下Promise对象的结构 当没有任何操作的时候，Promise对象的状态时pending，值是undefinded 当在Promise中调用resolve之后，状态变为resolved，值是成功 当调用reject的时候，状态变为rejected，值是失败 pending就是未决，resolve可以理解为成功，reject可以理解为拒绝 Promise的状态是不可逆的，resolve和reject同时出现，先执行的决定状态，后执行的不生效 下面这三种方法可以触发Promise.then的错误方法 throw new Error(‘fail’) reject(‘fail’) 错误操作（默认，类似try/catch） 链式调用console.log(&#39;start&#39;) let promise = new Promise((resolve, reject) =&gt; { console.log(&#39;promise&#39;) resolve(&quot;success&quot;) // reject(&quot;faild&quot;) }).then(value =&gt; { console.log(value+1) return value }, reason =&gt; { console.log(reason) }).then(value =&gt; { console.log(value+2) }, reason =&gt; { console.log(reason) }) console.log(&#39;end&#39;) 打印结果为 Promise会将返回值作为.then()的参数传递下去，而且两个.then是在主线程执行完成之后才执行的，这里被放到了微任务（不是并列的，当执行第一个.then的时候第二个.then才会被放到微任务），如果不调用resolve或者reject，微任务是不创建的 每一个Promise.then也是一个Promise 状态中转let promiseErr = new Promise((resolve, reject) =&gt; { reject(&#39;faild&#39;) }) let promise = new Promise((resolve, reject) =&gt; { resolve(promiseErr) }).then(value =&gt; { console.log(&#39;value:&#39;+value) }, reason =&gt; { console.log(&#39;err:&#39;+reason); }) 这里promise虽然调用了resolve，但是返回的状态却是promiseErr的，所以他的结果是 .then是对它前一个Promise对象的操作 错误捕获这样每一个then都有两个方法，过于繁琐，可以在then中只写成功方法，在最后使用catch方法捕获错误 let promise = new Promise((resolve, reject) =&gt; { resolve() }).then(v =&gt; { console.log(&#39;p1&#39;) throw new Error(&#39;fail&#39;) }).then(v =&gt; { console.log(&#39;p2&#39;) }).catch(err =&gt; { console.log(err) }).then(v =&gt; { console.log(&#39;p3&#39;) }).then(v =&gt; { console.log(&#39;p4&#39;) }) 结果为 有结果可以看出，发生错误的地方到catch之间的代码不会执行，catch返回值也是一个Promise对象 async/await了解了Promise之后，async/await就很容易了，它其实就是Promise的语法糖 async function asyncFunc() { return &quot;asunc&quot; } let result = asyncFunc() console.log(result); 从结果看出，async方法返回的也是一个Promise对象 来看看下面这个例子 function p() { console.log(&#39;p&#39;) } async function func() { await p(); console.log(&#39;OK&#39;) } console.log(&#39;start&#39;) func() console.log(&#39;end&#39;) // start // p // end // OK 用知乎上看到过一个例子来解释，可以将 async function func() { await p(); console.log(&#39;OK&#39;) } 理解为 function func() { return Promise.resolve(p()).then(() =&gt; { console.log(&#39;OK&#39;) }) } console.log(‘OK’)被分配到微任务中等待下一轮轮询 来看一个综合案例 async function async1() { console.log(&#39;async1 start&#39;) await async2() console.log(&#39;async1 end&#39;) } async function async2() { console.log(&#39;async2&#39;) } console.log(&#39;script start&#39;) setTimeout(function () { console.log(&#39;settimeout&#39;) }) async1() new Promise(function (resolve) { console.log(&#39;promise1&#39;) resolve() }).then(function () { console.log(&#39;promise2&#39;) }) console.log(&#39;script end&#39;) 输出结果是 script start async1 start async2 promise1 script end async1 end promise2 settimeout 你做对了么(๑´ㅂ`๑)","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"JS中的闭包","slug":"闭包","date":"2020-07-23T05:28:46.515Z","updated":"2020-07-23T05:36:52.742Z","comments":true,"path":"2020/07/23/闭包/","link":"","permalink":"https://fengjing95.github.io/2020/07/23/闭包/","excerpt":"","text":"​ 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 相信你看了这段鬼话，80%会感到懵逼，看完下面的内容再回来看这句话，相信你就可以理解了。 函数的作用域 在全局环境中定义了title变量和show方法，当执行show方法时，开辟出一块内存，如果在show方法内部调用context是可以正常执行的，当show执行完的时候，show中定义的context变量不被保留，这时外部调用context就会 not defined。 数据的作用默认就是在函数体内 数据向下流动，只会向子级传递，不会向父级传递 当show方法执行完之后，内存被释放，执行多个show方法相当于多次开辟了内存 如果在show方法中再定义一个head方法，再执行，此时的内存结构如图所示，head方法时show方法内部的，show执行时为head开辟一块内存；那多次调用show方法会一直调用那一个head方法么？不是的！！！多次调用show方法会开辟多块内存，他们之间是没有关系的。 这个例子更能清楚的说明，按照常理，第一次调用++n之后变成了2，但是这里第二次调用结果还是2，这就说明了两次调用创建了两次 那么怎么让n一直被使用呢，这时你应该想起来开头有一句话 但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 当数据一直被使用时就会保留下来，那么怎么让他一直被使用呢？ 将sum方法作为返回值赋值给a，这时候，feng中的数据就会一直被使用，直到a销毁，这时候多次调用a方法，n就会累加 如果再赋值给b，这就又开辟了一块内存，与a无关n又重新开始计算，结果如下： 这时候你又想起了开头还有一句话： 每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址 如果在sum中在添加一个function，这样再执行两次a结果是什么呢？ 你没有看错，其实很简单，这跟之前一样，相当于在a中开辟了两块不相关的内存，那么怎么让m累加呢？也很简单，再把show返回出去 这时再创建b，打印结果依旧是2 3 2 3 利用闭包选择数组区间 由于过滤函数一直在调用between的子函数，所以a，b也被保留了下来 闭包会造成内存泄漏 这段代码的意思是点击div会触发打印descript属性，因为事件处理函数是一直存在的，所以每个item在使用完成之后都会保存，而且都是不同的内存区域，对于复杂对象来说是非常浪费内存的 那么怎么解决闭包带来的内存泄漏呢 在使用完之后给item项赋空值 这样就可以解决不必要的内存浪费","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"思途实训day2","slug":"STDay 2","date":"2020-07-22T08:57:04.870Z","updated":"2020-07-28T14:13:35.489Z","comments":true,"path":"2020/07/22/STDay 2/","link":"","permalink":"https://fengjing95.github.io/2020/07/22/STDay 2/","excerpt":"","text":"Day 2字体选择： 中文：微软雅黑， 宋体，黑体 英文：arial 字体大小： 网页最小字号：12px， 不重要信息 一般用的最小字号：14px 精确抠图解锁原背景，新建图层填充鲜艳的颜色，例如绿色 用魔棒工具选择背景色，调整容差值，右键选择【调整边缘】 调整参数 菱形方格 制作一个这样的菱形方格 用矩形工具选择一个矩形框填充一个颜色，【ctrl】+【T】自由变换，按住shift旋90度 在图层调节描边，内阴影和投影 就可以看到效果图中的样式 图层蒙版将要贴入的图片拖拽至目标图层上方 注意在图层区域要将两图层放在一起 左上角有自动选择，点一下就可以定位图层 在两图层之间按住【alt】+鼠标左键 图层区会变成 显示的样式就会变成 图标绘制 锚点工具使用 首先利用椭圆工具绘制黄色圆形，然后复制两份 利用圆角矩形工具绘制蓝色矩形，绘制完成之后按【A】键选中元素出现锚点，按住【ctrl】用鼠标拖拽锚点成为一个梯形 在梯形内绘制三个圆角矩形，填充背景色构造成镂空的感觉 绘制底座，使用圆角矩形，使用锚点工具选择右上角两个点，【delete】，然后将描边改为白色 使用钢笔工具绘制上面的把手，钢笔工具点击一个点，再点第二个点不要松手，调整弧度至合理，使用上面底座相同的配置即可 钢笔工具在使用的时候如果出现角度很别扭的时候，可以在上一个点调好之后不松手，按住【alt】鼠标移动调节手柄 切图将所有的背景色全部隐藏，用切片工具画出切片区域，存储为web格式","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day1","slug":"STDay 1","date":"2020-07-22T07:27:01.446Z","updated":"2020-07-28T14:13:13.761Z","comments":true,"path":"2020/07/22/STDay 1/","link":"","permalink":"https://fengjing95.github.io/2020/07/22/STDay 1/","excerpt":"","text":"Day 1PhotoShop操作快捷键 图层复制：【Ctrl】+【J】 自由变换：【Ctrl】+【T】 画笔工具：【B】，画笔调节：粗——右中括号，细——左中括号 放大：【ctrl】+【space】，缩小：【ctrl】+【alt】+【space】，抓手：【space】 盖印：【ctrl】+【alt】+【shift】+【e】 首选项：【ctrl】+【k】 填充前景色：【alt】+【delete】，填充背景色：【ctrl】+【delete】 移动工具：【v】 编组：【ctrl】+【g】 制作大头像调节图层素材图片 1 复制一个图层（可使用ctrl+j，也可以拖拽图层到下方的新建图层图标） 2 ctrl+t自由变换图层，缩放到合适的比例（按住shift等比缩放） 3 调节新图层透明度，50%-60%合适 4 将两图层下巴对齐 5 在小图层上新建蒙版 6 用黑色画笔将大图层头部涂黑，涂完之后将不透明度调至100%，如果有多余部分使用白色画笔涂回去（硬度调为0） 7 使用裁切工具只保留需要的部分，盖印生成图层 成果图如下 图层修饰 滤镜中点开液化 使用膨胀工具在两眼位置分别点击两下将眼部放大 使用褶皱工具将鼻子和嘴缩小 使用左推工具将脸收一下 如果拖坏了可以使用重建工具将要恢复的地方涂一下 GIF制作窗口打开时间轴，新建帧动画 在图层中控制要显示的帧然后添加关键帧 调节每一帧的时间 导出：存储为web格式，调节为GIF格式 网页设计项目立项——分析市场环境——解决用户痛点 仿照图 自己做的设计图： 渐变色：在选区内添加渐变图层，否则会使整个背景全部渐变 选择多个图层：选中第一个图层，按住shift选中最后一个图层 要选中某一图层的某一部分：先用多边形框选工具选出大致部分，然后ctrl+alt+shift+点击要选中部分的图层","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"Typora图片自动上传到图床","slug":"Typora图片自动上传到图床","date":"2020-07-15T11:50:22.787Z","updated":"2020-07-15T13:53:48.283Z","comments":true,"path":"2020/07/15/Typora图片自动上传到图床/","link":"","permalink":"https://fengjing95.github.io/2020/07/15/Typora图片自动上传到图床/","excerpt":"","text":"Typora图片自动上传到图床你是否还在为找不到可靠的图床而烦恼 是否害怕图床网站关闭资源丢失 是否担心资源不能管理而发愁 今天他来了 1 下载安装picGo地址在这里，根据需要的版本进行下载 下载完成后进行安装 安装完之后在桌面右下角图标打开picGo详细界面 2 配置picGo图床+giteepicGo支持多个图床 这里主要说一下gitee新建一个公开的仓库，私有的在相册和Typora无法显示 搜索插件gitee（需要安装Node环境） 据说是两个都可以，我只试过了gitee，安装好之后在上面的图床列表里就会出现gitee图床 这里是配置信息 owner：gitee用户名 repo：gitee仓库名 path：路径，存放到根目录可以不用写 token：gitee个人令牌 message：可以不写 关于gitee个人令牌的获取 点开gitee的设置，在左侧栏找到私人令牌，然后点击生成新令牌 描述可以随便写一下，然后点击确认会生成一个token 将token复制到picGo中就可以了 3 配置Typora+picGo在Typora的偏好设置中将插入图片改为上传图片，上传服务修改为picGo App，并选择到安装目录 点击验证 如果出现false情况，看一下连接中的端口号，然后到picGo的设置中找到Server服务 将端口号修改一致 然后保存，再试一下验证","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"ES6笔记","slug":"ES6笔记","date":"2020-07-15T07:24:55.780Z","updated":"2020-08-02T06:22:10.833Z","comments":true,"path":"2020/07/15/ES6笔记/","link":"","permalink":"https://fengjing95.github.io/2020/07/15/ES6笔记/","excerpt":"","text":"ES6笔记变量let和constvar存在的问题 可以重复声明 无法限制修改 没有块级作用域 ES6新的定义变量 let 不能重复声明 变量，可以修改 块级作用域 const 不能重复声明 常量，不能修改 块级作用域 最大的区别：const一经定义值不能再变 函数箭头函数let show = function(n1,n2) { return n1-n2; } ----------等价-------------- let show = (n1, n2) =&gt; { return n1-n2; } 如果只有一个参数，()可以省略 let show = (n) =&gt; { return n; } --------省略-------- let show = n =&gt; { return n; } 如果只有一个return，{}可以省略 let show = n =&gt; { return 2*n; } -------省略-------- let show = n =&gt; 2*n; 箭头函数的this不会变：this指向的是当前对象，传统的function需要定义一个const that= this才能在里面的函数访问到最外层的this，箭头函数不会改变this指向，也就是说，无需定义that就可以用this访问原来的对象 箭头函数的优势和劣势 参数...args接收参数 命名随意，但必须放到参数最后，用于收集剩余参数 let show = function (a, b, ...args) { alert(a); alert(b); alert(args); } show(14,2,3,4,5); 多余的参数将会由args接收 展开数组 展开后效果跟直接把数组放在那一样 let arr = [1,2,3,4]; show(...arr);// == show(1,2,3,4) ------------------- let arr1=[1,2,3]; let arr2=[4,5,6]; let arr=[...arr1,...arr2]; // == let arr=[1,2,3,4,5,6]; 默认参数let show = function (a, b=5, c=10) { XXX } show(12); 当传的参数只有一个的时候，b默认是5，c默认是10； 当传参数大于一位时，会依次顶替默认参数 解构赋值左右两边结构必须一样 let [a, b, c] = [1,2,3] let {a,b,c} = {a:1,b:2,c:3} 右边必须合法 声明和赋值不能分开 let [a, b] = [5, 12];// 合法 ------------------------ let [a, b]; [a, b] = [5, 12];// 报错，解构赋值声明和赋值不能分开 数组map映射————一个对一个 let arr = [1, 2, 3, 4]; let result = arr.map(item =&gt; item * 2); // result 2,4,6,8 reduce汇总————一堆出来一个 let arr= [12, 8, 9, 16]; let result = arr.reduce( function (tmp, item, index) { return tmp + item; }) function中的三个参数分别是存储的和的中间数、要计算的数、索引 filter过滤器————保留一部分 let arr = [10,3,16,15,21,20]; let result = arr.filter(item =&gt; { if(item % 3 == 0) { return true; } return false; }); alert(result); -------------------------------- // json类型 let arr = [ {name: &#39;tom&#39;, price: 75}, {name: &#39;jerry&#39;, price: 60} ]; let result = arr.filter(item =&gt; { return item.price&gt;65; }); console.log(result); 当filter中的方法返回true的时候数据保留，返回false数据删除 forEach循环（迭代）————每一项进行操作 吧数组中的每一项都放到方法中执行 字符串两个新方法startsWith 匹配前面的字符串，相同返回true，不相同返回false endWith 匹配末尾的字符串，相同返回true，不相同返回false 应用：检测文件后缀 字符串模板字符串拼接 let a = &#39;AScri&#39;; let str = `ECM${a}pt6`; alert(str); // str=ECMAScript6 注意：插入字符串的字符串要用反单引号（数字键盘1左边的那个） 应用，拼接字符串 let html = `&lt;div&gt; &lt;h1&gt;${title}&lt;/h1&gt; &lt;p&gt;${content}&lt;/p&gt; &lt;/div&gt;`; 优势：直接把字符串插到字符串中；可以折行 面向对象语法class User { constructor(name, age) { this.name = name; this.age = age; } showName() { alert(this.name); } showAge() { alert(this.age); } } var user = new User(&#39;Tom&#39;, 18); user.showName(); user.showAge(); 对象创建关键字class，相当于java的类 构造器关键字constructor，相当java的构造函数 方法直接写在class里面，不需要加function 继承class VipUser extends User { constructor(name, age, level) { super(name, age); this.level = level; } showLevel() { alert(this.level); } } var vip = new VipUser(&#39;Tom&#39;, 18, 3); vip.showName(); vip.showAge(); vip.showLevel(); 继承关键字extens，相当于java的继承 构造函数中使用super关键字，调用父类的构造函数 添加新的属性和新的方法 JSON标准写法 只能用双引号 所有名字都必须用引号括起来 { &quot;a&quot;: &quot;abx&quot;, &quot;b&quot;: 12, &quot;c&quot;: true } 格式化为字符串let json = {a: 11, b: 12}; alert(JSON.stringify(json)); JSON.stringify()得到的结果是一个字符串 格式化为JSONlet str = &#39;{&quot;a&quot;: 11, &quot;b&quot;: 12}&#39;; console.log(JSON.parse(str)); JSON.parse()得到的结果是一个json对象，但是，字符串的内容必须符合json格式标准，另外，双引号的外面是单引号 简写属性名简写 let a = 12; let b = 5; let json = {a, b, c: 15}; console.log(json); 当已经存在的值和json属性名一样的时候，可以只写值，不一样的可以按照json格式添加 这里的json指的是json字面量 方法简写 let json = { a: 12, show() { console.log(this.a); } } json.show(); 方法可以只写方法名，省略 function Promise作用：消除异步操作，用同步的方式来写异步代码 异步：操作之间没啥关系，同时进行多个操作；代码复杂 同步：同时只能做一件事，前面的事没干完后面的事不能开始；代码简单 封装ajax（基于jquery） let ajax = new Promise(function (resolve, reject) { $.ajax({ url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); ajax.then(result =&gt; { alert(result); }, err =&gt; { console.log(err); }) Promise.all()当有两个Promise对象时，可以使用Promisr.all()处理两个Promise对象 Promise.all([ ajax1, ajax2 ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 这里注意，当使用.all处理多个Promise对象时，有一个出错就会报错，全部成功才会执行成功的回调函数 有多个ajax请求不同地址的时候可以，再次封装 function createPromise(url) { return new Promise(function(resolve, reject) { $.ajax({ url, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); } Promise.all([ createPromise(&#39;js/arr.txt&#39;), createPromise(&#39;js/arr2.txt&#39;) ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 以上只是示例，jquery的作者当然想到了这一点，$.ajax()是有返回值的（高版本，低版本可能没有） let p = $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}); 可以将 $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}) 放到Promise.all()里面，代替上面的createPromise方法 Promise.race()同时处理多个Promise对象，有一个先完成的就停止 应用场景，同时向多个负载发送请求 Promise链式调用let test = new Promise((resolve, reject) =&gt; { let random = Math.random() if (random &gt; 0.5) { resolve(&#39;大于0.5&#39;) } else { reject(&#39;小于等于0.5&#39;) } }) let p = test.then((result) =&gt; { console.log(result) return result }).catch((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(&#39;last&#39;, result) }) console.log(p) ------------------------- Promise { &lt;pending&gt; } // p 大于0.5 // 或者小于，下同 大于0.5 last 大于0.5 promise 的 then 方法里面可以继续返回一个新的 promise 对象 下一个 then 方法的参数是上一个 promise 对象的 resolve 参数 catch 方法的参数是其之前某个 promise 对象的 rejecte 参数 一旦某个 then 方法里面的 promise 状态改变为了 rejected，则promise 方法连会跳过后面的 then 直接执行 catch；如果状态一直为fulfilled，catch里面的的代码不执行 catch 方法里面依旧可以返回一个新的 promise 对象 promies的三种状态是未决的pending（进行中），和已决的fulfilled（成功）/rejected（失败），reslove和reject是成功和失败的参数，在promies里调用参数之后then方法才会执行 参考资料： 深入理解Promise三种状态与链式调用 Promise对象then方法链式调用 生成器函数generator 普通函数：一直执行到最后 generator函数：中间可以暂停 function *show() { alert(&#39;1&#39;); yield; alert(&#39;2&#39;); } let obj = show(); obj.next(); obj.next(); 直接运行show()并不会有任何反应，用show来创建一个对象，用next方法可以执行，遇到yield停下，再执行next可以继续运行之后的部分 原理是把一个大函数的代码切分成多个小函数，每next一次执行一次 一个生成器中可以存在多个yield；注意函数命名方式 function *show(){}，带有星号 yield可以传参 第一个next无法传参，可以理解为generator的启动器，第二个next开始向第一个yield传参 function *show() { alert(&#39;1&#39;); let a = yield; alert(a); } let obj = show(); obj.next(); obj.next(10); -------------------------- // 打印结果 a=10 有返回值 function *show() { alert(&#39;1&#39;); let a = yield &#39;axc&#39; + &#39;ac&#39;; alert(a); // 10 // 如果这里return 55，那么下边b1的value就是55 } let obj = show(); let a1 = obj.next(); console.log(a1); // {value: &quot;axcac&quot;, done: false} let b1 = obj.next(10); console.log(b1); // {value: undifind, done: true} 一个yield相当于一个被分解成小函数的return 总结：第一个yield返回的值给了第一个next，第二个next的参数给了第一个yield 附：ES7 async awaitasync function doSome() { try { let data1 = await function(data); let data2 = await function(data1); let data3 = await function(data2); } catch(err) { console.log(&quot;Error:&quot; + err); } } 用同步的方式实现异步 await的返回值是promise；await后面可以用Promise.all()执行多个Promise操作 awat 外面必须包裹着async， 把await和成功后的操作放到try里，失败的放在catch 参考资料： async和await","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"VS Code 快捷键","slug":"VS Code 快捷键","date":"2020-07-14T07:29:20.384Z","updated":"2020-08-09T12:01:36.513Z","comments":true,"path":"2020/07/14/VS Code 快捷键/","link":"","permalink":"https://fengjing95.github.io/2020/07/14/VS Code 快捷键/","excerpt":"","text":"VS Code 快捷键打开一个新窗口 Ctrl+Shift+N 关闭窗口 Ctrl+Shift+W 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 复制或剪切当前行/当前选中内容 Ctrl+C 、 Ctrl+V 代码格式化： Shift+Alt+F 上下移动一行 Alt+Up 或 Alt+Down 向上向下复制一行 Shift+Alt+Up 或 Shift+Alt+Down 在当前行下方插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 移动到行首 Home 移动到行尾 End 移动到文件结尾 Ctrl+End 移动到文件开头 Ctrl+Home 移动到定义处 F12 定义处缩略图 只看一眼而不跳转过去 Alt+F12 找到所有的引用 Shift+F12 同时修改本文件中所有匹配的 Ctrl+F12 重命名 比如要修改一个方法名，可以选中后按 F2，输入新名字，回车，则所有该方法的引用也都同步更新了 跳转到下一个 Error 或 Warning 当有多个错误时可以按 F8 逐个跳转 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F","categories":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/tags/工具/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/categories/工具/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-14T07:29:20.383Z","updated":"2020-07-15T09:59:41.550Z","comments":true,"path":"2020/07/14/hello-world/","link":"","permalink":"https://fengjing95.github.io/2020/07/14/hello-world/","excerpt":"","text":"2020-07-13 博客诞生","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://fengjing95.github.io/tags/hello/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]}]}