{"meta":{"title":"前端小枫","subtitle":"","description":"","author":"小枫","url":"https://easyremember.cn"},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"client/index.html","permalink":"https://easyremember.cn/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"bangumi/index.html","permalink":"https://easyremember.cn/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"about/index.html","permalink":"https://easyremember.cn/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-07-13T12:13:10.594Z","comments":true,"path":"comment/index.html","permalink":"https://easyremember.cn/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-07-13T12:13:10.595Z","comments":false,"path":"lab/index.html","permalink":"https://easyremember.cn/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-13T12:13:10.596Z","comments":false,"path":"music/index.html","permalink":"https://easyremember.cn/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-09-04T08:55:27.099Z","comments":true,"path":"links/index.html","permalink":"https://easyremember.cn/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"tags/index.html","permalink":"https://easyremember.cn/tags/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"donate/index.html","permalink":"https://easyremember.cn/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"rss/index.html","permalink":"https://easyremember.cn/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://easyremember.cn/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"video/index.html","permalink":"https://easyremember.cn/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Vue组件库开发","slug":"技术/Vue组件开发","date":"2021-04-27T10:42:53.253Z","updated":"2021-04-30T10:45:04.841Z","comments":true,"path":"2021/04/27/技术/Vue组件开发/","link":"","permalink":"https://easyremember.cn/2021/04/27/技术/Vue组件开发/","excerpt":"","text":"技术铺垫本节内容以技术铺垫为主，如果你对这里的内容非常自信可以跳到下一节，当然也可以帮我找找错😂 必要性随着Vue在国内市场的占有率越来越高，组件库同时也火了起来，很多公司内部也为了适应其自身业务而开始开发其自有的组件库，我们现在使用的Element UI（饿了么）、Nut UI（京东）等组件库都是大厂开源出来的组件库。与此同时，拥有组件库开发经验也已经成为了我们在应聘面试中的加分项。 组件库中的组件开发其实给跟我们平常开发组件本质是相同的，只不过我们需要尽可能地考虑到组件的复用性，使组件可以面对多种情况下的业务需求，而且组件库不能和业务耦合，应该和业务完全脱离，即使切换另一种业务也可以使用。 基础API组件的开发脱离不开prop、slot和event这三个API，此外还要考虑组件之间的通信，比如form和form-item、checkbox和checkbox-group等，他们之间其实是有联系的 propprop在我们平常的开发任务中也是经常使用的一个API，用于子组件接受父组件传递的参数，尽管日常使用，但是还是有人在规范性等方面用得并不是很好。 抛弃数组写法：虽然支持数组写法，但是官方都不推荐的数组写方法就扔掉吧 // 摒弃吧 // props: [&#39;status&#39;] // 至少也这样吧 props: { status: String // 等同于 // status: { // type: String // } } 键值的写法只是提供了类型限制，除此之外，prop还有其他的属性，比如必填项以及内容验证等；validator的值是一个函数，可以将当前prop接受的值传递给函数，返回值如果是一个失败类型的值就会在控制台抛出异常 下面的验证规则限制了status必须是’success’, ‘warning’, ‘error’中的一个 props: { status: { type: String, validator: function(prop) { return [ &#39;success&#39;, &#39;warning&#39;, &#39;error&#39; ].indexOf(prop) &gt;= 0 }, default: &#39;success&#39;, required: true, // 一般默认值不会和必填项同时出现 } } 然后我在使用组件时传入一个错误的值 &lt;message status=&quot;warning1&quot; /&gt; 此外还有一点，子组件不能直接修改接收的prop值 slot我理解的slot作用就是在子组件中插入父组件的内容，子组件在定义时提供一个插槽，父组件在使用子组件时可以向插槽中插入内容。相当于插座和插头，下面这张图类似于具名插槽，父组件使用的插槽名和子组件中的插槽名不匹配，就无法使用 普通的插槽很简单，在子组件中声明插槽，父组件直接添加内容即可，插槽可以设置默认内容，当父组件没有内容传进来时，就会使用默认内容，类似于prop的default属性 &lt;!-- 父组件 --&gt; &lt;message&gt; 我是父组件的内容 &lt;/message&gt; &lt;!-- 子组件 --&gt; &lt;div&gt; 接受插槽： &lt;slot&gt;后备内容&lt;/slot&gt; &lt;/div&gt; 在上面我们提到了具名插槽，其实就是为了有多个插槽内容时区分内容。使用方法也很简单，在子组件声明slot时添加name属性即可，父组件在使用时添加v-slot:[name]属性（原来是slot=”name”，已废弃但没有删除，现阶段这样用也可以） &lt;!-- 父组件 --&gt; &lt;message status=&quot;warning&quot;&gt; &lt;template v-slot:header&gt;我是父组件的头部内容&lt;/template&gt; &lt;template v-slot:footer&gt;我是父组件的底部内容&lt;/template&gt; &lt;/message&gt; &lt;!-- 子组件 --&gt; &lt;div&gt; 头部插槽： &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;br /&gt; 底部插槽： &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt; 不添加name属性时，默认会赋值name=”default”，父组件在使用时不添加v-slot属性默认就是v-slot:default，所以普通插槽也相当于具名插槽，只是默认名。下面两种用法是一样的 &lt;message status=&quot;warning&quot;&gt; &lt;template v-slot:default&gt;我是父组件的内容&lt;/template&gt; &lt;/message&gt; &lt;message status=&quot;warning&quot;&gt; &lt;template&gt;我是父组件的内容&lt;/template&gt; &lt;/message&gt; 还有一种作用域插槽，用简单的话来说就是，在父组件中使用子组件的数据，这里的作用域也就是指的父组件接收子组件作用域 子组件在声明插槽时绑定一个变量，父组件在使用插槽时使用v-slot=”props”接受这个变量（原来是slot-scope，同样已废弃），然后使用变量我们继续使用上面的例子稍加改造 &lt;!-- 父组件 --&gt; &lt;message status=&quot;warning&quot;&gt; &lt;template v-slot:header=&quot;sonData&quot;&gt;{{sonData.user.name}}今年{{sonData.user.age}}岁了&lt;/template&gt; &lt;template v-slot:footer&gt;我是父组件的底部内容&lt;/template&gt; &lt;/message&gt; &lt;!-- 子组件 --&gt; &lt;div&gt; 头部插槽： &lt;slot name=&quot;header&quot; :user=&quot;user&quot;&gt;&lt;/slot&gt; &lt;br /&gt; 底部插槽： &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt; v-slot指令可以缩写为#，比如v-slot:header可以缩写为#header，默认插槽不可以简写，但是你可以使用#default event事件这一块内容虽然很简单，但说起来比较琐碎，看文档吧😂 此外你还需要了解组件之间的通信，组件之间的通讯大致有ABCD这几种情况（大体列一下，不展开细说了） AB之间父子关系，AC和AD时祖先和后代的关系，CD之间是兄弟关系 props/$emit，用于父子之间通信 $on/$emit，可以在任意组件之间通信 $children/$parent，可用于父子组件 $ref，通过标记来获取组件实例 $attrs/$listeners，attrs包含了父作用域中不被 prop 所识别的属性，listeners包含了父作用域中的 (不含 .native 修饰器的) 事件监听器 provide/inject，可以在祖孙之间传递数据 实战一，Form组件上一节我们为组件开发做了技术铺垫，这一节开始我们来进入实战环节 首先我们来实现一套Form组件，如果你使用过市面上比较流行的组件库，你应该知道一套Form组件应该包含这样的内容 那么我们首先下一个用例，从用例出发，倒推组件 &lt;f-form :model=&quot;userForm&quot; :rules=&quot;rules&quot;&gt; &lt;f-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;f-input v-model=&quot;userForm.username&quot; placeholder=&quot;请输入用户名&quot; /&gt; &lt;/f-form-item&gt; &lt;f-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;f-input type=&quot;password&quot; v-model=&quot;userForm.password&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;/f-form-item&gt; &lt;/f-form&gt; &lt;script&gt; export default { data() { return { userForm: { username: &#39;&#39;, password: &#39;&#39; }, rules: { username: [ {required: true, message: &#39;请输入用户名&#39;} ], password: [ {required: true, message: &#39;请输入密码&#39;} ] } } } } &lt;/script&gt; 从内而外实现，从input开始，然后form-item，最后form，话不多说开搞 f-input首先来输入框，你可能会觉着这东西很简单，但是不要忘了我们之前说的，子组件不能直接修改prop接收的值，所以赶紧抛弃你直接v-model绑定prop的想法。 如果你不关闭警告你会看到这样的警告 这里你需要知道，其实v-model是一个语法糖，下面这两行其实作用是一样的 1&lt;input v-model=&quot;username&quot; /&gt; &lt;br/&gt; 2&lt;input :value=&quot;username&quot; @input=&quot;username = $event.target.value&quot; /&gt; &lt;br/&gt; {{username}} 运行一下看下结果 所以在f-input中你可以这样来实现绑定的传递 &lt;template&gt; &lt;div&gt; &lt;input :value=&quot;value&quot; @input=&quot;inputHandler&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { value: { type: String, default: &#39;&#39; } }, methods: { inputHandler(e) { this.$emit(&#39;input&#39;, e.target.value) } } } &lt;/script&gt; 这时候再去试试，发现已经可以了，控制台也没有报警告 然后你又发现了一个问题，设置的placeholder没有生效，因为他被添加到f-input上，而不是f-input里面的input上 官网API文档有这么一段 它的作用总结下来就是，如果开启此选项，父组件绑定的属性没有被props接收的，将会存在$attrs里面，可以使用v-bind将$attrs绑定在任意非根组件上，然后把我们的f-input稍加改造 &lt;template&gt; &lt;div&gt; &lt;input :value=&quot;value&quot; @input=&quot;inputHandler&quot; v-bind=&quot;$attrs&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { inheritAttrs: true, // 省略部分代码 &lt;/script&gt; 完美，可以看到设置的密码型输入框也已经生效了 f-form-item到这里就比上面的输入框稍微有点难度了，但也很简单，这里需要实现的点是 label文本 给表单组件预留插槽 按规则校验并提示错误 前两点都很简单，你应该比较畏惧第三点，其实这个也很简单，有现成的“轮子”——async-validator，作为程序员要杜绝重复造轮子😂 想一下我们之前的用例中form-item的属性：label和prop，然后配置要接收的参数 &lt;template&gt; &lt;div&gt; &lt;label v-if=&quot;label&quot;&gt;{{label}}&lt;/label&gt; &lt;slot&gt;&lt;/slot&gt; &lt;p v-if=&quot;errorMessage&quot;&gt;{{errorMessage}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { label: { type: String, default: &#39;&#39; }, prop: { type: String, } }, data() { return { errorMessage: &#39;&#39; } }, } &lt;/script&gt; 这样我们第一步和第二步都完成了，接下来就是validate了，接受的prop的作用就是为了从form组件中绑定的rules中获取需要使用的验证规则，同时也使用prop从form绑定的表单内容中获取当前表单项的值。这里可以使用provide/inject来传递数据 &lt;script&gt; import Schema from &#39;async-validator&#39; export default { inject: [&#39;form&#39;], props: { label: { type: String, default: &#39;&#39; }, prop: { type: String, } }, data() { return { errorMessage: &#39;&#39; } }, methods: { validate() { const rule = this.form.rules[this.prop] const value = this.form.model[this.prop] // 获取验证规则实例 const description = {[this.prop]: rule} const schema = new Schema(description) // 使用验证规则实例的验证方法 return schema.validate({[this.prop]: value}, (error, field) =&gt; { if(error) { this.errorMessage = error[0].message console.log(`${field}验证未通过`); } else { this.errorMessage = &#39;&#39; } }) } }, } &lt;/script&gt; 然后添加验证事件的监听器，在内部表单项值修改时动态验证 mounted() { this.$on(&#39;validate&#39;, this.validate) } 再顺便修改一下f-input的内容 methods: { inputHandler(e) { this.$emit(&#39;input&#39;, e.target.value) // 通知验证 this.$parent.$emit(&#39;validate&#39;) } } OK~~form-item齐活 f-form在完成了form-item和input组件之后，form组件就简简单单了，再来看一下form要做的事 接收验证规则和表单数据 给form-item预留插槽 全局校验方法 首先我们来实现前两步，很简单，不要忘了之前form-item使用inject接收的数据，这里需要绑定上 &lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { provide() { return { form: this } }, props: { model: { type: Object, required: true }, rules: { type: Object } } } &lt;/script&gt; 接下来全局的校验，接受一个回调函数，回调函数的参数是一个布尔值，代表校验是否通过，使用Promise.all来执行多个验证器，只要有失败的就返回false methods: { validate(cb) { const validators = this.$children .filter(item =&gt; item.prop) .map(item =&gt; item.validate()) Promise.all(validators) .then(() =&gt; cb(true)) .catch(() =&gt; cb(false)) } }, 然后在修改一下用例，添加一个提交按钮，绑定全局校验 &lt;template&gt; &lt;div&gt; &lt;f-form :model=&quot;userForm&quot; :rules=&quot;rules&quot; ref=&quot;formRef&quot;&gt; &lt;f-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;f-input v-model=&quot;userForm.username&quot; placeholder=&quot;请输入用户名&quot; /&gt; &lt;/f-form-item&gt; &lt;f-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;f-input type=&quot;password&quot; v-model=&quot;userForm.password&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;/f-form-item&gt; &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/f-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 省略部分代码 methods: { submit() { this.$refs.formRef.validate(valid =&gt; { if(valid) { console.log(&#39;通过验证&#39;); } else { console.log(&#39;验证失败&#39;); } }) } }, } &lt;/script&gt; 到现在我们就已经粗略的完成了一套form组件，当然他的功能并不止于此，这只是起了个头具体功能完善也就不在这里细说了，效果展示如下，样式细节也不在这里扣了 实战二，Message组件上一节我们实现了写在模板里面的组件，还有一种组件比如message消息提示，它的使用要求比较灵活，不确定在什么组件中出现，所以不能写死在模板中，要使用js动态控制 这种组件就需要手动地实现挂载与卸载了，在开始之前需要做一下铺垫Vue.extend(options)，创建一个子类包含配置的选项 首先我们来构建一个消息的模板 &lt;template&gt; &lt;div class=&quot;message&quot;&gt; &lt;p&gt;{{ message }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;message&quot;, data() { return { message: &quot;message&quot;, }; }, &lt;/script&gt; 然后再创建一个Message.js，用于渲染这个模板 import Vue from &#39;vue&#39;; import Message from &#39;./Message.vue&#39; export default function() { const MessageConstructor = Vue.extend(Message) const component = new MessageConstructor().$mount() document.body.appendChild(component.$el) } 上面的最后一段代码，我们调用了 $mount 方法对组件进行了手动渲染，这里渲染之后的结果是一个Node节点，我们需要手动将它插入到document中 使用组件也很简单，导入并执行这个函数。我们来使用一个按钮触发这个消息渲染 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;alert&quot;&gt;消息&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Message from &#39;./Message.js&#39; export default { methods: { alert() { Message() } } } &lt;/script&gt; 来看下效果 还行，我们来继续完善一下，首先需要自动删除节点，我们要在出现提示之后一定时间内取消展示，思路也很简单，在mounted之后添加一个延时卸载Node节点的方法 mounted() { setTimeout(() =&gt; { // duration 后通过父级移除子元素的方式移除该组件实例和DOM节点 this.$destroy(true); this.$el.parentNode.removeChild(this.$el); }, this.duration); }, 现在我们来考虑一下通过配置控制消息内容 调用组件时传入一个配置对象 在创建渲染实例时将参数传递进去，覆盖掉继承来的属性 对我们的Message.js稍加改造，让参数覆盖data选项 export default function(options) { const MessageConstructor = Vue.extend(Message) const component = new MessageConstructor({data: options}).$mount() document.body.appendChild(component.$el) } 然后我们来使用一下，配合我们之前的表单校验一起试一下 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;f-form :model=&quot;userForm&quot; :rules=&quot;rules&quot; ref=&quot;formRef&quot;&gt; &lt;f-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;f-input v-model=&quot;userForm.username&quot; placeholder=&quot;请输入用户名&quot; /&gt; &lt;/f-form-item&gt; &lt;f-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;f-input type=&quot;password&quot; v-model=&quot;userForm.password&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;/f-form-item&gt; &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/f-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import FFormItem from &#39;./components/FFormItem.vue&#39; import FInput from &#39;./components/FInput.vue&#39; import FForm from &#39;./components/FForm.vue&#39; import Message from &#39;./components/Message&#39; export default { name: &#39;App&#39;, components: { FFormItem,FInput,FForm }, data() { return { userForm: { username: &#39;&#39;, password: &#39;&#39; }, rules: { username: [ {required: true, message: &#39;请输入用户名&#39;, tigger: &#39;blur&#39;} ], password: [ {required: true, message: &#39;请输入密码&#39;, tigger: &#39;blur&#39;} ] }, username: &#39;&#39; } }, methods: { submit() { this.$refs.formRef.validate(valid =&gt; { if(valid) { Message({ message: &#39;通过验证&#39;, duration: 5000 }) } else { Message({ message: &#39;验证失败&#39;, duration: 2000 }) } }) }, }, } &lt;/script&gt; 可以看到时间、内容都已经生效了 然后为了使用方便我们可以在入口文件将Message挂载到Vue的原型上Vue.prototype.$message = Message，，然后其他组件内部再使用时就可以直接this.$message() 这里我们只实现了一个简单的message，他还可以有很多扩展方向，比如通知类型（根据类型控制message颜色样式不一样）或者内嵌icon等，我们在这就不说了，有了这个结构再去拓展就很简单了 实战三，树形组件和动态组件之前我们介绍了两种类型的组件封装，现在我们来说一下另外一种组件，递归组件。这种组件可用于列表展开、树形表格等 递归组件我们在使用组件时一般都是先使用import导入，然后在components选项中声明，最后在组件中使用；但其实还有一种使用组件的方法，当组件声明了选项name之后就可以使用name调用自身了，这也是递归组件的原理 但是不可以直接使用，需要有一个限制条件，不然就会调用栈溢出了，比如下面这样 我们来实现一个简易的树形组件，用来展开和闭合列表 首先我们来创建一个模板 &lt;template&gt; &lt;li&gt; &lt;div @click=&quot;toggle&quot;&gt; {{model.title}} &lt;span v-if=&quot;isFolder&quot;&gt;[{{open ? '-' : '+'}}]&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/template&gt; 这里只是做示范，在使用外层需要有个ul包裹，当有子组件时会显示+和-，展开式显示-，关闭时显示+，isFolder就是一个计算属性，用来判断有没有子组件，通过事件来控制open的开闭 export default { name: &quot;Tree&quot;, props: { model: { type: Object, required: true, }, }, data() { return { open: false }; }, computed: { isFolder() { return this.model.children &amp;&amp; this.model.children.length; } }, methods: { toggle() { if (this.isFolder) { this.open = !this.open; } }, }, }; 我们来添加一下数据来试一下效果 &lt;template&gt; &lt;ul&gt; &lt;tree v-for=&quot;(model, index) in treeData&quot; :key=&quot;index&quot; :model=&quot;model&quot;&gt;&lt;/tree&gt; &lt;/ul&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { treeData: [ { title: &#39;打野&#39;, children: [ { title: &#39;刺客&#39;, children: [ { title: &#39;兰陵王&#39; },{ title: &#39;李白&#39; } ] // ……省略大段数据代码 } } } &lt;/script&gt; 现在的效果是这样的 接下来我们就来注入灵魂，实现组件递归，将tree组件做一下修改 &lt;template&gt; &lt;li&gt; &lt;div @click=&quot;toggle&quot;&gt; {{model.title}} &lt;span v-if=&quot;isFolder&quot;&gt;[{{open ? '-' : '+'}}]&lt;/span&gt; &lt;/div&gt; &lt;ul v-show=&quot;open&quot; v-if=&quot;isFolder&quot;&gt; &lt;tree class=&quot;item&quot; v-for=&quot;model in model.children&quot; :model=&quot;model&quot; :key=&quot;model.title&quot;&gt;&lt;/tree&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/template&gt; 然后再看效果 完成，当然这只是粗略版本，这样拿出去肯定是用不了的，还需要拓展功能调整样式","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"canvas入门","slug":"技术/canvas","date":"2021-04-22T13:49:57.433Z","updated":"2021-04-23T10:41:05.463Z","comments":true,"path":"2021/04/22/技术/canvas/","link":"","permalink":"https://easyremember.cn/2021/04/22/技术/canvas/","excerpt":"","text":"了解canvas背景canvas是为了解决页面只能显示静态图片而出现的一种可以使用JavaScript绘制的HTML标签，它可以接受两个参数width和height（原来有三个，还有一个moz-opaque控制透明度，已经废弃了） 注意事项：不同于img标签的自闭和，canvas必须要有闭合标签；能直接在canvas标签上设置宽高尽量直接在标签属性设置宽高，其次可以通过js来设置，尽量不要通过css样式来设置宽高，可能会出现拉伸等情况，这一点MDN也给出了说明 注意: 如果你绘制出来的图像是扭曲的, 尝试用width和height属性为&lt;canvas&gt;明确规定宽高，而不是使用CSS。 除了canvas之外你可能还会听过svg，svg是一种使用xml定义的矢量图，而canvas是使用JavaScript控制绘制出来的位图 由于主题是canvas，所以这里我们之说canvas，不聊svg 用途canvas最常用的功能是用来绘制图表，比如我们常用的ECharts图标库底层就是使用的canvas，我手上最近的一个项目中就用到了ECharts 这是他的DOM文档体现 由于是通过JavaScript驱动绘制的，所以数据都是可以动态传入的，这是静态图片（jpg/png……）所无法比拟的 此外canvas可以用来制作游戏，这是我以前玩过的魔方游戏（虽然体验完全不如实体） 还可以用来做活动页面，很多商家都会用这种形式来做营销活动 你可能还会再某些博客中看到这样的特效，他也是canvas实现的 基本用法收先需要在HTML文档中声明canvas标签，标签可以添加后备内容，以防止浏览器不兼容canvas，后备内容可以是一串文本、一张图片或者是动态提娜佳的内容 &lt;canvas id=&quot;canvas&quot;&gt; 很遗憾你的浏览器不支持canvas &lt;/canvas&gt; &lt;canvas id=&quot;canvas&quot;&gt; &lt;img src=&quot;./img.png&quot; /&gt; &lt;/canvas&gt; 在使用canvas之前，我们需要获取canvas的上下文 const canvas = document.getElementById(&#39;canvas&#39;) // 标注id属性的元素会自动创建全居变量，可以直接使用id操作，但是不推荐 const context = canvas.getContext(&#39;2d&#39;) 上下文的类型有三种，分别是 2d（本小册所有的示例都是 2d 的）：代表一个二维渲染上下文 webgl（或”experimental-webgl”）：代表一个三维渲染上下文 webgl2（或”experimental-webgl2”）：代表一个三维渲染上下文；这种情况下只能在浏览器中实现 WebGL 版本2 (OpenGL ES 3.0) 在获取路径之后，我们就可以通过上下文的api来进行绘制路径了，比如你可以使用context.arc(x, y, r,angle1, angle2, direction)来绘制一个圆，其中参数的含义为： x：圆心x坐标 y：圆心y坐标 r：半径 angle1：起始角度，默认水平向右，也就是三点钟 angle2：结束角度，从开始角度旋转的度数 direction：旋转方向，true是逆时针，false是顺时针 context.beginPath(); // 起始一条路径，或重置当前路径 context.arc(100, 100, 50, 0, Math.PI * 2, true); // 曲线 context.closePath(); // 闭合曲线 context.fillStyle = &#39;rgb(0,0,0)&#39;; // 设置填充样式 context.fill(); // 填充 效果如下 这一节我们大体介绍了canvas的用途，下一节开始我们就开始讲解canvas的具体使用 canvasAPI（上）上一节最后我们说了一个绘制曲线的API——arc（那个API并不是专门用来绘制圆形，只是使用曲线可以绘制圆形），他还有一个兄弟——arcTo（x1, y1, x2, y2, r），根据当前描点与给定的控制点1连接的直线，和控制点1与控制点2连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径 x1：第一个控制点x坐标 y1：第一个控制点y坐标 x2：第二个控制点x坐标 y2：第二个控制点y坐标 r：曲线半径 示意图如下 路径先来熟悉一下必用的路径相关的API beginPath()：新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。 closePath()：闭合路径之后图形绘制命令又重新指向到上下文中。 stroke()：通过线条来绘制图形轮廓。 fill()：通过填充路径的内容区域生成实心的图形。 接下来从点开始 moveTo(x, y)——移动当前描点到指定坐标 然后是线 lineTo(x, y)——绘制从当前描点到指定点的直线 到这里我们可以来做一个小练习，绘制一个圆角矩形的一个角 首先画一条线，然后画一条曲线，然后再画一条直线 ctx.beginPath(); ctx.moveTo(20, 20) ctx.lineTo(60, 20) ctx.arcTo(120, 20, 120, 40, 50) ctx.lineTo(120, 80) ctx.stroke(); 这里在绘制曲线的时候要需要计算曲线半径，曲线半径设置错误之后效果体现不出来了 绘制矩形，有三个API与绘制矩形有关，分别是： fillRect(x, y, width, height)绘制一个填充的矩形 strokeRect(x, y, width, height)绘制一个矩形的边框 clearRect(x, y, width, height)清除指定矩形区域，让清除部分完全透明。 rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。 参数：x——矩形的起点x坐标，y——矩形的起点y坐标，width——矩形的宽，height——矩形的高 ctx.fillRect(25, 25, 100, 100); ctx.clearRect(45, 45, 60, 60); ctx.strokeRect(50, 50, 50, 50); 注意：重头戏要来了——二次贝塞尔曲线和三次贝塞尔曲线 如果你使用过PhotoShop的钢笔工具，你一定不会陌生贝塞尔曲线，放一个简书的链接，如果你对数学感兴趣可以看看 quadraticCurveTo(cp1x, cp1y, x, y)绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。 这里再贴一张MDN的图片，红点代表控制点，蓝点代表起始点和结束点 总之，贝塞尔曲线用于绘制不规则曲线，当然这可能需要你有耐心去计算，因为绘制的曲线没有给我们提供直接的视觉反馈 有关路径的API基本就是这些，但是在绘制过程中不可能一个路径一个路径地去绘制，canvas也提供了路径服用的方法——Path2D Path2D是一个构造函数，可以用来克隆路径，比如 const path1 = new Path2D() path1.rect(10, 10, 100,100) const path2 = new Path2D(path1) path2.arc(225, 55, 55, 0, 2 * Math.PI) ctx.fill(path2); 创建一个路径path1，绘制一个矩形，然后创建一个path2克隆path1，在此基础上绘制一个圆，最后只渲染path2，可以看到path1的内容也有了 样式和颜色 fillStyle = color设置图形的填充颜色。 strokeStyle = color设置图形轮廓的颜色。 color的值跟css色彩的值是一样的，可以是16进制色彩、色彩英文单词、RGB以及RGBA，如 fillStyle ＝ &#39;red&#39; fillStyle ＝ &#39;#409eff&#39; fillStyle ＝ &#39;rgb(255, 255, 0)&#39; fillStyle ＝ &#39;rgba(255, 255, 255, 0.1)&#39; rgba的最后一个参数是透明度，除此之外还提供了专门的API来设置透明度，globalAlpha 取值介于0（全透）-1（不透）之间，设置globalAlpha 之后透明度可以叠加，叠加越多透明度越低。 下面的API可以用来设置线条的样式 lineWidth = value设置线条宽度。 lineCap = type设置线条末端样式。取值有butt（平齐），round（超出圆头）和 square（超出方形）。默认是 butt lineJoin = type设定线条与线条间接合处的样式。 miterLimit = value限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。 getLineDash()返回一个包含当前虚线样式，长度为非负偶数的数组。 setLineDash(segments)设置当前虚线样式。接受一个数组，来指定线段与间隙的交替 lineDashOffset = value设置虚线样式的起始偏移量。 渐变作为一种比较炫酷的样式当然不能少了 createLinearGradient(x1, y1, x2, y2)createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。 createRadialGradient(x1, y1, r1, x2, y2, r2)createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆 createLinearGradient 是线性渐变，createRadialGradient 是圆形渐变 在创建渐变对象之后就可以给他上色了，使用gradient.addColorStop(position, color)方法给渐变对象上色，posotion是一个介于0-1的值，0.5表示在正中心渐变 var lineargradient = ctx.createLinearGradient(0,0,150,150); lineargradient.addColorStop(0,&#39;white&#39;); lineargradient.addColorStop(1,&#39;black&#39;); ctx.fillStyle = lineargradient ctx.fillRect(10,10,130,130) 阴影也是一个非常好看的效果： shadowOffsetX = float：shadowOffsetX 用来设定阴影在 X 轴的延伸距离，不受变换矩阵所影响。负值表示阴影会往左延伸，正值则表示会往右延伸，默认为 0。 shadowOffsetY = float：shadowOffsetY用来设定阴影在 Y 轴的延伸距离，不受变换矩阵所影响。负值表示阴影会往上，正值则表示会往下，默认为 0。 shadowBlur = float：shadowBlur 用于设定阴影的模糊程度，默认为 0。 shadowColor = color：shadowColor 用于设定阴影颜色效果，默认是全透明的黑色。 在我们上一个渐变的基础上加上阴影 ctx.shadowOffsetX = 8; ctx.shadowOffsetY = 8; ctx.shadowBlur = 2; ctx.shadowColor = &quot;rgba(0, 0, 0, 0.5)&quot;; 填充规则fill()，填充我们之前已经用到很多了，他有两个规则，也就是参数nonzero（默认路径内部）和evenodd（路径外部），这是相对于当前路径来说的，在路径嵌套式效果明显 canvasAPI（下）书接上回 图片所有的内容都是手动绘制还是有点麻烦，好在canvas支持导入图片，createPattern(image, type)，该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。 这里引一张我掘金的头像来做示例，要注意这里需要等待图片加载完之后再渲染 // 创建新 image 对象，用作图案 var img = new Image(); img.src = &#39;https://sf6-ttcdn-tos.pstatp.com/img/user-avatar/01434b575492b00010706d94d5b975aa~300x300.image&#39;; img.onload = function() { // 创建图案 var p = ctx.createPattern(img, &#39;no-repeat&#39;); ctx.fillStyle = p; ctx.fillRect(0, 0, 150, 150); } 文本图片都可以渲染那文本不也轻轻松松，canvas 提供了两种方法来渲染文本: fillText(text, x, y [, maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. strokeText(text, x, y [, maxWidth])在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. 根据API的语义就可以知道作用，stroke和fill就是我们前面用的描边和填充 文本可以设置字体等样式 font = value当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。 textAlign = value文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。 textBaseline = value基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。` direction = value文本方向。可能的值包括：ltr,rtl,inherit。默认值是inherit。` 这些跟css的样式是基本一致的 移动和缩放既然canvas是为了解决动态图片的问题而设计的，那么移动和缩放可以说是动画的基础 移动很简单，使用translate(x, y)来控制移动，x和y分别就是x轴和y轴的偏移量； 旋转使用rotate(angle)，接受一个角度参数，沿顺时针方向，旋转点默认是（0，0）点，除非我们使用translate来移动它（比如直接ctx.translate(10, 10)即可）； 接下来是缩放，scale(x, y)，x和y分别是x轴和y轴方向的所当比例，1为不变，&lt;1是缩小，反之放大；如果出现负数，就是按照所在的轴进行镜像翻转 如果你熟悉css的transform，那这里应该也很简单，他们很相似。 蒙版关于蒙版内容，放个文档在这里吧，说起来太费劲了，如果你用过PhotoShop，你可能会比较好理解 动画关于动画可以使用的方法有三种setTimeout、setInterval、requestAnimationFrame，前两个就是你熟悉的那两个定时器，requestAnimationFrame诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。 动画的大体过程如下： 清除上一帧，可以使用的方法很多，最简单的就是清空矩形，长宽为canvas的长宽 保存canvas状态（样式，变形之类的）,ctx.save() 绘制图形 恢复canvas状态,ctx.restore() 我们这里来做一个小的示例，矩形下落 ctx.beginPath(); let h = 0 function down() { h += 1 ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillRect(0, h, 100, 100) window.requestAnimationFrame(down) } down() 效果如下 那么关于canvas的API我们也已经了解的差不多了，下一节，我们来实现一个五子棋的小游戏 canvas实战——五子棋之前三节我们铺垫了canvas的相关知识，这一节我们来“落地”，实现一个五子棋的小游戏 开始之前，我们先想一下要做什么： 首先我们要绘制一个棋盘 然后要有黑子和白子 每次落子时判断当前位置是否已经落子，“米”字型方向上是否有五个子，如果满足条件，当前落子一方获胜 下面马上开始，先做好准备工作，准备一个canvas容器和一个刷新按钮用来重新开盘，然后准备一个结果区显示提示信息 &lt;canvas id=&quot;canvas&quot; width=&quot;200px&quot; height=&quot;200px&quot;&gt;&lt;/canvas&gt; &lt;p class=&quot;result&quot;&gt;&lt;/p&gt; &lt;button onclick=&quot;loadPanel(400, 400,30,13)&quot;&gt;刷新&lt;/button&gt; 棋盘首先我们来绘制棋盘，这个很简单，循环画直线即可，我们将所有的操作放置在一个函数中，以便重新开局 /** * @param w 棋盘宽度 * @param h 棋盘高度 * @param cs 格子尺寸 * @param ps 棋子半径 */ function loadPanel(w, h, cs, ps) { let i, j, k; //1)绘制棋盘,边缘应隔开棋子半径的距离 cs = cs || 16;//默认格子宽高 ps = ps || 4;//棋子半径 h = h || w;//高度默认等于宽度 let el = document.getElementById(&#39;canvas&#39;); el.setAttribute(&#39;width&#39;, w + &#39;px&#39;); el.setAttribute(&#39;height&#39;, h + &#39;px&#39;); let context = el.getContext(&quot;2d&quot;); //计算棋盘分割，向下取整 let splitX = ~~((w - 2 * ps) / cs), splitY = ~~((h - 2 * ps) / cs); //循环划线 context.translate(ps, ps); context.beginPath(); context.strokeStyle = &#39;#000&#39;; //垂直线 for (i = 0; i &lt; splitX + 1; i++) { context.moveTo(cs * i, 0); context.lineTo(cs * i, splitY * cs); context.stroke(); } //水平线 for (j = 0; j &lt; splitY + 1; j++) { context.moveTo(0, cs * j); context.lineTo(splitX * cs, cs * j); context.stroke(); } context.closePath(); } // 绘制棋盘 loadPanel(400, 400, 30, 13); ~~作用是向下取整，可以将浮点类型转为整数，字符串类型的数字也可以，但是无法转为数字的结果为0 现在打开浏览器，看一下效果 棋子棋子的绘制也不难，就是画圆，黑子填充黑色，白子填充白色，然后描个边，相关API之前也有过介绍，我们先在棋盘上绘制两个静态的棋子观察效果 context.beginPath() context.arc(cs * 0, cs * 0, ps, 2 * Math.PI, false); context.fillStyle = &#39;#fefefe&#39; context.fill() context.stroke(); context.closePath() context.beginPath() context.arc(cs * 1, cs * 0, ps, 2 * Math.PI, false); context.fillStyle = &#39;#000&#39; context.fill() context.stroke(); context.closePath() 效果还不错，但是在下棋时需要鼠标点击，这里的棋子渲染是需要鼠标点击事件来触发的，下面来给canvas添加鼠标点击事件，我们需要获取鼠标的点击坐标，然后计算出他应该落在哪个点，还要循环落子， let user = 0, colors = [&#39;#000&#39;, &#39;#fefefe&#39;]; el.addEventListener(&#39;click&#39;, function (e) { let x = e.offsetX, y = e.offsetY, //计算落子范围 rx = ~~((x - ps) / cs) + (((x - ps) % cs &lt;= cs / 2) ? 0 : 1), ry = ~~((y - ps) / cs) + (((y - ps) % cs &lt;= cs / 2) ? 0 : 1); context.beginPath(); context.arc(cs * rx, cs * ry, ps, 2 * Math.PI, false); context.fillStyle = colors[user]; context.strokeStyle = &#39;#000&#39;; user ? user = 0 : user = 1;//切换执子者 context.fill(); context.stroke(); context.closePath(); }) 现在我们已经完成了50%了 胜方判定现在进行做事后的一步，判定“米”字方向上是否存在5个同色棋子，我们先来考虑一下答题思路，你先不要往下看，先考虑一下自己的想法 好了，现在不管你想没想出来，我来说一下大概思路，首先定义一个对象来存储落子情况，大概的形式是这样的 { &#39;1-1&#39;: 0, &#39;1-2&#39;: 1 } // key是棋盘位置，value是身份 然后使用分别使用[0,1]、[1, 0]、[1, 1]、[1, -1]表示上下、左右、斜向上、斜向下四个方位，待会会分别拿这几个方位来进行遍历，原理大概是这样的 以[0, 1]为例，在for（let i = 1; i&lt;= 4 ; i++）{}中，分别用0和1去乘以i，然后加上当前点击未知的x或者y坐标，就能够遍历，因为i无论是多少乘0都是0，所以x坐标是不会变的，那么y坐标会遍历上边的四个，如果这四个的都是当前落子选手的即判定为赢，如果找不到就向反方向去找，即循环for（let i = -1; i&gt;= -4 ; i–）{}，如果当前循环结束没有判定胜利再去其他方向重读此步骤 计算出坐标来之后在存储落子的对象中寻找落子者，如果是当前落子者就累加，如果遍历结束满足获胜条件游戏结束 let user = 0, colors = [&#39;#000&#39;, &#39;#fefefe&#39;]; let chks = [[1, 0], [0, 1], [1, 1], [1, -1]]; // 四个方向 let pieces = {}; // 记录游戏者落子位置 let successNum = 5;//赢棋标准 let resultEl = document.querySelector(&#39;.result&#39;); el.addEventListener(&#39;click&#39;, function (e) { let x = e.offsetX, y = e.offsetY, //计算落子范围 rx = ~~((x - ps) / cs) + (((x - ps) % cs &lt;= cs / 2) ? 0 : 1), ry = ~~((y - ps) / cs) + (((y - ps) % cs &lt;= cs / 2) ? 0 : 1); context.beginPath(); context.arc(cs * rx, cs * ry, ps, 2 * Math.PI, false); context.fillStyle = colors[user]; context.strokeStyle = &#39;#000&#39;; user ? user = 0 : user = 1;//切换执子者 context.fill(); context.stroke(); context.closePath(); piece = pieces[rx + &#39;-&#39; + ry] = user; for (j = 0; j &lt; chks.length; j++) { let num = 1, chk = chks[j]; for (i = 1; i &lt;= 4; i++) { if (pieces[(rx + chk[0] * i) + &#39;-&#39; + (ry + chk[1] * i)] == piece) { num++ } else { for (i = -1; i &gt;= -4; i--) { if (pieces[(rx + chk[0] * i) + &#39;-&#39; + (ry + chk[1] * i)] == piece) { num++ } } break } } if (num == successNum) { status = false resultEl.innerHTML = [&#39;白&#39;, &#39;黑&#39;][user] + &#39;方赢&#39;; break; } } }) 然后就完事了 但是现在还有很多逻辑问题没有解决，游戏结束之后限制不可继续落子，点击位置如果已经有过落子则不可继续落子等这些就当作业留给你吧，其实不难，好好考虑考虑吧 我最终的实现效果如下","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"手动实现简易Vuex","slug":"技术/vuex简单实现","date":"2021-04-18T04:23:33.925Z","updated":"2021-04-19T12:38:28.957Z","comments":true,"path":"2021/04/18/技术/vuex简单实现/","link":"","permalink":"https://easyremember.cn/2021/04/18/技术/vuex简单实现/","excerpt":"","text":"同样，这一次我们只讲原理，如果你还不会Vuex的使用，简易移步官网 任务分析先来根据Vuex的流程图来看一下我们需要做什么 vuex也是一个插件 实现四个东西：state/mutations/actions/getters 创建Store 数据响应式 插件关于插件这里同样不多说，不会的请移步官网，这里依旧贴一张图 在安装插件时，通过Vue.use触发插件的install方法 function install(_Vue) { Vue = _Vue Vue.mixin({ beforeCreate() { // 只有根元素才有store if (this.$options.store) { Vue.prototype.$store = this.$options.store } } }) } 这里注意只有第一次调用时才给元素添加store，也就是根节点 四个核心首先要有一个可实例化的Store类，这点官网给的实例可以看出来 那我们就先创建一个Store类，它接收一个配置对象 class Store { constructor(options) { this.state = new Vue({ data() { return { ...options.state} } }) this.mutations = options.mutations this.actions = options.actions options.getters &amp;&amp; this.handleGetters(options.getters) } } state负责存储数据，借用Vue实例来实现响应式；mutations用来存储改变state的方法；actions用来存储异步方法，这里注意actions本身并不具备异步特性，仅作为异步方法的容器，他可以调用mutations中的方法；getters可以用来读取state的内容，将结果处理返回 class Store { constructor(options) { this.state = new Vue({ data() { return { ...options.state} } }) this.mutations = options.mutations this.actions = options.actions options.getters &amp;&amp; this.handleGetters(options.getters) } commit = (type, args) =&gt; { this.mutations[type](this.state, args) } dispatch = (type, args) =&gt; { this.actions[type]({ commit: this.commit, state: this.state }, args) } handleGetters(getters) { this.getters = {} Object.keys(getters).forEach(key =&gt; { Object.defineProperty(this.getters, key, { get: () =&gt; { return getters[key](this.state) } }) }) } } 测试现在我们已经实现了一个简易版的Vuex，我们接下来进行一下测试 新建一个store.js，用来实例化store Vue.use(Vuex) export default new Vuex.Store({ state: { count: 0 }, mutations: { add(state) { state.count++ } }, actions: { addAsync({ commit }) { setTimeout(() =&gt; { commit(&#39;add&#39;) }, 1000) } }, getters: { getCount(state) { return state.count } } }) 在main.js中引入store import store from &#39;./store&#39; new Vue({ store, router, render: h =&gt; h(App), }).$mount(&#39;#app&#39;) 编写Vue组件，调用Vuex方法 &lt;div&gt; {{$store.getters.getCount}} &lt;br /&gt; &lt;button @click=&quot;$store.commit(&#39;add&#39;)&quot;&gt;同步+1&lt;/button&gt; &lt;button @click=&quot;$store.dispatch(&#39;addAsync&#39;)&quot;&gt;延时+1&lt;/button&gt; &lt;/div&gt; 测试结果如下","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"vue-router实现原理","slug":"技术/vue-router简单实现","date":"2021-04-18T02:13:36.328Z","updated":"2021-04-18T04:11:43.989Z","comments":true,"path":"2021/04/18/技术/vue-router简单实现/","link":"","permalink":"https://easyremember.cn/2021/04/18/技术/vue-router简单实现/","excerpt":"","text":"本篇只说原理，不说使用，如果不会使用请移步官网文档 任务分析在实现之前我们来分析一下需要做的处理是什么，有了大纲才能轻松完成任务 首先vue-router是一个插件 其次可以监听路由变化 然后就是路由配置解析，说白了就是根据路由匹配组件 还要有全局组件router-link、router-view 插件开发插件的说明在官网也有明确说明，如果你还不知道，我还是推荐你去看一下官网文档的插件部分，如果你实在不想去看文档，那就帮你贴张图吧 Vue在使用插件的使用通过Vue.use()来使用插件，会调用插件的install方法，那么我们首选来实现这个install方法 class VueRouter { init() {} } VueRouter.install = function (Vue) { // 混入，会和vue的生命周期一起执行 Vue.mixin({ beforeCreate() { // 指向vue实例，根组件执行一次 if (this.$options.router) { Vue.prototype.$router = this.$options.router this.$options.router.init() } }, }) } Vue.use(VueRouter) init负责初始化插件，那么现在整体框架已经OK了，在开始的任务大纲里面列出的其他任务就可以方法这里了 class VueRouter { constructor(options) { this.$options = options this.routeMap = {} // 利用Vue实现双向绑定 this.app = new Vue({ data() { return { current: &#39;/&#39; } } }) } init() { this.bindEvents() this.createRouteMap() this.initComponents() } bindEvents() { } createRouteMap() { } initComponents() { } } 这里利用了Vue来实现路由地址的响应式，这也是为什么vue-router只能用在Vue里面的原因 监听路由变化监听路由变化的过程十分简单，只需要添加一个事件监听器即可 bindEvents() { // 如果不显示绑定this就会指向window window.addEventListener(&#39;load&#39;, this.onHashChange.bind(this)) window.addEventListener(&#39;hashchange&#39;, this.onHashChange.bind(this)) } onHashChange() { this.app.current = window.location.hash.slice(1) || &#39;/&#39; } 上面的slice是为了去除# 配置路由解析路由解析的目标就是我们在使用vue-router的时候配置的路由配置文件，如下 new VueRouter ({ routes: [ { path: &#39;/&#39;, component: Home }, { path: &#39;/about&#39;, component: About }, ] }) 那么这里要做的事就是将路由配置中的path和component关联起来 createRouteMap(options) { options.routes.forEach(item =&gt; { this.routeMap[item.path] = item.component }) } 实现全局组件这里可以利用Vue的API——Vue.component router-link 回忆一下我们要怎么使用这个组件，&lt;router-link to=&quot;/link&quot;&gt;跳转&lt;/router-link&gt;，那么我们需要接收一个to属性，然后这个组件会被渲染为a标签 initComponents() { Vue.component(&#39;router-link&#39;, { props: { to: String }, render(h) { return h(&#39;a&#39;, {attrs: {href: &quot;#&quot; + this.to}}, [this.$slots.default]) } }) } 这里将to拼接为a标签的href属性，然后将内容通过slot传递 router-viewrouter-view的功能就是渲染，从缓存的路由配置中拿出并渲染匹配当前路由组件 initComponents() { // ··· Vue.component(&#39;router-view&#39;, { render: (h) =&gt; { const component = this.routeMap[this.app.current] return h(component) } }) } 这里注意细节render跟上面link中的形式发生了一些变化，改用了箭头函数，因为这里用到的this，如果不使用箭头函数this指向就会改变 测试现在已经完成了上面的内容，我们来测试一下 在根组件中编写代码 &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 在main.js中 引入路由文件并且添加到Vue实例参数中 import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; import router from &#39;./myRouter&#39; new Vue({ router, render: h =&gt; h(App), }).$mount(&#39;#app&#39;) 效果如下 到现在我们已经实现了hash模式下的vue-router，当然vue-router还有很多内置的API我们不一一讲解，vue-router还有history模式，如果你感兴趣，可以去研究一下 最后贴一份完整代码 import Vue from &#39;vue&#39; import Home from &#39;./views/Home&#39;; import About from &#39;./views/About&#39; class VueRouter { constructor(options) { this.$options = options this.routeMap = {} // 利用Vue实现双向绑定 this.app = new Vue({ data() { return { current: &#39;/&#39; } } }) } init() { this.bindEvents() this.createRouteMap(this.$options) this.initComponents() } bindEvents() { // 如果不显示绑定this就会指向window window.addEventListener(&#39;load&#39;, this.onHashChange.bind(this)) window.addEventListener(&#39;hashchange&#39;, this.onHashChange.bind(this)) } onHashChange() { this.app.current = window.location.hash.slice(1) || &#39;/&#39; } createRouteMap(options) { options.routes.forEach(item =&gt; { this.routeMap[item.path] = item.component }) } initComponents() { Vue.component(&#39;router-link&#39;, { props: { to: String }, render(h) { return h(&#39;a&#39;, {attrs: {href: &quot;#&quot; + this.to}}, [this.$slots.default]) } }) Vue.component(&#39;router-view&#39;, { render: (h) =&gt; { const component = this.routeMap[this.app.current] return h(component) } }) } } VueRouter.install = function (Vue) { // 混入，会和vue的生命周期一起执行 Vue.mixin({ beforeCreate() { // 指向vue实例，根组件执行一次 if (this.$options.router) { Vue.prototype.$router = this.$options.router this.$options.router.init() } }, }) } Vue.use(VueRouter) export default new VueRouter ({ routes: [ { path: &#39;/&#39;, component: Home }, { path: &#39;/about&#39;, component: About }, ] })","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"前端性能优化","slug":"技术/前端性能优化","date":"2021-04-17T03:41:53.952Z","updated":"2021-04-18T14:43:59.882Z","comments":true,"path":"2021/04/17/技术/前端性能优化/","link":"","permalink":"https://easyremember.cn/2021/04/17/技术/前端性能优化/","excerpt":"","text":"铺垫移动互联网时代，用户对于网页的打开速度要求越来越高。首屏作为直面用户的第一屏，其重要性不言而喻。优化用户体验更是我们前端开发非常需要 focus 的东西之一。 一个快速响应的网站可以更好地留住用户，试想一下如果你打开一个网站，过了几十秒网站仍然没有加载完成，你是否还会有耐心去等待？ 那这样的话该怎么去提升我们网站的打开速度呢？首先我们要知道打开网站的过程中究竟是什么地方比较耗时，才能更好地去优化，这一节我们主要分析加载网页的过程，也就是前端经典面试题——从输入URL到页面渲染经历了什么。 问题根源从输入URL到页面渲染经历了什么？这个问题在前端面试中已经被问“烂了”，可能还有部分小伙伴不熟悉这个问题，我们今天就来回顾一下这个问题 输入网址 DNS查询 建立TCP连接 浏览器向服务器发送HTTP请求 服务器处理请求 关闭TCP连接 浏览器解析资源 页面渲染 一个网页加载的过程大致就是这些，其中需要我们前端工作者去优化的部分已经加粗标注了，下面我们来说详细或一下这几个过程 DNS查询这个过程其实就是根据域名查询主机地址的过程，主机的标识地址都是通过IP地址来区分的，但是这个IP对于常人来说很难记忆，于是就有了域名这个东西，一般来说域名都是跟网站内容相关的方便记忆的英文单词或者单词组合，但是我们要访问主机还是通过IP来访问，这个过程浏览器会自动帮助我们完成。 这个查询的过程大致如下： 首先浏览器解析输入的域名，先查找本地硬盘的host文件，看有没有和这个域名对应的ip，如果有，就直接使用这个ip。 如果没有，浏览器会发出一个DNS请求到本地DNS(域名分布系统)服务器.本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。 请求到达DNS服务器后，DNS服务器首先会查询他的缓存记录，如果有对应的ip地址，则返回，如果没有，本地DNS服务器向DNS根服务器发送查询请求。 根服务器不会记录具体的域名和ip的对应关系，而是返回域服务器的地址.本地服务器会继续向域服务器发起请求。 域服务器并没有记录域名和ip的对应关系，而是返回你的域名的解析服务器的地址. 本地DNS服务器继续向域名解析服务器发出请求，这时会收到域名对应的ip，本地DNS服务器将ip返回给浏览器，并将ip存入缓存，方便下次访问，加快访问速度。 其实这个过程的有话不需要我们自己动手，浏览器或者运行商已经通过缓存手段帮助我们完成了优化 HTTP请求现在大多的网络请求都基于HTTP协议完成，他是一个基于TCP的应用层协议。 在 HTTP 请求阶段，最大的瓶颈点来源于请求阻塞。所谓请求阻塞，就是浏览器为保证访问速度，会默认对同一域下的资源保持一定的连接数，请求过多就会进行阻塞，一般是 6 个。所以减少HTTP请求或者使用内容分发网络（CDN）是优化方向。 其次，HTTP资源传输也需要消耗时间，时长和资源大小成正比，缩小资源体积也是一个优化方向。 再就是将不重要的且短时间不会改动的静态资源缓存下来也是一个方向 解析&amp;渲染最后一步发生在浏览器，浏览器将从服务器获取到的HTML、CSS、JS等文件进行解析然后渲染页面。 首先会并行解析HTML文档和CSS样式，分别生成产物DOM和CSSOM，然后将二者融合生成渲染树，最后绘制渲染树生成页面，这个过程中不会有JS脚本参与，只要有HTML和CSS就可以完成，但是遇到script标签就会被阻塞，因为JS可以改变HTML和CSS，因此非必要情况下不要在过程中添加script脚本，可以将script标签放到文档内容的最后或者使用 defer 和 async，告诉浏览器在等待脚本下载期间不阻止解析过程。 页面渲染完成之后的界面布局如果发生了改变就会触发回流和重绘，回流的代价要高于重绘，当然这两个都不是善茬，尽量不要去招惹他们 本节内容我们大体讲解了可以进行优化的点，后面我们将从不同的维度去进行性能优化 网络上一节介绍了网页加载过程中可优化的点，这一节我来说一下网络部分的优化。 网络部分包括了以下几个过程： DNS查询 建立TCP连接 发送HTTP请求 这几点中DNS和TCP方面我们其实是无从下手的，所以我们只能咋HTTP上动刀子了。HTTP是一个往返的过程，浏览器发送请求和接收响应。 请求在请求层面，上一节我们也说到了请求环节的优化，那就是减少HTTP请求，因为网络请求是整个过程中最不确定的因素，它受环境的影响最为直观。那么具体该从哪些方面减少，比如： 每一个图片、样式……加载都会发送HTTP请求，所以可以将图片转为base64，现在前端开发一般都是使用打包工具来进行的工程化开发，打包工具一般会提供图片转base64的插件；合并小图标到css sprites (CSS精灵图)等，将小图标放置到一个文件，只需要一次加载，然后从这一张图片的位置去裁切，但是不要盲目合并导致文件过大，那样同样可能会影响体验 过多的样式文件和脚本文件也会增加HTTP的压力，所以适当的将脚本和样式进行合并，但是不要盲目合并，盲目合并导致文件过大同样会影响加载速度 少用location.reload()来刷新页面，每重新加载一次都会重新去请求资源 响应在响应方面可以做的优化其实很简单，减小响应资源的体积——使用gzip压缩，启用gzip压缩也很简单，只需要在请求头中加入accept-encoding:gzip。HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程。 gzip可以帮我们压缩大约70%体积，但是他并不是万能的，他也是有代价的，开启gzip需要浪费服务器的计算资源，服务器的 CPU 性能不是无限的，如果存在大量的压缩需求，服务器也扛不住的，这时候就会得不偿失 HTTP缓存HTTP缓存是一个减少加载时间的最有效地方法，HTTP缓存有强缓存和协商缓存两种形式。 强缓存使用Expires 和 Cache-Control 两个字段来控制，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。 来看一个使用了强缓存的响应，可以看到它使用了cache-control，最大有效时间31536000，换算过来借接近一年，也就是说在未来一年中都不需要再去请求这个资源 协商缓存顾名思义就是浏览器和服务器共同协商的结果，当请求资源的时候浏览器会询问服务器资源是否过期，如果过期就重新加载资源，如果没有过期就直接使用缓存资源，协商缓存常用的字段有ETag/If-None-Match、Last-Modified/If-Modified-Since等 使用协商缓存之后HTTP状态码会变为304 关于强缓存和协商缓存可以看我之前的这篇文章 内容分发网络CDN现在CDN已经是一种很廉价的资源了，各大云服务商都提供了自己的CDN服务，价格也很便宜，CDN通过判断用户的地理位置来选择请求距离最近的一台服务器，来减少资源传输的距离，从而减少响应的时间 CDN的核心在于缓存和回源，CDN服务器会缓存根服务器的资源文件；回源是CDN服务器去向根服务器请求资源的过程，一般发生在资源缓存过期。 静态资源加载速度始终是前端性能的一个非常关键的指标，因为静态资源的请求量一般比较大，而且体积较大，放置到CDN上可以减轻应用服务器的压力，应用服务器就可以专心处理业务而不用分心来响应静态资源。一般放置在CDN上的都是些静态文件，比如图片、样式文件等 懒加载懒加载可以将不重要的图片文件在需要时加载，优先将网页的整体框架加载出来，当用户需要浏览图片时再去请求。此外可以在用户等待页面加载的过程中使用骨架屏来优化用户的体验，比如掘金的文章详情页就使用了骨架屏 存储上一讲我们说到了HTTP缓存，这一讲的缓存并不单单指HTTP缓存 资源缓存浏览器提供了多种缓存方式 Memory Cache（内存） Service Worker Cache HTTP Cache Push Cache Memory Cache，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持Memory Cache。在刷新页面时就会使用内存缓存，如图，第一次打开网页时先从磁盘缓存中读取了资源 然后刷新页面，就会从内存中加载资源 内存缓存是“最短命”的一种缓存，在页面关闭之后缓存就会从内存中释放 service worker 是独立于当前页面的一段运行在浏览器后台进程里的脚本。它的特性将包括推送消息,背景后台同步， geofencing（地理围栏定位），拦截和处理网络请求。它可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能（一般称之为 Offline First）。前提是必须是HTTPS协议才可以，而且必须注册以后才可用 Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 本地存储打开开发者工具的应用程序选项就可以看到浏览器提供的本地存储方案 现在的网页应用基本上不是原来的网页了，现在基本都是应该叫做WebApp，webApp的成型过程中，浏览器提供的存储功能提供了清理的支持 因为HTTP是无状态的请求，所以怎么保持状态是一个问题，cookie的出现就是为了解决这个问题。Cookie 说白了就是一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。 但是cookie还是有缺陷的： 不够大，cookie的体积上限是4kB，超过4kB将会被裁剪 影响性能，cookie会被每次请求携带，无形之中增加了请求的体积，如果请求次数太多将会增加很多没有必要的传输 为了解决cookie的缺陷，web stroage出现了，web stroage有两种形式，localStroage和sessionStroage。它们二者的不同是sessionStroage生命周期是会话级，localStroage是持久化；作用域方面，localStroage只要是在同源下都可以访问，而sessionStroage只在当前窗口生效，再打开另一个窗口无法共享，通过a标签的target =“_blank”属性打开新窗口时可以共享sessionStroage 渲染前面介绍多个前端性能优化的点，现在我们来说一下性能优化的最后一关——页面渲染 浏览器渲染的过程我们之前也稍微提过，这里再说一下 解析 HTML 文件，构建 DOM 树，同时浏览器主进程负责下载 CSS 文件 CSS 文件下载完成，解析 CSS 文件成树形的数据结构，然后结合 DOM 树合并成 RenderObject 树 布局 RenderObject 树 （Layout/reflow），负责 RenderObject 树中的元素的尺寸，位置等计算 绘制 RenderObject 树 （paint），绘制页面的像素信息 浏览器主进程将默认的图层和复合图层交给 GPU 进程，GPU 进程再将各个图层合成（composite），最后显示出页面 重绘（Repaint）当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 回流（Reflow）当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的 DOM 元素 激活 CSS 伪类（例如:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法，因为这些API需要实时获取，所以会触发回流clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftscrollIntoView()、scrollIntoViewIfNeeded()、getComputedStyle()、getBoundingClientRect()、scrollTo() 回流比重绘的代价要更高。有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 或者我们可以通过“离线操作”的方式来操作DOM let container = document.getElementById(&#39;container&#39;) container.style.display = &#39;none&#39; container.style.width = &#39;100px&#39; container.style.height = &#39;200px&#39; container.style.border = &#39;10px solid red&#39; container.style.color = &#39;red&#39; ...（省略了许多类似的后续操作） container.style.display = &#39;block&#39; 再有就是css选择器，css选择器每一次遍历都的过程是非常消耗性能的，应该减小那些没有必要的选择器堆叠，比如#container li{}虽然看起来搜索范围很小，从具体的id选择器中找li元素，但是实际上在选择元素时是从右向左寻找的，会先找所有的li，然后再找#container下面的，不如直接设置类选择器。 JS 引擎是独立于渲染引擎存在的，我们在第一节也说过，当HTML文档中引入script脚本时会阻塞浏览器解析DOM和CSSOM，脚本执行完成之后才会继续解析，对此我们可已使用异步defer或者async脚本 &lt;script async src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt; async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行，defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始执行。 服务端渲染服务端渲染是在服务端将首屏的HTML文档渲染好之后在发送给客户端，解决了客户端加载首屏过长的问题，我们现在绝大多数的webApp都是客户端渲染，HTML文档中只有一个根节点，往往是这个样子的 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; 只有一个根节点，根据后期的js运行来渲染页面内容，这就需要等待js全部加载完成才能开始渲染，这就导致了首屏时间过长，所以出现了服务端渲染的技术来解决首屏加载时间长的问题，服务端渲染并不是javaweb那种每切换一次网页都在服务端获取一次HTML，而是通过第一册请求的url将首屏的HTML文档直接填充内容，客户端在获取资源之后直接渲染就是了，之后切换路由也不需要再去请求HTML文件，只需要ajax交互就行了 具体的实现细节可以看我之前的SSR实现 服务端渲染固然能带来用户体验的提升，但是牺牲的同样是服务器的计算资源，服务端渲染本质上是本该浏览器做的事情，分担给服务器去做，当服务器顶不住压力时，这又是一波“反向优化”","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"大前端","slug":"大前端","permalink":"https://easyremember.cn/tags/大前端/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"JavaScript核心原理","slug":"技术/JavaScript核心原理","date":"2021-04-08T11:16:28.327Z","updated":"2021-04-08T11:17:50.383Z","comments":true,"path":"2021/04/08/技术/JavaScript核心原理/","link":"","permalink":"https://easyremember.cn/2021/04/08/技术/JavaScript核心原理/","excerpt":"","text":"typeof利用typeof判定类型的取值范围是：’undefined’ /‘boolean’ /‘string’ /‘number’ /‘object’ /‘function’ /‘symbol’ 在JavaScript内部使用typeof判断类型依据的是二进制，根据变量的机器码低位1-3位存储其类型信息，有如下规则： 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 这里就引出了JavaScript的经典bug typeof null === &#39;object&#39; // true 因为null的机器码为全0，那自然前三位也是0，所以这里会误判null的类型为object instanceofinstanceof用来判断实例是否属于某种类型，或者实例的祖先属不属于某种类型，翻译一下就是只要右边变量的 prototype 在左边变量的原型链上即可，大致过程如下 function intanceofSelf(son, parent) { if(son === null || parent === null) { return false } let proto = son.__proto__ while(1) { if(proto === parent.prototype) { return true } if(proto === null) { return false } proto = proto.__proto__ } } console.log(intanceofSelf([], Array)); console.log([] instanceof Array); 执行结果如下 贴一张图来回忆一下原型 new new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 来看一下真正的new操作之后是什么效果 我们班来简单梳理一下new操作符所做的事情： 创建一个对象 将构造函数的原型挂载到新对象上 执行构造函数 返回新对象 大体功能已经分析出来了，开始代码实现，由于我们无法实现关键字的形式，我们就以工厂函数的形式来实现new操作 function createNewObj(constructor) { const args = Array.prototype.slice.call(arguments, 1) const obj = {} obj.__proto__ = constructor.prototype constructor.apply(obj, args) return obj } function Person(name, age) { this.name = name this.age = age } Person.prototype.getAge = function () { return this.age } let p = createNewObj(Person, &#39;king&#39;, 17) console.log(p) 来看一下执行结果，与原生new的效果相同，大功告成 callcall是再Function原型上的方法，它的作用是改变函数执行时的this指向，也就是this绑定规则中的显示绑定 先来看一下使用示例，理解了使用方法才能去实现它 var foo = { value: 1 }; function bar() { console.log(this.value); } bar.call(foo); // 1 实现思路： 将调用方法添加到指定的this上 执行方法 删除指定this上的方法 PS：这里注意call的this指向可以传null，当传值是null的时候，this指向window对象 Function.prototype.callSelf = function(ctx) { ctx = ctx || window const args = Array.from(arguments) args.shift() ctx.fun = this ctx.fun(...args) delete ctx.fun } const bar = { age: 18 } var age = 17 function foo(name) { console.log(name) console.log(this.age) } foo.callSelf(bar, &#39;张三&#39;) foo.callSelf(null, &#39;张三&#39;) foo(&#39;张三&#39;) 来看一下运行结果（不可以在node环境运行，node环境没有window） 可以看到传值为null的时候也实现了绑定为window PS：这只是原理上实现，call在ES3就已经实现了，我在代码中使用了多个ES6的方法 applyapply的作用于call一样，唯一的区别在于二者接收的参数，call的参数是this指向+函数参数，apply的参数是this指向+函数参数组成的数组，如foo.call(bar, arg1, arg2)和foo.apply(bar, [arg1, arg2]) 那么这里也不再细说apply的原理了，直接上代码 Function.prototype.applySelf = function(ctx, args) { ctx = ctx || window ctx.fun = this ctx.fun(...args) delete ctx.fun } const bar = { age: 18 } var age = 17 function foo(name) { console.log(name) console.log(this.age) } foo.applySelf(bar, [&#39;张三&#39;]) foo.applySelf(null, [&#39;张三&#39;]) foo(&#39;张三&#39;) 运行结果 bindbind与apply和call作用大抵相同，区别在于bind返回的是一个可执行函数，看一下MDN上bind的介绍 bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 那也就是说，bind不再只是this指向的改变，而且要兼顾原型等因素，我们一步一步来 先来实现返回指定this的函数 Function.prototype.bindSelf = function (ctx) { var _this = this return function () { return _this.apply(ctx) } } var bar = { age: 18 } var age = 19 function foo() { console.log(this.age) } const f = foo.bindSelf(bar) f() foo() 不要忘了还可以接受参数，这里不再是简单的参数展开，他还可以分批传入（柯里化），如下 当然，也不需要太过担心，其实实现也很简单，从两个函数作用域的arguments中提取即可 Function.prototype.bindSelf = function(ctx) { var _this = this var args = Array.prototype.slice.call(arguments, 1) return function() { _this.apply(ctx, args.concat(Array.from(arguments))) } } var bar = { value: 1 } function foo(name, age) { console.log(name) console.log(age) console.log(this.value) } const f = foo.bindSelf(bar, &#39;king&#39;) f(18) 传参的问题解决了，接下来就是最头疼的构造器效果了，我们先来new一下试试，看看缺了什么 const f = foo.bindSelf(bar, &#39;king&#39;) const o = new f(17) console.log(o) // 17 // 1 // {} const f2 = foo.bind(bar, &#39;king&#39;) const o2 = new f2(17) console.log(o2) // 17 // undefined // foo {} // foo的实例对象 如果你从上面看下来你会知道在执行new操作符的时候会将this指向要创建出来的对象实例，所以原生bind返回的函数在实例化时会找不到value，而我们自定义的bind在执行new操作符的时候this仍然指向bar对象，而且实例的原型链也有问题，所以会分析不出对象实例的类型 知道了问题所在我们就开始继续优化 Function.prototype.bindSelf = function(ctx) { var _this = this console.log(_this); var args = Array.prototype.slice.call(arguments, 1) var midFun = function() { _this.apply(this instanceof midFun ? this : ctx, args.concat(Array.from(arguments))) } midFun.prototype = this.prototype return midFun } 这里我们通过instanceof来判断当前操作是new还是作为普通函数执行。当执行new操作时，this指向对象实例，instanceof的结果为true，保持this指向对象实例；否则就是作为普通函数执行，this指向一开始传进来的上下文。这一段要好好消化一下，比较绕。 再来执行上面的测试数据，大功告成","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"HTTP 强缓存和协商缓存","slug":"技术/HTTP 强缓存和协商缓存","date":"2021-04-04T02:28:13.854Z","updated":"2021-04-04T02:41:02.125Z","comments":true,"path":"2021/04/04/技术/HTTP 强缓存和协商缓存/","link":"","permalink":"https://easyremember.cn/2021/04/04/技术/HTTP 强缓存和协商缓存/","excerpt":"","text":"这里我们说的缓存主要是指HTTP请求得到的静态资源（img/css/js），使用HTTP缓存的好处是可以减少请求时间，节省带宽流量，减少服务器压力并且提升用户体验，当然并没有绝对完美的东西，HTTP缓存也存在他的缺陷，可能会造成数据不一致，占用内存等 我们将缓存分为强缓存和协商缓存，两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。 这是缓存运作的一个整体流程图：图片来自HTTP缓存 强缓存强缓存主要有两种Cache-Control和Expires Cache-ControlCache-Control是在http1.1中出现的，，Cache-Control有如设置： max-age：它是一个相对时间，表示缓存的有效时间 no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 ExpiresExpires是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。这个时间代表这这个资源的失效时间，只要发送请求时间是在Expires之前，那么本地缓存始终有效，则在缓存中读取数据。 cache-control:max-age=3600 expires:Fri Apr 02 2021 13:52:41 GMT Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。上面这段配置中，就会按照max-age来使用缓存 协商缓存ETag/If-None-MatchETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。 Last-Modified/If-Modified-SinceLast-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。 ETag作用Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://easyremember.cn/tags/计算机网络/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"react生命周期","slug":"技术/react生命周期","date":"2021-03-17T13:20:01.085Z","updated":"2021-03-17T13:21:01.082Z","comments":true,"path":"2021/03/17/技术/react生命周期/","link":"","permalink":"https://easyremember.cn/2021/03/17/技术/react生命周期/","excerpt":"","text":"先来看一下官网的生命周期图谱 这是只有常用生命周期的图谱 这是带有不常用生命周期的图谱 注意：我们所说的生命周期只存在于类组件中，函数组件中是没有生命周期的概念的 react的生命周期大致分为三个部分：挂载、更新、卸载，下面来看一下每个部分都有哪些生命周期 挂载时 static getDerivedStateFromProps()：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 UNSAFE_componentWillMount：弃用；组件挂载前执行 componentDidMount：组件挂载之后执行，可以在这里进行网络请求，此时DOM元素已经生成 更新时 static getDerivedStateFromProps()：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 shouldComponentUpdate()：根据的返回值，判断组件的输出是否受当前 state 或 props 更改的影响，返回true则组件更新，返回false组件不更新。这里是性能优化的关键之处，如果不在这里处理组件默认是更新的，父组件更新之后，不论子组件是否发生变化都会重新渲染。 getSnapshotBeforeUpdate()： 在最近一次渲染输出（提交到 DOM 节点）之前调用，此生命周期的任何返回值将作为参数传递给 componentDidUpdate() componentDidUpdate()：更新后会被立即调用。首次渲染不会执行此方法。 UNSAFE_componentWillUpdate：弃用；在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。 UNSAFE_componentWillReceiveProps：弃用；会在已挂载的组件接收新的 props 之前被调用 卸载时 componentWillUnmount()：会在组件卸载及销毁之前直接调用，可以在此生命周期解除定时器、监听等 参考：React中文文档，React.component","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://easyremember.cn/tags/react/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"require.context实现自动化导入","slug":"技术/require.context实现自动化导入","date":"2021-03-15T10:47:32.766Z","updated":"2021-03-15T10:54:28.098Z","comments":true,"path":"2021/03/15/技术/require.context实现自动化导入/","link":"","permalink":"https://easyremember.cn/2021/03/15/技术/require.context实现自动化导入/","excerpt":"","text":"API描述先看一眼官网文档 require.context( (directory: String), (includeSubdirs: Boolean) /* 可选的，默认值是 true */, (filter: RegExp) /* 可选的，默认值是 /^\\.\\/.*$/，所有文件 */, (mode: String) /* 可选的， &#39;sync&#39; | &#39;eager&#39; | &#39;weak&#39; | &#39;lazy&#39; | &#39;lazy-once&#39;，默认值是 &#39;sync&#39; */ ) require.context()方法一共可以接收4个参数： directory：要加载的目录 includeSubdirs：是否遍历子目录 filter：要加载的文件正则匹配 mode：模式，见文档 文件目录如图 require.context()的返回值是一个方法，并且该方法具有三个属性，id、keys、resolve 从图中可以看出，id属性的值是由相对路径、模式、以及正则组成的一个字符串，keys和resolve属性都是方法，分别来执行一下 keys方法返回的是匹配到的文件名组成的数组，从上面截图可以看到resolve方法需要接受一个参数，我们再来调用一下resolve console.log(&#39;resolve:&#39;, modulesFile.resolve(modulesFile.keys()[0])); console.log(&#39;resolve:&#39;, modulesFile.resolve(&#39;a&#39;)); 可以看出resolve的结果是keys中返回结果的某一项的相对路径，并且，参数必须包含在keys返回结果的数组中，否则报错 前面说到，require.context()返回值的本身也是一个方法也需要接收一个参数，根据上面的req参数推断，这个参数也要在keys返回值的结果之中，再来执行下 这里可以看出，执行的结果是一个Module实例（使用.default获取值），因为我在a.js中使用ES6 Module导出的，所以这里是一个模块的引用，如果这里我更换为CommonJS的的导出 // export default { // from: &#39;a.js&#39; // } module.exports = { from: &#39;a.js&#39; } 结果就会变成值的拷贝 应用应用场景大多是在导入同一文件夹下的多个文件，举一个简单的例子：Vuex分模块引入时，可以通过require.context来动态引入模块，只需要编写一次代码，不再需要后期过多得维护 const modulesFiles = require.context(&#39;./modules&#39;, false, /\\.js$/) const modules = modulesFiles.keys().reduce((modulesTemp, currentPath) =&gt; { // 从文件名中去除文件后缀，如./a.js =&gt; a const temp = modulesTemp const moduleName = currentPath.replace(/^\\.\\/(.*)\\.\\w+$/, &#39;$1&#39;) const value = modulesFiles(currentPath) temp[moduleName] = value.default return temp }, {}) store = new Vuex.Store({ modules }) export default store","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"TypeScript高级使用","slug":"笔记/TypeScript高级","date":"2021-02-20T01:00:21.569Z","updated":"2021-02-22T12:10:01.993Z","comments":true,"path":"2021/02/20/笔记/TypeScript高级/","link":"","permalink":"https://easyremember.cn/2021/02/20/笔记/TypeScript高级/","excerpt":"","text":"在之前有过一篇TypeScript的入门笔记，介绍了TS最基本的用法，现在来进阶一下 深入TS类型联合类型使用|操作符将变量可能出现的数值类型连接起来，就是联合类型 function css(ele: Element, attr: string, value: string | number) { // value参数的类型只能是string或者number // ...... } 交叉类型使用&amp;操作符将多种类型合并在一起，形成一种新的类型 type t1 = { name: string, age: number } type t2 = { sex: string } type t3 = t1 &amp; t2 function sayHi(person: t3) { console.log(`${person.name}今年${person.age}岁，性别：${person.sex}`) } let king = { name: &#39;king&#39;, age: 12, sex: &#39;man&#39; } let ali = { name: &#39;king&#39;, sex: &#39;woman&#39; } sayHi(king) sayHi(ali) // 报错 这里t1和t2两个类型通过交叉合并为一种类型，要求必须含有三个属性并且符合数据类型限定，上面的代码中最后一行会抛出错误，因为变量ali不满足t3类型的要求 这里需要说一下interface和type，都可以描述一个对象或者函数，interface用来定义接口，type定义类型，二者并不是互相独立的。 这里说一下二者的区别： type可以直接通过运算获得新类型，而interface需要使用extends操作符来生成新的接口。 type 语句中还可以使用 typeof 获取实例的类型进行赋值 interface 能够声明合并，多个同名interface声明的类型会被合并到同一接口 从图中可以看到interface也可以来继承type，并且实现相同功能 字面量类型TS类型限定除了基本数据类型限定之外还可以进行具体值的限定 type t1 = { name: string, sex: &#39;man&#39; | &#39;woman&#39; } let person: t1 = { name: &#39;张三&#39;, sex: &#39;middle&#39; // 报错 } 如上，使用字符串限定之后sex的值之能是man或者woman。除了字符串以外，其他的基本数据类型也都可以限制 类型别名可以使用type操作符对任意类型获取组合类型起别名 类型推导每次都显式标注类型太麻烦，TS提供了一种方便的特性——类型推导。根据上下文自动推导出对应的类型标注，过程发生在： 初始化变量 设置函数默认参数 返回函数值 类型断言有的时候我们需要一个更精确的标注，比如使用document.querySelector方法获得的结果，TS会根据参数判断返回值的类型。如果是一个图片，他有src属性，而如果是一个div，他就没有src属性。 但是TS并不会知道我们使用了类选择器之后的结果，我们需要提前告知 let ele = &lt;HTMLImageElement&gt;document.querySelector(&#39;.box&#39;) // 或者 let ele2 = document.querySelector(&#39;.box&#39;) as HTMLImageElement 断言也可以联合类型参数带来的问题吗，如果参数是联合类型，比如string | string[]，参数有可能是数组也有可能是字符串，那么无法判断参数是否具有某一方法，这时候就可以使用类型断言来调用方法 类型保护上面说的联合类型参数带来的问题也可已通过类型保护来解决 function fun(str: string | string[]) { if (typeof str === &#39;string&#39;) { str.split(&#39;&#39;) } else { // 当其他类型都在if中罗列之后，剩余的一种在else中生效 str.push() } } intanceof也可以触发类型保护 类型操作符keyof可以获取类型的键名组成的联合类型，主要用途是key的合法化 type Person = { name: string; age: number; } type PersonKey = keyof Person; // PersonKey得到的类型为 &#39;name&#39; | &#39;age&#39; function getValue(p: Person, k: keyof Person) { return p[k]; } typeof获取一个对象/实例的类型，只能用在具体的对象上 in只能用在类型的定义中，可以对枚举类型进行遍历 // 这个类型可以将任何类型的键值转化成number类型 type TypeToNumber&lt;T&gt; = { [key in keyof T]: number } 泛型泛型在之前的入门中也有所涉及，但那只是皮毛中的皮毛，现在我们来深入一下泛型，基本的泛型定义不再赘述，可以去看一下TypeScript的入门笔记 泛型推导如同前面所说的类型推导一样，泛型也有推导， type Dog&lt;T&gt; = { name: string, type: T } function doSth&lt;T&gt;(dog: Dog&lt;T&gt;) { return dog.type } let dog = { name: &#39;lucky&#39;, type: &#39;pug&#39; } // 如果没有泛型推导，就需要写这么多 // let dog: Dog&lt;string&gt; = { // name: &#39;lucky&#39;, // type: &#39;pug&#39; // } doSth(dog) // 调用函数时根据type的类型自动推导出了T 类型约束有时候，我们需要限定类型，这时候使用extends关键字 function sum&lt;T extends number&gt;(value: T[]) { let count = 0 value.forEach(v =&gt; count += v) return count } 使用extends限定参数类型为数字数组，如果调用时参数出现了其他类型就会报错 还可以限制多个参数，如 function pick&lt;T, U extends keyof T&gt;(obj: T, proto: U) { console.log(obj[proto]); }; let person = { name: &#39;张三&#39;, age: 14 } pick(person, &#39;name&#39;) 第二个参数必须是第一个参数中keys的子集，否则报错 泛型推断使用infer关键字来进行泛型推断 type Per&lt;T&gt; = T extends { t: infer P } ? P : string type p = Per&lt;number&gt; // string type p1 = Per&lt;{ t: boolean }&gt; // boolean type p2 = Per&lt;{ t: number }&gt; // number 定义Per的过程也叫泛型条件，通过三目运算符控制最终分配的类型。根据传进来的泛型类型T有无t属性来确定返回的类型，并将t的属性返回 常用泛型工具PartialPartial的作用是将传入的属性变成可选项，原理就是使用keyof拿到所有属性名，然后再使用in遍历，使用?将属性设置为可选属性，其实现源码如下 type Partial&lt;T&gt; = { [P in keyof T]?: T[p] } type person = { name: string, age: number } // 使用Partial处理后没有全部属性不再报错 let a: Partial&lt;person&gt; = { name: &#39;1q23&#39; } RequiredRequired将所有的参数变为必选项；其原理是使用keyof拿到所有属性名，然后再使用in遍历，可以理解为使用-?抵消掉? type Required&lt;T&gt; = { [P in keyof T]-?: T[P] } type person = { name: string, age: number } let b: Required&lt;person&gt; = { name: &#39;king&#39;, } RecordRecord作用是将 K 中所有属性值转化为 T 类型 type Record&lt;K extends keyof any,T&gt; = { [key in K]: T } // keyof any对应的类型为number | string | symbol,就是可以做索引的类型集合 type person = { name: string, age: number } let c: Record&lt;number, string&gt; = { 1: 1, &#39;str&#39;: 123 } 这里会抛出异常，因为使用Record工具将所有的number类型为索引的属性值类型设置为string，数字索引的属性不是string就会报错 PickPick的作用是将 T 类型中的 K 键列表提取出来，生成新的子键值对类型 type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P] } type person = { name: string, age: number } let d: Pick&lt;person, &#39;name&#39;&gt; = { name: &#39;king&#39;, age: 12 // 不能将类型“{ name: string; age: number; }”分配给类型“Pick&lt;person, &quot;name&quot;&gt;”。对象文字可以只指定已知属性，并且“age”不在类型“Pick&lt;person, &quot;name&quot;&gt;”中 } 因为使用Pick工具从person类型中只选择了name属性，所以添加age属性之后会报错 ExcludeExclude的作用是去除 T 类型和 U 类型的交集，返回剩余的部分 type Exclude&lt;T, U&gt; = T extends U ? never : T type person = { name: string, age: number } type el = Exclude&lt;person | string, number | &#39;a&#39; | person&gt; // string let e: el = &#39;str&#39; OmitOmit用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对 type Omit = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt; type person = { name: string, age: number } type oi = Omit&lt;person, &#39;age&#39;&gt; let f: oi = { name: &#39;king&#39; } ReturnTypeReturnType获取 T 类型(函数)对应的返回值类型，通过使用 infer 推断返回值类型，然后返回此类型 type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any; type T0 = ReturnType&lt;() =&gt; string&gt;; // string type T1 = ReturnType&lt;(s: string) =&gt; void&gt;; // void","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"前端防抖和节流","slug":"技术/防抖和节流","date":"2021-02-16T08:31:34.714Z","updated":"2021-02-16T09:20:06.305Z","comments":true,"path":"2021/02/16/技术/防抖和节流/","link":"","permalink":"https://easyremember.cn/2021/02/16/技术/防抖和节流/","excerpt":"","text":"什么是防抖/节流 防抖(debounce)：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间；我们日常使用的百度搜索框就使用了防抖机制，只有在输入框不再输入内容一段时间之后才会弹出关键词索引 节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次；例如滑动到底部自动加载下一页，就可以通过节流来控制 区别：防抖只会在最终执行一次；而节流是每隔一段时间执行一次，起到稀释操作的作用 这里借用一张网络上的图片，前半部分节流，只会在某一时间点触发，可以看见a、b、c三个点在时间线上都是一样的；后半部分是防抖，a事件过了一段时间之后触发，b、c事件之间的间隔没有达到阈值，c事件就会覆盖b事件，最终只有c事件执行 为什么要防抖/节流事件无法控制触发频率，会不断执行事件造成性能的浪费，比如鼠标位置、页面滚动……等，使用了防抖或节流就可以有效的控制不可控事件的触发，可以优化用户体验，甚至可以缓解服务器压力 怎样实现防抖/节流防抖通过不断地重置计时器timer来实现最终只执行一次 /** * @description: 函数防抖，利用闭包返回防抖函数 * @param {*} fun 需要防抖的函数 * @param {*} wait 等待时间，默认0.5秒 * @return {*} 实际到用的防抖函数 */ function debounce(fun, wait = 500) { let timer = null return function (...args) { if (timer) { clearTimeout(timer) } timer = setTimeout(() =&gt; { fun.apply(this, args) }, wait) } } 节流通过setTimeout执行事件来调控状态位 /** * @description: 函数节流 * @param {*} fun 需要节流的函数 * @param {*} wait 等待时间，默认0.5秒 * @return {*} */ function throttle(fun, wait = 500) { let valid = true return function (...args) { if (!valid) { return false } // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false setTimeout(() =&gt; { fun.apply(this, args) valid = true }, wait) } }","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://easyremember.cn/tags/悦读/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"纯手工搭建Vue SSR","slug":"技术/纯手工搭建Vue-SSR","date":"2021-02-15T02:44:36.951Z","updated":"2021-02-15T06:21:08.765Z","comments":true,"path":"2021/02/15/技术/纯手工搭建Vue-SSR/","link":"","permalink":"https://easyremember.cn/2021/02/15/技术/纯手工搭建Vue-SSR/","excerpt":"","text":"准备工作首先创建一个vue项目 vue create ssr 既然是服务端渲染，我们需要一个服务器，这里我们选择express；此外还需要一个库vue-server-renderer npm install vue-server-renderer express -D 开始干活服务器启动脚本const express = require(&#39;express&#39;) const Vue = require(&#39;vue&#39;) const app = express() // 创建渲染器 // createRenderer()是一个工厂函数，会染回一个渲染器 const renderer = require(&#39;vue-server-renderer&#39;).createRenderer() const page = new Vue({ template: `&lt;div&gt;hello ssr&lt;/div&gt;` }) // 设置路由 app.get(&#39;/&#39;, async (req, res) =&gt; { try { const html = await renderer.renderToString(page) res.send(html) } catch (error) { res.status(500).send(&#39;服务器错错误&#39;) } }) app.listen(3000, () =&gt; { console.log(&#39;server listening port:3000&#39;); }) 通过编译器可以看见renderToString方法接收一个Vue示例作为参数，也就是上面编写的page 你可能会发现一个问题，在服务端编写路由并不是非常灵活，而且也不方便我们后续的spa，这时候我们需要将路由的控制权交给vue-router 配置vue-routerimport Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import About from &#39;../pages/About&#39; import Index from &#39;../pages/Index&#39; Vue.use(Router) // 使用工厂函数，返回一个路由的构造器，防止污染不同访问者的路由 export default function createRouter() { return new Router({ mode: &#39;history&#39;, routes: [ { path: &#39;/&#39;, component: Index }, { path: &#39;/about&#39;, component: About }, ], }) } 这里注意向外暴露的不再是一个VueRouter实例，而是一个工厂函数，因为不同的用户会发送不同的请求，如果都返回同一个实例，则会对其他用户造成影响 这里我们再来看一下构建流程 通过server-bundle构建之后的html不再只有一个根div，而是已经被渲染的html，当第一次请求结束时，又会变成一个spa，不在跟服务端有联系，而是通过ajax直接访问api服务器 编写入口总入口app.js import Vue from &#39;vue&#39; import App from &#39;./App&#39; import createRouter from &#39;./router/index&#39; export default function createApp() { const router = createRouter() const app = new Vue({ router, render: h =&gt; h(App) }) // 这里不需要挂载到根节点，因为没有根节点 return {app, router} } 服务端入口server-entry.js import createApp from &#39;./app&#39; export default context =&gt; { return new Promise((resolve, reject) =&gt; { const { app, router } = createApp() // 进入首屏 router.push(context.url) router.onReady(() =&gt; { resolve(app) }, reject) }) } 客户端入口client-entry.js // 挂载激活app import createApp from &#39;./app&#39; const { app, router } = createApp() router.onReady(() =&gt; { app.$mount(&#39;#app&#39;) }) 进行打包配置安装依赖 npm install webpack-node-externals lodash.merge cross-env -D 根目录添加vue.config.js const VueSSRServerPlugin = require(&#39;vue-server-renderer/server-plugin&#39;) const VueSSRClientPlugin = require(&#39;vue-server-renderer/client-plugin&#39;) const nodeExternals = require(&#39;webpack-node-externals&#39;) const merge = require(&#39;lodash.merge&#39;) // 决定入口是服务端还是客户端 const TARGET_NODE = process.env.WEBPACK_TARGET === &#39;node&#39; const target = TARGET_NODE ? &quot;server&quot; : &quot;client&quot; module.exports = { css: { extract: false }, outputDir: &#39;./dist&#39; + target, configureWebpack: () =&gt; ({ // 指向entry文件 entry: `./src/${target}-entry.js`, // 对bundle提供source-map支持 devtool: &#39;source-map&#39;, target: TARGET_NODE ? &#39;node&#39; : &#39;web&#39;, node: TARGET_NODE ? undefined : false, output: { libraryTarget: TARGET_NODE ? &#39;commonjs2&#39; : undefined }, externals: TARGET_NODE ? nodeExternals({ allowlist: [/\\.css$/] }) : undefined, optimization: { splitChunks: TARGET_NODE ? false : undefined, }, plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()] }), chainWebpack: config =&gt; { config.module .rule(&quot;vue&quot;) .use(&quot;vue-loader&quot;) .tap(options =&gt; { merge(options, { optimizeSSR: false }) }) } } 然后在package.json中添加脚本 &quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;build:server&quot;: &quot;vue-cli-service build&quot;, &quot;build:client&quot;: &quot;cross-env WEBPACK_TARGET=node vue-cli-service build --mode server&quot;, &quot;build&quot;: &quot;npm run build:server &amp;&amp; npm run build:client&quot; }, 打包之后再来修改服务器启动脚本 const express = require(&#39;express&#39;) const fs = require(&#39;fs&#39;) // const Vue = require(&#39;vue&#39;) const app = express() const serverBundle = require(&#39;../dist/server/vue-ssr-server-bundle.json&#39;) const clientManifest = require(&#39;../dist/client/vue-ssr-client-manifest.json&#39;) // 创建渲染器 // createRenderer()是一个工厂函数，会染回一个渲染器 const { createBundleRenderer } = require(&#39;vue-server-renderer&#39;) const renderer = createBundleRenderer(serverBundle, { runInNewContext: false, // 记得新建一个模板 template: fs.readFileSync(&#39;../public/index.temp.html&#39;, &#39;utf-8&#39;), clientManifest }) app.use(express.static(&#39;../dist/client&#39;, {index: false})) // const page = new Vue({ // template: `&lt;div&gt;hello ssr&lt;/div&gt;` // }) // 设置路由 app.get(&#39;*&#39;, async (req, res) =&gt; { try { const context = { url: req.url, title: &#39;ssr test&#39; } const html = await renderer.renderToString(context) res.send(html) } catch (error) { res.status(500).send(&#39;服务器错错误&#39;) } }) app.listen(3000, () =&gt; { console.log(&#39;server listening port:3000&#39;); }) 大功告成此时我们再启动服务器，就可以看到成果了 可以看到html文档中不再是一个app根元素了 总结SSR（server side render）解决了SEO和首屏渲染慢的问题，首屏在服务器端进渲染，等全部文件加载完之后在浏览器再激活mount实现spa 源码已经上传码云仓库","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/tags/技术/"}],"keywords":[]},{"title":"Vue2.x数据绑定原理","slug":"技术/Vue2.x数据绑定原理","date":"2021-02-14T13:25:47.791Z","updated":"2021-02-22T12:09:55.436Z","comments":true,"path":"2021/02/14/技术/Vue2.x数据绑定原理/","link":"","permalink":"https://easyremember.cn/2021/02/14/技术/Vue2.x数据绑定原理/","excerpt":"","text":"总览Vue是一款MVVM（Model-View-ViewModel）前端框架，框架帮我们实现了数据和视图的双向绑定，我们不在需要操作DOM，只需要关心数据的变化，视图就会自动改变，我们就来探究一下Vue的数据绑定原理 先来贴一张官方的数据绑定原理的介绍图，还有一段官网的介绍 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。 总体来说，就是将Vue中的data通过Observer进行数据观察，在读取数据值的时候添加订阅，在值进行修改时发布通知，告诉这个数值所有的订阅者更新数据 源码分析为了方便理解，代码中有所省略 defineReactive劫持数据众所周知，Vue2使用的是Object.defineProperty()来实现的数据劫持，defineReactive就是对Object.defineProperty()进行的一次封装 export default function defineReactive(data,key,val){ // console.log(&#39;defineReactive&#39;,data,key) if(arguments.length == 2){ val = data[key] } //子元素要进行observe，形成递归，多个函数循环调用 let childOb = observe(val) Object.defineProperty(data,key,{ //可枚举 enumerable:true, //可以被配置,比如可以被delete configurable:true, //getter get() { console.log(`打开${key}属性`) return val }, //setter set(newValue) { console.log(`改变obj的${key}属性`,newValue) if(val === newValue){ return } val = newValue childOb = observe(newValue) } }); } 将defineReactive暴露出去，再需要进行数据劫持的时候直接就可以用这个封装好的方法 Observer类开始我们说了，Vue中的data通过Observer进行数据观测才可以进行劫持，那么Observer的作用是什么呢？Observer主要负责将基本数据类型进行我们上面所定义的defineReactive数据劫持，然后区分引用类型，将对象的属性递归劫持，如果是数组，就要改写数组的方法来实现数据劫持，之后会详细介绍。 Observer使用时会在外面进行类型检测，如果不是引用类型，直接返回，只有引用类型才进行数据侦测，并将Observer实例返回 // observe.js export default function(value){ //如果value不是对象，什么都不做 if(typeof value != &#39;object&#39;) return; //定义ob var ob; // __ob__就是对象是否真测过的标识，如果数据被Observer处理过，他的属性上就会有__ob__ if(typeof value.__ob__ !== &#39;undefined&#39;){ ob = value.__ob__; }else{ ob = new Observer(value) } return ob; } // Observer.js export default class Observer { constructor(value) { //每一个Observer的实例身上，都有一个dep（下一部分会说到） this.dep = new Dep(); //给实例添加了__ob__属性，值是这个new的实例 def(value, &#39;__ob__&#39;, this, false) console.log(&#39;我是Observer构造器&#39;, value) //Observer将一个正常的object转换为每个层级的属性都是响应式(可以被侦测的)object //检查它是数组还是对象 if (Array.isArray(value)) { //如果是数组，就将这个数组的原型指向arrayMethods(后面会介绍) Object.setPrototypeOf(value, arrayMethods); //让这个数组变得observe this.observeArray(value) } else { this.walk(value) } } //遍历 walk(value) { for (let k in value) { defineReactive(value, k) } } //数组的特殊遍历 observeArray(arr) { for (let i = 0, l = arr.length; i &lt; l; i++) { observe(arr[i]) } } } 数组的响应式由于通过索引来实现绑定太过浪费性能，所以，Vue在实现数组的响应式时重写了7个数组的API（为什么是7个？Array.prototype上可以改变原数组的API只有7个，其他的不会改变原数组），只要调用了这7个API就通知视图进行更新 //得到Array.prototype const arrayPrototype = Array.prototype; //以Array.prototype为原型创建arrayMethods对象,并暴露 export const arrayMethods = Object.create(arrayPrototype); //要被改写的7个数组方法 const methodsNeedChange = [ &#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39; ] methodsNeedChange.forEach(methodName =&gt;{ //备份原来的方法 const original = arrayPrototype[methodName]; def(arrayMethods,methodName,function(){ //恢复原来的方法 const result = original.apply(this,arguments) //把类数组对象变为数组 const args = [...arguments] //把这个数组身上的__ob__取出来，__ob__已经被添加了，因为数组肯定不是最高层，比如obj.g属性是数组，obj不能是数组，第一次遍历obj这个对象的第一层的时候，已经给g属性(就是这个数组)添加了__ob__属性。 const ob = this.__ob__; // 要把插入的新项也要变为observe的 let inserted = []; switch(methodName){ case &#39;push&#39;: case &#39;unshift&#39;: inserted = args break case &#39;splice&#39;: //splice新加入的参数是从第三项开始 inserted = args.slice(2) break } //判断有没有要插入的新项,让新项也变成响应的 if(inserted){ ob.observeArray(inserted) } // 调用dep的notify方法通知更新 ob.dep.notify() return result },false) }) 依赖收集依赖收集的过程就是将watcher实例添加到Dep的队列中的过程，Dep实例存在 __ob__属性中，也就是上文Observer中的创建Dep对象实例的那一段代码。每一个Dep实例维护着一个watcher队列，当数据发生改变时，触发notify方法通知视图更新 var uid = 0; export default class Dep{ constructor(){ this.id = uid++; //用数组存储自己的订阅者。subs是subscribes订阅者的意思 this.subs = []; } //添加订阅 addSub(sub){ this.subs.push(sub) } //添加依赖 depend(){ //Dep.target我们自己指定的全局的位置，只要是全局唯一没有歧义就行 if(Dep.target){ this.addSub(Dep.target) } } //通知更新 notify(){ //浅克隆一份 const subs = this.subs.slice(); //遍历 for(let i = 0,l = subs.length;i&lt;l;i++){ subs[i].update(); } } } 这里面比较难理解的是Dep.target这一个东西，这个东西其实就是一个全局标识，如果你愿意，你也可以用window.target或者其他的变量名。了解他的作用继续看下一段 var uid = 0; export default class Watcher { constructor(target, expression, callback) { console.log(&#39;我是watcher的构造器&#39;); this.id = uid++; this.target = target; this.getter = parsePath(expression); this.callback = callback; this.value = this.get(); } update() { this.run(); } get() { //进入依赖收集阶段.让全局的Dep.target设置为Watcher本身，那么就是进入依赖收集阶段 Dep.target = this; const obj = this.target; var value; //只要能找，就一直找 try { value = this.getter(obj); } finally { Dep.target = null; } return value; } run() { this.getAndInvoke(this.callback) } getAndInvoke(cb) { const value = this.get(); if (value !== this.value || typeof value == &#39;object&#39;) { const oldValue = this.value; cb.call(this.target, value, oldValue) } } } function parsePath(str) { var segments = str.split(&#39;.&#39;); return (obj) =&gt; { for (let i = 0; i &lt; segments.length; i++) { if (!obj) return; obj = obj[segments[i]] } return obj; } } 在创建Watcher实例的时候，将Dep.target指向当前实例，然后触发被处理过的属性的get方法，调用dep的depend方法，将这个watcher实例添加到dep的subs队列中，这时候defineReactive方法就要发生一点改变了 export default function defineReactive(data,key,val){ const dep = new Dep(); if(arguments.length == 2){ val = data[key]; } //子元素要进行observe，形成递归，多个函数循环调用 let childOb = observe(val); Object.defineProperty(data,key,{ enumerable:true, configurable:true, //getter get() { console.log(`打开${key}属性`) //如果现在处于依赖收集阶段 if(Dep.target){ dep.depend(); if(childOb){ childOb.dep.depend() }; } return val; }, //setter set(newValue) { console.log(`改变obj的${key}属性`,newValue) if(val === newValue){ return; } val = newValue; childOb = observe(newValue) dep.notify(); } }); } 总结Vue数据绑定的过程大致就是如此了，还有很多不完善的地方，比如直接通过数组索引改变数组项不会触发响应式，这里官方也是不建议使用下标直接修改，所以官方提供了$set这个API来完成操作 结束~~~","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"帧动画animation","slug":"笔记/帧动画animation","date":"2021-02-01T01:10:59.521Z","updated":"2021-02-05T08:51:23.462Z","comments":true,"path":"2021/02/01/笔记/帧动画animation/","link":"","permalink":"https://easyremember.cn/2021/02/01/笔记/帧动画animation/","excerpt":"","text":"没有中间值过度的属性无法使用帧动画 定义关键帧使用关键字@keyframes来声明关键帧 from表示开始 to表示结束 使用百分数表示动画到百分之几的位置 如： @keyframes box { from { } to { } /* 或者 */ /* 0% { } 100%{ } */ } 不设置0%和100%时默认使用元素初始样式，时间点可以同时设置，例如25%,75%{}就可以在两个时间点同时生效 使用关键帧使用动画元素属性中使用animation-name声明动画，可以声明多个动画，使用逗号隔开；使用animation-duration声明动画时间，多个时间并列会自动对应相应的name，如果动画个数多于时间个数，会从第一个时间开始依次使用 .class { animation-name: box, float-box; animation-duration: 6s, 3s; } 如果多个动画存在属性冲突，后出现的权重高，如果后出现的执行完了，先设置的效果还没结束，就会再执行先设置的效果 重复动画使用animation-iteration-count 规则设置动画重复执行次数，设置值为 infinite 表示无限循环执行，控制多个动画重复次数的规则跟时间控制一样 动画方向使用animation-direction规则设置动画的方向 normal——从0%到100%运行动画 reverse——从100%到0%运行动画 alternate——先从0%到100%，然后从100%到0% alternate-reverse——先从100%到0%，然后从0%到100% 延迟动画使用 animation-delay 规则定义动画等待多长时间后执行。 动画速率 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 开始慢，然后快，慢下来，结束时非常慢（cubic-bezier(0.25,0.1,0.25,1)） ease-in 开始慢，结束快（等于 cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值 步进动画通过 animation-timing-function控制步进动画，具体操作如下 选项 说明 steps(n,start) 设置n个时间点，第一时间点变化状态 steps(n,end) 设置n个时间点，第一时间点初始状态 step-start 等于steps(1,start)，可以理解为从下一步开始 step-end 等于steps(1,end)，可以理解为从当前步开始 播放状态使用 animation-play-state 可以控制动画的暂停与运行 paused：暂停 running：运动 可以在鼠标悬浮时运动或者暂停 填充模式animation-fill-mode 用于定义动画播放结束后的处理模式，是回到原来状态还是停止在动画结束状态。 选项 说明 none 需要等延迟结束，起始帧属性才应用 backwards 动画效果在起始帧，不等延迟结束 forwards 结束后停留动画的最后一帧 both 包含backwards与forwards规则，即动画效果在起始帧，不等延迟结束，并且在结束后停止在最后一帧 组合定义可以使用animation组合定义帧动画。animation 属性是一个简写属性，用于设置六个动画属性： animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction 必须存在 animation-duration属性，否则过渡时间为0没有动画效果","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/tags/笔记/"}],"keywords":[]},{"title":"Vue面试题","slug":"随想/Vue面试题","date":"2021-01-19T13:33:03.945Z","updated":"2021-01-19T13:34:03.565Z","comments":true,"path":"2021/01/19/随想/Vue面试题/","link":"","permalink":"https://easyremember.cn/2021/01/19/随想/Vue面试题/","excerpt":"","text":"深度监听对象有如下数据，实现对obj的深度监听 data() { return { obj: { name: &#39;张三&#39;, age: 21, } } } 结合computed 将要监听的属性使用computed计算出来，然后监听这个计算属性，如下 computed: { oName() { return this.obj.name } }, watch: { oName(newValue) { console.log(&#39;name值变为&#39;+newValue) } } 深度监听 利用Vue自身的深度监听，设置深度监听为true，如下 watch: { obj: { deep: true, handler: (newValue) =&gt; { console.log(&#39;name值变为&#39;+newValue) } } } 什么是MVVM传统的MVC（Model-View-Controller）中，当数据Model发生变化时由控制器Controller控制视图View的更新。 随着前端页面越来越复杂以及单页应用的出现，MVC模型已经不再适应前端的开发，MVVM（Model-View-ViewModel）应运而生 ，MVVM中Model和View没有直接联系，通过ViewModel进行交互，而且是双向的，这样开发时就不再需要关注View，只需要对数据进行处理就可以了 响应式数据的原理Vue在初始化时，会给data中属性通过Object.defineProperty()重新定义所有属性，当页面取到对应的属性是会进行依赖收集，如果属性发生变化会通知相关依赖进行更新 Vue如何检测数组变化 使用函数劫持的方法，重写数组方法 Vue将data中的数组进行了原型链重写，指向了自己顶一个数组原型链方法，在调用数组API时，可以通知依赖更新，如果数组中存在引用类型，，会对引用类型再次进行监控 为什么Vue采用异步渲染如果不采用异步更新，那么每次数据变化都会引起组件的重新渲染，为了性能考虑，Vue会在本轮数据更新后再去异步渲染 nextTick原理nextTick 方法主要是使用了宏任务和微任务,定义了一个异步方法.多次调用 nextTick 会将方法存入 队列中，通过这个异步方法清空当前队列。 所以这个 nextTick 方法就是异步方法 Computed和Watch的区别Computed和Watch都是watcher，区别在于Computed具有缓存功能 Watch中的deep: true怎么实现的当用户指定了 watch 中的deep属性为 true 时，如果当前监控的值是数组类型。会对对象中的每 一项进行求值，此时会将当前 watcher 存入到对应属性的依赖中，这样数组中对象发生变化时也 会通知数据更新 生命周期 ajax请求放在哪个生命周期中 在created的时候，视图中的 dom 并没有渲染出来，所以此时如果直接去操 dom 节点，无法找到相 关的元素 在mounted中，由于此时 dom 已经渲染出来了，所以可以直接操作 dom 节点 ；一般情况下都放到 mounted 中,保证逻辑的统一性,因为生命周期是同步执行的， ajax 是异步执行的 服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放到created中 何时需要使用beforeDestroy 可能在当前页面中使用了 $on 方法，那需要在组件销毁前解绑。 清除自己定义的定时器 解除事件的绑定 scroll mousemove …. Vue中模板编译原理 第一步是将 模板字符串 转换成 element ASTs（解析器） 第二步是对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器） 第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器） Vue中v-if和v-show的区别v-if 如果条件不成立不会渲染当前指令所在节点的 dom 元素 v-show 只是切换当前 dom 的显示或者隐藏(display: none) 为什么V-for和v-if不能连用v-for 会比 v-if 的优先级高一些,如果连用的话会把 v-if 给每个元素都添加一下,会造成性能问题 如果需要连用，可以使用计算属性，先处理要遍历的数据，筛选之后再遍历 &lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;computeData&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;script&gt; data() { return { initData: [ {flag: true, name: &#39;aaa&#39;}, {flag: false, name: &#39;bbb&#39;}, ] } }, computed: { computeData() { this.initData.map((item) =&gt; { return item.flag }) } } &lt;/script&gt; diff算法的时间复杂度两个树的完全的 diff 算法是一个时间复杂度为 O(n³) , Vue 进行了优化O(n³) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题) 在前端当中， 你很少会跨越层级地移动Dom元素。 所 以 Virtual Dom只会对同一个层级的元素进行对比 diff原理 先同级比较，在比较子节点 先判断一方有儿子一方没儿子的情况 比较都有儿子的情况 递归比较子节点 v-for中为什么要有key 组件中的 data为什么是一个函数同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果 data 是一个对象的 话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过 data 函数 返回一个对象作为组件的状态 一个组件被使用多次，用的都是同一个构造函数。为了保证组件的不同的实例data不冲突，要求 data必须是一个函数，这样组件间不会相互影响 Vue中事件绑定的原理Vue 的事件绑定分为两种一种是原生的事件绑定，还有一种是组件的事件绑定 原生 dom 事件的绑定,采用的是 addEventListener 实现 组件绑定事件采用的是 $on 方法 原理 Vue中常见性能优化1.编码优化: 不要将所有的数据都放在data中，data中的数据都会增加getter和setter，会收集对应的 watcher vue 在 v-for 时给每项元素绑定事件需要用事件代理 SPA 页面采用keep-alive缓存组件 拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 ) v-if 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show key 保证唯一性 ( 默认 vue 会采用就地复用策略 ) Object.freeze 冻结数据 合理使用路由懒加载、异步组件 尽量采用runtime运行时版本 数据持久化的问题 （防抖、节流） 2.Vue加载性能优化:第三方模块按需导入 ( babel-plugin-component ) 滚动到可视区域动态加载 图片懒加载 3.用户体验:app-skeleton 骨架屏 app-shell app壳 pwa serviceworker 4.SEO优化：预渲染插件 prerender-spa-plugin 服务端渲染 ssr 5.打包优化:使用 cdn 的方式加载第三方模块 多线程打包 happypack splitChunks 抽离公共文件 sourceMap 生成 6.缓存，压缩客户端缓存、服务端缓存 服务端 gzip 压缩 参考资料Vue面试题汇总一 Vue面试题汇总二","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://easyremember.cn/tags/悦读/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"重学flex","slug":"技术/重学flex","date":"2021-01-05T07:03:32.209Z","updated":"2021-01-05T07:04:40.918Z","comments":true,"path":"2021/01/05/技术/重学flex/","link":"","permalink":"https://easyremember.cn/2021/01/05/技术/重学flex/","excerpt":"","text":"flex指的是弹性盒模型也叫弹性布局，任何容器都可以设置为flex；flex将会是未来最流行的布局方式，但是现在浏览器的兼容并不是很好 属性6个容器属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 6个元素属性 order flex-grow flex-shrink flex-basis flex align-self flex-directionflex-direction用于设置主轴的方向，row从左到右、row-reverse从右向左、column从上到下、column-reverse从下到上 flex-wrapflex-wrap用于设置换行，当一条主轴上排列不开时可以设置换行 wrap：换行吗，从第一行开始，依次往下排 wrap-reverse：换行，第一行在最下面，依次往上排 nowrap：不换行，默认设置 flex-flowflex-direction和flex-wrap的简写属性flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; 例如 .father { display: flex; flex-flow: row wrap; /*效果相同*/ /*flex-direction: row*/ /*flex-wrap: wrap;*/ } justify-contentjustify-content用于设置内容在主轴上的对齐方式 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。 align-itemsalign-items定义元素在交叉轴上的对齐方式 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义当有多根轴线时，轴线的对齐方式，一根轴线时不起作用 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 orderorder定义元素的排列顺序。数值越小，排列越靠前，默认为0 flex-growflex-grow定义元素的放大比例 flex-shrinkflex-shrink定义了元素的缩小比例 flex-basisflex-basis定义了在分配多余空间之前，项目占据的主轴空间 flexflex是flex-grow,flex-shrink和flex-basis的简写，默认值为0 1 auto align-selfalign-self允许单个元素有与其他元素不一样的对齐方式","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"css","slug":"css","permalink":"https://easyremember.cn/tags/css/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"react组件传值","slug":"技术/react组件传值","date":"2020-12-31T07:17:00.093Z","updated":"2020-12-31T07:18:24.013Z","comments":true,"path":"2020/12/31/技术/react组件传值/","link":"","permalink":"https://easyremember.cn/2020/12/31/技术/react组件传值/","excerpt":"","text":"父-&gt;子父组件将要传递的数据放到子组件的属性上， // 父组件 class Father extends Component { render() { &lt;Son message=&quot;msg from father&quot; /&gt; } } 子组件通过props获取这个值 // 子组件 class Son extends Component { constructor(props) { super(props) } render() { &lt;div&gt; {this.props.message} &lt;/div&gt; } } 子-&gt;父子组件向父组件传值使用回调函数，父组件先向子组件传递一个函数， // 父组件 sonHandler(msg) { this.setState({ message: msg }) } render() { return &lt;div&gt; {/*&lt;Redirect /&gt;*/} &lt;h2&gt;{this.state.message}&lt;/h2&gt; &lt;Son click={this.sonHandler.bind(this)} /&gt; &lt;/div&gt; } 然后子组件中触发这个函数，并携带参数，就可以实现将子组件中的数据传递到父组件中 callback = (msg) =&gt; { return () =&gt; { this.props.click(msg) } } render() { return &lt;div&gt; &lt;button onClick={this.callback(&#39;msg from son&#39;)}&gt;click&lt;/button&gt; &lt;/div&gt; } 祖先-&gt;后代祖先到后代之间的传递方式有两种：中间层逐层props和使用context对象。逐层传递在层级较深时会变得很复杂，所以我们只使用context方法。 使用方法：上级组件声明自己支持context，提供一个context对象；子级组获取context // 为当前的 theme 创建一个 context（“light”为默认值）。 const ThemeContext = React.createContext(&#39;light&#39;); // 父组件 class App extends React.Component { render() { return ( &lt;ThemeContext.Provider value=&quot;dark&quot;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); } } // 子组件 function Toolbar() { return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; ); } // 孙子组件（类组件） class ThemedButton extends React.Component { static contextType = ThemeContext; render() { return &lt;Button theme={this.context} /&gt;; } } // 孙子组件（函数组件） export default function ThemedButton() { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;Button theme={theme} /&gt; )} &lt;/ThemeContext.Consumer&gt; ) } APIReact.createContext 创建一个context对象，返回一个Provider，可以设置默认值，当组建没有被Provider包裹时，会使用默认值 Context.Provider 接收一个value属性，传递给消费组件，有多层Provider包裹时，最内层的组件会覆盖其他 Context.Consumer 接收context的值，传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值 Class.contextType 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。 class MyClass extends React.Component { componentDidMount() { let value = this.context; /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */ } componentDidUpdate() { let value = this.context; /* ... */ } componentWillUnmount() { let value = this.context; /* ... */ } render() { let value = this.context; /* 基于 MyContext 组件的值进行渲染 */ } } MyClass.contextType = MyContext;","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://easyremember.cn/tags/react/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Redux笔记","slug":"笔记/Redux笔记","date":"2020-12-30T08:38:44.340Z","updated":"2021-03-01T01:34:24.959Z","comments":true,"path":"2020/12/30/笔记/Redux笔记/","link":"","permalink":"https://easyremember.cn/2020/12/30/笔记/Redux笔记/","excerpt":"","text":"redux简介Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux 除了和 React 一起用外，还支持其它界面库。 安装使用npm安装npm install --save redux或者使用yarn安装yarn add redux redux flow 三大原则 唯一数据源 保持只读状态 数据改变只能通过纯函数来执行 这里的纯函数指的就是reducer，随着应用变大，可以拆分成多个reducer 核心Actionaction负责将数据从应用传输到store，通过store.dispatch()将action传到store；action本质上是JavaScript对象，通过键值来传递数据，规定必须要有type属性，通过type来标识action，此外可以添加其他属性，结构如下： { type: &#39;ADD_ITEM&#39;, content: &#39;code review&#39; } Reducerreducer的主要功能是将action发送到store从而更新store，(previousState, action) =&gt; newState，reducer函数接收两个参数，一个是旧的state，另一个是action，返回值是一个新的state。reducer通过action的type属性来识别不同的操作 reducer一定要是一个纯函数，不要在reducer中发生以下操作： 修改传入参数 调用非纯函数 执行有副作用的操作 纯函数：函数的输出结果只跟传入的参数有关，只要参数不变，输出的结果永远不会改变 返回值的操作：不能修改原有的state，可以使用Object.assign({}, state, {newProperty})和...（展开运算符）来处理返回结果；遇到无法识别的action时要返回旧的state 拆分reducer：当reducer变得非常复杂时可以将其按照功能拆分，多个reducer通过combineReducers函数来合并或者通过function包装，例如 // todoReducer const todoState = [ &#39;test&#39;, &#39;code&#39;, &#39;submit&#39;, ] function todoReducer(state = todoState， action) { switch(action.type) { case &#39;ADD_ITEM&#39;: state.push(action.value) return state default: return &#39;&#39; } } // roleReducer function roleReducer(state = &#39;SHOW_ALL&#39;, action) { switch (action.type) { case &#39;SET_VISIBILITY_FILTER&#39;: return action.filter default: return state } } // index import { combineReducers, createStore } from &#39;redux&#39; let reducer = combineReducers({ todoReducer, roleReducer }) let store = createStore(reducer) // 或者 export default function todoApp(state = {}, action) { return { todoReducer: todoReducer(state.todoReducer, action), roleReducer: roleReducer(state.roleReducer, action) } } Storeredux中只有一个store，是负责将action和state联系起来的容器，提供了更新state的方法dispatch()和获取state的方法getState()，通过subscribe()注册监听器以及销毁监听器 暴露store： 在store文件中引入redux中的createStore方法，引入reducers，然后暴露store import {createStore} from &#39;redux&#39; import reducer from &#39;./reducer&#39; let store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()) export default store createStore()的第二个参数可选，填入这段代码可以开启redux devtools进行调试 订阅store以及获取state： 使用store.getState()可以获取到store中的state，在componentDidMount生命周期中添加订阅 constructor(props) { super(props); this.state = { ...store.getState(), } // 也可以在这里注册 // store.subscribe(() =&gt; { // this.setState(store.getState()) // }) } componentDidMount() { store.subscribe(this.storeChange) } storeChange = () =&gt; { this.setState(store.getState()) } subscribe()的参数是一个回调函数，当store中数据发生改变时可以触发方法 更新state： 使用store.dispatch()方法，传入action来更新state addItem = () =&gt; { if (this.state.input) { const action = { type: &#39;ADD_ITEM&#39;, value: this.state.input } store.dispatch(action) this.setState({ input: &#39;&#39; }) } }","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"react","slug":"react","permalink":"https://easyremember.cn/tags/react/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"React-Router笔记","slug":"笔记/React-Router笔记","date":"2020-12-16T08:46:15.780Z","updated":"2020-12-17T01:03:36.307Z","comments":true,"path":"2020/12/16/笔记/React-Router笔记/","link":"","permalink":"https://easyremember.cn/2020/12/16/笔记/React-Router笔记/","excerpt":"","text":"react-router入门React-Router由社区维护并非官方发布的，有三个部分 react-router 核心组件 react-router-dom 应用于浏览器端的路由库（单独使用包含了react-router的核心部分） react-router-native 应用于native端的路由 所以我们就只需要引入react-router-dom就可以了 React-Router中主要有三部分，Router、Route和Link，Router用于管理Route，Route用来匹配组件，Link用来跳转Route，先来看一个简单的小示例 &lt;Router&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/list&quot;&gt;列表&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/&quot; exact component={Index}/&gt; &lt;Route path=&quot;/list&quot; component={List}/&gt; &lt;/Router&gt; Link用于跳转，在渲染时会被渲染成 &lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;的样式 路由传参路由传参大致分为两大类，一种是通过动态路由传参，一种是通过路由属性传递，就是params和query &lt;Route path=&quot;/list/:id&quot; component={List}/&gt; // 声明路由时定义接收的参数，然后在组件中通过props.match.params获取这个值 &lt;Link to=&quot;/list/123&quot;&gt;列表&lt;/Link&gt; // 这个link就可以命中路由，123也将作为params属性传递 // 还是上面的路由声明，将to做修改 &lt;Link to={{pathname: \"/list/123\", query: {name: '张三'}}}&gt;列表&lt;/Link&gt; // pathname作为url路径，query将被携带到props.location.query中 嵌套路由react的路由嵌套也很简单，就是在组件中再声明路由，比如一级路由中声明了一个/list路由，指向List组件，然后List组件中再声明/list/newslist路由指向子组件，就可以达到二级路由的效果 Switch组件Switch用于只匹配一个组件，比如/about和/:user这两个路由，命中第一个就必定会命中第二个，这时候可以使用Switch将Route声明包裹，就只命中1个组件；此外还可以在所有的路由都不命中时显示404页面 &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component={Home}/&gt; &lt;Route path=&quot;/about&quot; component={About}/&gt; &lt;Route component={NotFound}/&gt; &lt;/Switch&gt; Redirect组件Redirect组件用于组件重定向，有两种方法来实现重定向 使用Redirect标签声明重定向 在构造函数中使用this.props.history.push()实现编程式重定向 例如可以在个人中心的页面中，通过判定是否登陆来重定向到登录页面 // 声明式(路由声明组件) &lt;Route exact path=&quot;/person&quot; render={() =&gt; ( &#39;登录判定条件&#39; ? ( &lt;Person /&gt; ) : ( &lt;Redirect to=&quot;/login&quot;/&gt; ) )}/&gt; // 编程式(个人中心组件) constructor(props) { super(props); this.state = {} if (&#39;未登录判定条件&#39;) { this.props.history.push(&#39;/login&#39;) } } react-router进阶这种写法虽然能够运行，但是后期的维护成本太高，我们需要将路由尽可能的配置到一起，以减少后期的维护成本，我们可以将路由信息配置到一个数组中，然后通过map来遍历数组 function AppRouter() { let routes = [ { path: &#39;/&#39;, exact: true, component: Person }, { path: &#39;/list/:id&#39;, exact: false, component: InputList }, ] return (&lt;Router&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to={{pathname: \"/list/123\", query: {name: '张三'}}}&gt;列表&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; { routes.map((item) =&gt; { return (&lt;Route path={item.path} exact={item.exact} key={item.path} component={item.component}/&gt;) }) } &lt;/Router&gt;) } export default AppRouter 虽然这样比起之前好了不少，但是还是达不到我们想要的效果 终极解决方案react-router-config这里需要额外安装一个包react-router-config，安装完之后就可以开始配置路由了 新建一个router的js文件 export const routes = [ { path: &#39;/&#39;, exact: true, component: Person }, { path: &#39;/list/:id&#39;, component: InputList, routes: [ { path: &#39;/list/:id/h&#39;, component: News } ] } ] 然后修改AppRouter文件，将Route的map遍历声明改为{renderRoutes(routes)} function AppRouter() { return &lt;Router&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to={{pathname: \"/list/123\", query: {name: '张三'}}}&gt;列表&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; {renderRoutes(routes)} &lt;/Router&gt; } export default AppRouter 子路由也一样，在子组件中使用{renderRoutes(this.props.route.routes)}","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"react","slug":"react","permalink":"https://easyremember.cn/tags/react/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"React入门笔记","slug":"笔记/React入门笔记","date":"2020-12-15T14:01:03.039Z","updated":"2021-02-27T09:49:17.214Z","comments":true,"path":"2020/12/15/笔记/React入门笔记/","link":"","permalink":"https://easyremember.cn/2020/12/15/笔记/React入门笔记/","excerpt":"","text":"本文将会以与Vue的差别来进行React的学习，所以在阅读本文之前我希望你能具备以下技能 前端三剑客HTML+CSS+JavaScript 了解Vue的使用 书写形式React在采用自创jsx语法，即HTML in JavaScript，将UI与逻辑耦合在一起 import React from &#39;react&#39;; class item extends React.Component { constructor(props) { super(props); this.state = { } } render() { return &lt;div&gt; {/*要显示的内容*/} &lt;/div&gt; } } Vue常规采用模板语法，将HTML文档与JavaScript逻辑分离开，Vue也可以设置使用jsx &lt;template&gt; &lt;!--页面内容--&gt; &lt;/template&gt; &lt;script&gt; // 逻辑部分 &lt;/script&gt; &lt;style&gt; /*css样式*/ &lt;/style&gt; 组件及传递数据二者都通过导入外部文件然后使用HTML标签的形式在引用组件，不同点在于二者的组件接收形式 React中通过构造函数来接收props， constructor(props) { super(props); this.state = {} } // 通过构造函数接收props之后就可以直接通过this.props来获得参数 vue通过options来接收参数，可以规定props的类型及默认值 &lt;script&gt; props: { message: { type: String, default: &#39;from father&#39; } } &lt;/script&gt; 在react中也可以规定类型及默认值，但是需要引入第三方的包，这里官网文档已经说得很清楚了 从子组件向父组件传递数据时都是通过触发父组件传递过来的回调函数来实现 // Vue this.$emit(&#39;eventName&#39;, data) // React this.props.eventName(data) 修改数据在React中数据存储在state中，不可以直接修改，直接修改不会触发render，而Vue中则可以直接修改data中的数据，因为Vue对每一个数据都进行了数据劫持，当数值发生改变时都会触发渲染 在React中想要修改数据需要使用API——setState constructor(props) { super(props); this.state = { value: 12 } } changeValue() { this.setState({ value: 13 }) } 事件Vue中通过v-on来绑定事件，可以简写为@ &lt;button @click=&quot;eventHandler&quot;&gt; 点击 &lt;/button&gt; React中跟传统HTML相似但又略微不同 &lt;button onClick={this.eventHandler.bind(this)}&gt; 点击 &lt;/button&gt; 在React中声明方法this指向并不是组件的this，需要改变其this指向，可以使用的方法有： 在构造函数中绑定：this.eventHandler = this.eventHandler.bind(this) 在声明方法时使用eventHandler = () =&gt; {}的形式 在调用方法时绑定：onClick={this.eventHandler.bind(this)}或者onClick={() =&gt; this.eventHandler()} 条件渲染Vue中的条件渲染使用v-if、v-else-if、v-else、v-show来进行条件渲染，区别在于v-if不会渲染到文档中，v-show会渲染到文档中，只是display变为none &lt;div v-if=&quot;value&quot;&gt; {{value}} &lt;/div&gt; &lt;div v-else&gt; 暂无数据 &lt;/div&gt; React中的条件渲染是通过js的if语句控制变量或者运算符来控制的 // 变量控制 let data; if(this.state.value) { data = &lt;div&gt;{this.state.value}&lt;/div&gt; } else { data = &lt;div&gt;暂无数据&lt;/div&gt; } return( {data} ) // _______________________ // &amp;&amp;运算符 // 因为在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression // 而 false &amp;&amp; expression 总是会返回 false return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; {unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have {unreadMessages.length} unread messages. &lt;/h2&gt; } &lt;/div&gt; ); // ________________________ // 三目运算符 return ( &lt;div&gt; The user is &lt;b&gt;{isLoggedIn ? &#39;currently&#39; : &#39;not&#39;}&lt;/b&gt; logged in. &lt;/div&gt; ); 列表在Vue中通过v-for属性来生成列表 &lt;ul&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; 在React中使用js的遍历来生成列表 &lt;ul&gt; list.map((item, index) =&gt; { return &lt;li key={index}&gt;{item}&lt;/li&gt; }) &lt;/ul&gt; 实际上并不建议使用index作为key值，每个key应该是独一无二的 “双向绑定”在Vue中使用v-model属性来绑定data，这是真正的双向绑定，绑定之后我们不再需要关心值的改变，而在React中，重新赋值就需要我们来手动操作，如果不手动修改，页面不会重新渲染，比如输入框中使用键盘输入一串字符，其实他已经有值了，但是页面上的输入框还是会显示空白 inputHandler = (e) =&gt; { this.setState({ inputValue: e.target.value }) } render( return &lt;div&gt; &lt;input value={this.state.inputValue} onChange={this.inputHandler}/&gt; &lt;/div&gt; ) 生命周期关于生命周期已经有很多讲的不错的文章了，可以去看一下 重点两个比较难搞得就是shouldComponentUpdate和componentWillReceiveProps shouldComponentUpdate(nextProps, nextState)通过返回值是true和false来控制组件是否重新渲染（react父组件发生改变时所有的子组件都会重新render），可以通过对比前后的props来决定是否进行重新渲染，这是一种优化手段；只在props或者state发生改变时执行 shouldComponentUpdate(nextProps, nextState, nextContext) { if(this.props.person === nextProps.person) { return false } else { return true } } componentWillReceiveProps只在props发生改变时执行，可以在这里面使用setState，不会引起额外的render 获取DOM元素Vue中获取DOM的方式是通过给元素添加ref属性，然后通过$refs来获取DOM &lt;template&gt; &lt;input ref=&quot;inputRef&quot; type=&quot;text&quot; /&gt; &lt;/template&gt; &lt;script&gt; mounted() { console.log(this.$refs[&#39;inputRef&#39;]) } &lt;/script&gt; 在React中有很多种方式，其中一种就跟Vue这种形式一样，但是已经废弃了，我们再来看一下其他方法 React.createRef() 在构造函数中声明一个变量并赋值React.createRef()，然后在元素上挂载ref，就可以通过这个变量来访问DOM constructor() { this.inputRef = React.createRef() } componentDidMount() { console.log(this.inputRef.current) // 这里注意使用createRef的方式需要通过current来获取 } render( return &lt;div&gt; &lt;input ref={this.inputRef} /&gt; &lt;/div&gt; ) 回调函数 直接在回调函数中向组件传递DOM componentDidMount() { console.log(this.inputRef) // 回调函数的方式直接获取 } render( return &lt;div&gt; &lt;input ref={(ul) =&gt; {this.inputRef = ul}} /&gt; &lt;/div&gt; ) 子组件ref 通过React.forward()来创建子组件，接收两个参数props、ref，将元素绑定接收来的ref就可以在父组件中获取子组件的DOM了 // 子组件 const InputComponent = React.forwardRef((props,ref)=&gt;( &lt;input type=&quot;text&quot; ref={ref} /&gt; )); // 父组件，使用createRef声明this.InputRef变量 &lt;InputComponent ref={this.InputRef} /&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"react","slug":"react","permalink":"https://easyremember.cn/tags/react/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"react配置axios","slug":"技术/react配置axios","date":"2020-12-14T05:29:32.642Z","updated":"2020-12-14T05:40:31.720Z","comments":true,"path":"2020/12/14/技术/react配置axios/","link":"","permalink":"https://easyremember.cn/2020/12/14/技术/react配置axios/","excerpt":"","text":"react配置axios配置axios之前设置一下代理，可以用来解决跨域问题 在package.json中添加一行代理设置，在新版的react中，proxy不再是对象形式，变成了string形式，如果按照之前的写法就会报错 新版写法 &quot;proxy&quot;: &quot;https://192.168.1.1/api&quot; 然后就是axios的配置 原型相比于常见的引入写法我个人比较习惯将axios挂载到原型上来使用（Vue中也是如此），但是在react中不是直接向React原型挂载而是想React.component的原型上挂载 在index.js中进行如下配置 import axios from &#39;axios&#39; // 配置axios axios.defaults.baseURL = &#39;/api&#39; // 配置请求拦截 axios.interceptors.request.use( config =&gt; { config.headers.Authorization = window.localStorage.getItem(&#39;token&#39;) return config; }, err =&gt; { return Promise.reject(err); } ); // 添加响应拦截器 axios.interceptors.response.use( function (response) { console.log(response); return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); } ); React.Component.prototype.$http = axios 在使用时，只要是继承Component创建的组件都可以直接通过this.$http来使用axios的方法，如 getList() { this.$http.get(&#39;/wbbr/bgeda&#39;).then(res =&gt; { console.log(res) }).catch(err =&gt; { console.log(err) }) } componentDidMount() { this.getList() } 在componentDidMount生命周期调用请求数据的方法 导入还有比较经典的方法就是通过一个js文件来封住axios，然后导出HTTP方法，需要请求的时候导入方法 import axios from &quot;axios&quot;; axios.defaults.timeout = 100000; axios.defaults.baseURL = &quot;http://test.mediastack.cn/&quot;; /** * http request 拦截器 */ axios.interceptors.request.use( (config) =&gt; { config.data = JSON.stringify(config.data); config.headers = { &quot;Content-Type&quot;: &quot;application/json&quot;, }; return config; }, (error) =&gt; { return Promise.reject(error); } ); /** * http response 拦截器 */ axios.interceptors.response.use( (response) =&gt; { return response; }, (error) =&gt; { console.log(&quot;请求出错：&quot;, error); } ); /** * 封装get方法 * @param url 请求url * @param params 请求参数 * @returns {Promise} */ export function get(url, params = {}) { return new Promise((resolve, reject) =&gt; { axios.get(url, { params: params, }).then((response) =&gt; { landing(url, params, response.data); resolve(response.data); }) .catch((error) =&gt; { reject(error); }); }); } /** * 封装post请求 * @param url * @param data * @returns {Promise} */ export function post(url, data) { return new Promise((resolve, reject) =&gt; { axios.post(url, data).then( (response) =&gt; { //关闭进度条 resolve(response.data); }, (err) =&gt; { reject(err); } ); }); } /** * 封装patch请求 * @param url * @param data * @returns {Promise} */ export function patch(url, data = {}) { return new Promise((resolve, reject) =&gt; { axios.patch(url, data).then( (response) =&gt; { resolve(response.data); }, (err) =&gt; { msag(err); reject(err); } ); }); } /** * 封装put请求 * @param url * @param data * @returns {Promise} */ export function put(url, data = {}) { return new Promise((resolve, reject) =&gt; { axios.put(url, data).then( (response) =&gt; { resolve(response.data); }, (err) =&gt; { msag(err); reject(err); } ); }); } 在使用时 import {get} from &#39;../http.js&#39; getList() { get(&#39;/wbbr/bgeda&#39;).then(res =&gt; { console.log(res) }).catch(err =&gt; { console.log(err) }) } componentDidMount() { this.getList() }","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://easyremember.cn/tags/react/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"前端面试经典问题","slug":"随想/前端面试经典问题","date":"2020-12-07T07:55:46.825Z","updated":"2021-02-22T12:11:38.882Z","comments":true,"path":"2020/12/07/随想/前端面试经典问题/","link":"","permalink":"https://easyremember.cn/2020/12/07/随想/前端面试经典问题/","excerpt":"","text":"BFC BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 BFC布局规则： Box垂直方向的距离由margin决定，同一个BFC内部会出现margin塌陷现象 BFC的区域不会与float box重叠 浮动元素也参与计算BFC高度 创建BFC float的值不是none。 position的值不是static或者relative。 display的值是inline-block、table-cell、flex、table-caption或者inline-flex overflow的值不是visible 作用：解决margin塌陷、不会被浮动元素覆盖、解决浮动元素无法撑起父级元素 闭包先来看一段代码 function f() { var book = &#39;JavaScript高级&#39; } console.log(book); 这一段代码的执行结果当然是报错，因为book的作用域是在f函数内部，外部无法访问，函数执行时生成一个自己的执行上下文（执行环境），执行完毕时执行上下文销毁 作用域链 作用域链中保存着当前变量对象和所有父级变量对象 function f() { var book = &#39;JavaScript高级&#39; return function () { console.log(book); } } var newF = f() newF() 执行f函数，将返回值赋值给newF函数，这个返回值是一个匿名函数，这其实就是闭包，在这个匿名函数中保留着f的作用域，所以这里可以打印出book的值 经典面试题for循环延时打印 for (var i = 0; i &lt; 5; i++) { setTimeout(function () { console.log(i); },1000) } // 5 5 5 5 5 结果为什么会是5个5呢，这里牵扯到了一点异步轮询，setTimeout属于异步方法，会在全局上下文执行完毕之后再之执行 执行过程为：for循环遍历5次，添加5个定时器，此时i=5，定时器时间到了之后，打印的是i的值，也就是5 那么怎么打印0-4呢？ 使用let声明i，let是块级变量 使用闭包，闭包函数有自己的作用域可以在设置定时器时保留i的值 let就不说了，说一下闭包解决这个问题 for (var i = 0; i &lt; 5; i++) { (function (j) { setTimeout(function () { console.log(j); }, 1000) })(i) } // 0 1 2 3 4 在么词设置定时器时，每次传进去的变量都不一样，每个定时器保留着着不同的作用域，所以结果是0 1 2 3 4 弊端 闭包虽好，但也有弊端——容易造成内存泄漏 根据js的垃圾回收机制，没有引用的变量将会自动回收，而如果使用闭包的形式通过函数表达式赋值给全局作用域中的一个变量，就可能会造成无法回收 原型先来看几个概念 原型——每一个函数都有一个prototype对象属性，指向另一个对象，prototype就是调用构造函数所创建的那个实例对象的原型 原型链——每个对象都有一个__proto__属性，用于指向创建它的函数对象的原型对象，通过__proto__把对象属性连接起来就叫原型链 如果还有些许疑惑，那么看代码吧 function Person(name) { this.name = name this.sayHi = function() { console.log(&#39;Hi&#39;); } } Person.prototype.sayName = function () { console.log(this.name); } const p = new Person(&#39;张三&#39;) p.sayHi() p.sayName() console.log(p.__proto__ === Person.prototype); 第一段代码是一个构造函数，添加了一个属性和一个方法；第二段代码是往Person的原型上添加方法；第三段代码是创建了一个对象实例p，他的父类是Person，然后执行父类的方法，最后一行说明了p的__proto__就是Person的prototype，对象实例可以使用原型链上的的方法 继承 继承有很多种方法 原型链继承 function Animals() { this.say = function () { console.log(&#39;Hi&#39;); } } function Cat() { } Cat.prototype = new Animals() 通过把Animals的原型对象添加到Cat的原型对象上，实现继承 构造函数继承 function Animals() { this.say = function () { console.log(&#39;Hi&#39;); } } function Cat() { Animals.call(this) } const c = new Cat() c.say() 用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制）） 组合继承 function Animals(name) { this.name = name this.say = function () { console.log(&#39;Hi&#39;); } } function Cat() { Animals.call(this, &#39;king&#39;) } Cat.prototype = new Animals() const c = new Cat() c.say() 将前面两种继承方式组合起来，解决了原型链继承不能传参和构造函数继承不能复用的问题，但是消耗内存，子类的构造函数会代替原型上的那个父类构造函数 原型式（实例）继承 function Animals(name) { this.name = name this.say = function () { console.log(&#39;Hi&#39;); } } function content(obj) { function F() { } F.prototype = obj return new F() } var animal = new Animals() var cat = content(animal) 通过对象实例来实现继承，但是无法复用 寄生组合继承 function Animals(name) { this.name = name this.say = function () { console.log(&#39;Hi&#39;); } } function content(obj) { function F() { } F.prototype = obj return new F() } var proto = content(Animals.prototype) function Cat() { Animals.call(this) } Cat.prototype = proto // 继承实例 proto.constructor = Cat // 修复实例 const c = new Cat() c.say() 解决了组合继承的问题 插一嘴new的原理 var new1 = function (Class) { var newObj = Object.create(Class.prototype); var returnObj = Class.call(newObj); return typeof returnObj === &#39;object&#39; ? returnObj : newObj } var s = new1(String) console.log(s instanceof String); // true 首先创建一个新的对象，然后通过构造函数继承的方式，将要实例化对象的原型添加到创建的对象上 HTTP请求方法GET 请求URL指定的资源 POST 传输实体主体 PUT PUT方法用来传输文件，也可以实现与post相同的效果 POST和PUT的区别：PUT具有幂等性，也就是说多次PUT操作对服务器影响是一样的。举个例子，如果发布一篇文章，发送了两个请求，如果使用POST会产生两篇相同的帖子，使用PUT只会产生一个 DELETE 用来删除文件，是PUT的相反方法。 HEAD 获取报文首部，和GET方法一样，只是不返回报文主体部分 OPTIONS 查询针对请求URL指定的资源支持的方法 TRACE 让Web服务器端将之前的请求通信环回给客户端方法 CONNECT 要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。 this的指向一句话来说就是：谁调用指向谁（个别情况除外） 改变this指向，可以看之前的一篇博客 正常情况下 this 指向调用他的上下文 箭头函数的 this 指向他的父作用域的 this（静态作用域、静态作用域、静态作用域） new 会创建一个新的对象，this 指向这个对象，详情可以自行了解 new call、bind、apply 会改变 this 的指向，详情自行了解 异步异步轮询 Promise原理 元素垂直水平居中 父级元素display设置为table，子元素display设置为table-cell，子元素vertical-align: middle; 利用绝对定位，父级设置position为relative，子级设置position为absolute，距离顶部50%左侧50%，然后利用transform，translate（-50%， -50%）；也可以使用margin-top和margin-left为负值 利用flex，将父级display设置为flex，然后justify-content: center; align-items: center; 利用父级伪类或子级空元素，display设置为inline-block，然后设置vertical-align: middle; 清除浮动 浮动元素后添加空标签，标签样式clear: both; 父级元素设置overflow: hidden;触发BFC，如果有定位谨慎使用 after伪元素清除浮动，浮动元素父级添加伪元素，设置属性clear: both; 盒子模型盒子模型包含margin（外边距）、padding（内边距）、border（边框）、content（内容）四部分 关于盒子模型存在两套标准 标准盒模型（W3C） 盒子宽度width=content 怪异盒模型（IE） 盒子宽度width=border+padding+content 这两个模型可以通过box-sizing来转换，conten-box是标准盒模型，border-box是怪异盒模型 数据类型JS中有两大类数据类型，基本类型和引用类型 基本类型——Number、String、Boolean、Null、Undefined以及新加入的Symbol 引用类型——是一种数据结构，用于将数据和功能组织在一起，常见的有Object类型，Array类型，Date类型，RegExp类型（正则），Function类型 基本类型和引用类型的区别 基本类型是按值访问的，因为可以直接操作保存在变量中的实际值，保存在栈中；而引用类型大小是不固定的，存储在堆内存中，不可以直接访问和操作对内存空间，所以只能在栈中操作引用地址 例如 基本类型在赋值时是将值重新添加到了b，此时改变a的值，b的值不受影响（传值） 而在引用类型中 在赋值时，传递的是引用的地址，所以内容发生变化时所有的引用都会改变（传址） 栈(stack)会自动分配内存空间，会自动释放。堆(heap)动态分配的内存，大小不定也不会自动释放，需要程序员手动释放，如果不释放就会由OS在程序结束运行时释放。 此外注意，在函数传参时，引用类型传参也是传的地址，形参的操作会影响到原来的数据 let、const和var的区别var存在变量提升，let和const没有 变量提升意味着可以先使用再声明，上代码 而块级作用域会报错 这就牵扯到了暂时性死区 暂时性死区：只要作用域内使用let声明了变量，变量就绑定了这个作用域，即使存在全局变量不会生效。使用let命令声明变量之前，该变量都是不可用的，这就叫暂时性死区。 let和const是块级变量 let和const都只会在声明所在的作用域块中生效，let和const的区别是，const声明时必须赋值，而且一旦赋值不可改变 同一作用域下const和let不能重复声明 事件委托事件委托主要利用了冒泡原理实现，从最深的结点开始，向外层传递事件，我们可以只给父级添加事件，然后通过target来触发事件 例如在ul&gt;li中，如果添加事件一般是在每个li上添加事件，如 &lt;ul id=&quot;ul&quot;&gt; &lt;li id=&quot;li1&quot;&gt;第一个&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;第二个&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;第三个&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;第四个&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var liNodes = document.querySelectorAll(&#39;li&#39;) for(let i =0; i &lt; liNodes.length; i++) { liNodes[i].onclick = function() { console.log(liNodes[i].innerText); } } &lt;/script&gt; 这样再每个节点上都加上监听会影响性能，这时候就可以利用事件委托在这些元素的父级元素上添加监听事件 事件委托 &lt;ul id=&quot;ul&quot;&gt; &lt;li id=&quot;li1&quot;&gt;第一个&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;第二个&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;第三个&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;第四个&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ulNode = document.getElementById(&#39;ul&#39;) ulNode.onclick = function(e) { console.log(e.target.innerText); } &lt;/script&gt; 就可以实现相同的效果 ES6和CommonJS模块化区别： CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用 CommonJS模块是运行时加载，ES6模块是编译时输出接口 ES6 使用export关键字导出变量或方法，使用import关键字导入模块； 此外还有默认导出export default，只能默认导出一次； export导出的内容会被放到一个对象中，导入时使用{}来解构取值，export default导出的是什么导入就是什么 CommonJS 使用module.exports关键字导出模块，使用require关键字倒入模块 可以使用解构或者.属性名来按需引入如 // 导出 module.exports = { obj: { name: &#39;张三&#39;, age: 14, out() { console.log(this.age); } } } // 导入 const obj = require(&#39;./1&#39;).obj // 或者 const {obj} = require(&#39;./1&#39;) 混用 module.exports可以看做一个export default，可以直接import 使用require导入export default时需要写成require().default 从输入url到显示内容发生了什么输入网址 在浏览器地址栏输入url 查找域名IP地址 首先从本地hosts文件中寻找对应的ip，如果由直接使用，没有的话发出DNS请求到本地DNS服务器，本地DNS先查找缓存，如果有返回目标ip，如果还没有找到，本地DNS就会到DNS根服务器查找，如果根DNS没有记录域名和IP的对应关系就会告诉本地DNS去域服务器查找，然后本地DNS再请求域服务器，域服务器再告诉本地DNS对应的解析服务器地址，最后本地DNS向解析服务器发送请求，然后获取到域名对应的IP，并且缓存下来 建立TCP连接 获取到对应的IP之后，向目标服务器发起TCP连接请求，经过三次握手之后建立连接 发送HTTP请求 建立好TCP连接之后，发起HTTP请求 服务器处理 服务器接收到浏览器发来的HTTP请求之后，处理相应的事务，将所需要的资源返回给浏览器 关闭TCP连接 为了避免资源占用，在资源传输完成之后将TCP连接断开，经过四次挥手之后连接中断 浏览器解析资源渲染 解析过程如下（来自网络，侵权联系删除） 怎么判断一个变量是数组 基于instanceof 基于constructor 基于Object.prototype.isPrototypeOf 基于getPrototypeOf 基于Object.prototype.toString 基于Array.isArray var a = [] a instanceof Array; a.constructor === Array; Array.prototype.isPrototypeOf(a); Object.getPrototypeOf(a) === Array.prototype; Object.prototype.toString.apply(a) === &#39;[object Array]&#39;; Array.isArray(a)","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://easyremember.cn/tags/悦读/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"Token无痛刷新","slug":"技术/token无痛刷新","date":"2020-12-01T09:23:38.519Z","updated":"2020-12-16T06:38:50.604Z","comments":true,"path":"2020/12/01/技术/token无痛刷新/","link":"","permalink":"https://easyremember.cn/2020/12/01/技术/token无痛刷新/","excerpt":"","text":"今天被问到一个很实用的问题： 出于安全考虑，将用户的token有效期设置得时间很短，怎么能保证用户在使用过程中的体验呢 然鹅，我没答上来！！！ 赶紧查一下解决方案，终于找到了解决办法 先来说一下原来的图有点丑，将就着看 首先在页面中触发一个事件向服务器发送一个请求，后端检测到token不合法，返回响应，状态码401，axios的响应拦截器捕获到了error，直接清除token，将页面跳转到首页 如果用户在刚填完一个很长的表单，刚提交，结果来了这么一出，那体验自然是很差的，所以有了下面的方案 无痛刷新需要后端提供支持，token除了设置过期时间之外，还要有一个刷新时间（刷新时间&gt;过期时间），当token过期之后只要没有超过刷新时间，就可以永久的token换取新的token，以保持前端无感 注意的一点是要再发送一次原来的请求，后端返回数据可以在错误响应中加入请求地址，（伪码） 这是一个错误响应的截图，里面有config项，可以用来访问原来的请求 const {token} = await getNewToken() localStroage.setItem(&#39;token&#39;, token) const res = axios.request(error.response.config) return res 注意先后顺序，要先获取到token之后再去访问请求","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"uni-app在线预览PDF","slug":"技术/uni-app在线预览PDF","date":"2020-11-29T04:10:32.740Z","updated":"2020-11-29T04:30:42.297Z","comments":true,"path":"2020/11/29/技术/uni-app在线预览PDF/","link":"","permalink":"https://easyremember.cn/2020/11/29/技术/uni-app在线预览PDF/","excerpt":"","text":"uni-app在线预览PDF需求文件不可以通过文件地址直接访问，要通过文件流的形式在线预览 工具基于pdfjs封装的组件（别人封装的），用webview访问本地网页 遇到的问题 开始的时候以为他可以自己获取文件流并处理，所以直接将请求地址传进去了 意识到他不能处理blob，手动处理，将blob转为url 正常处理了blob，处理后的url传进去，页数显示正常，但内容为空 踩坑的过程先看一下文件路径，资源会在文末分享 1 创建webview访问这个viewer.html&lt;template&gt; &lt;view style=&quot;width: 100%;&quot; &gt; &lt;web-view :src=&quot;allUrl&quot;&gt;&lt;/web-view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { allUrl:&#39;&#39;, viewerUrl: &#39;/hybrid/html/web/viewer.html&#39;, // 格式化文件流的一个js 文件 文末会分享出来 } }, onLoad(options) { let {url, title} = options uni.setNavigationBarTitle({ title: title }) this.allUrl = this.viewerUrl + url } &lt;/script&gt; 传进来的url是/read/tryread?bookId=${this.bookId}，但是pdfjs默认是不能处理这种形式的url的 2 先获取二进制流，转url在这个页面请求数据，然后转url传到pdfjs中，然后改进代码 &lt;template&gt; &lt;view style=&quot;width: 100%;&quot; &gt; &lt;web-view :src=&quot;allUrl&quot;&gt;&lt;/web-view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { allUrl:&#39;&#39;, viewerUrl: &#39;/hybrid/html/web/viewer.html&#39;, // 格式化文件流的一个js 文件 文末会分享出来 } }, methods: { getFile(url) { uni.request({ url: this.$photoHeader + &#39;api&#39; + url, header: { &#39;Content-Type&#39;: &#39;application/pdf&#39;, &#39;authorization&#39;: this.$store.getters.getToken }, success: (res) =&gt; { // ↓↓↓↓注意下面这里 const fileUrl = this.transBlobToUrl(res.data) this.allUrl = this.viewerUrl + &#39;?file=&#39; + fileUrl console.log(this.allUrl); }, }); }, transBlobToUrl(file) { // 将获取的blob转化为url // console.log(file); let url = null; if (window.createObjectURL != undefined) { // basic url = window.createObjectURL(file); } else if (window.webkitURL != undefined) { // webkit or chrome try { url = window.webkitURL.createObjectURL(file); } catch (error) { console.log(error) } } else if (window.URL != undefined) { // mozilla(firefox) try { url = window.URL.createObjectURL(file); } catch (error) { console.log(1); console.log(error) } } return url; }, }, onLoad(options) { let {url, title} = options uni.setNavigationBarTitle({ title: title }) this.getFile(decodeURIComponent(url)) } } &lt;/script&gt; 这应该可以获取到url了，但是还是不行，看到getFile中标记的地方了吗，问题就在这，他这里拿到的数据成了string，需要将string转为blob格式 将获取url的语句改为 const fileUrl = this.transBlobToUrl(new Blob([res.data])) 最后一步，临门一脚这时候数据拿到了，也转成url了，再回到页面中，！！！白屏，但是页数正常 查了好久之后发现，需要将响应格式声明为arraybuffer，也就是这样 然后再看页面，完美！ 插件地址：链接: https://pan.baidu.com/s/1xTTQPVWfJEVnY0hWlj7gdg 提取码: t8mn","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"nestjs学习笔记","slug":"笔记/NestJS学习笔记","date":"2020-11-27T13:02:04.459Z","updated":"2020-12-05T11:42:36.328Z","comments":true,"path":"2020/11/27/笔记/NestJS学习笔记/","link":"","permalink":"https://easyremember.cn/2020/11/27/笔记/NestJS学习笔记/","excerpt":"","text":"代码已上传码云 1 开始1.1 简介 Nest.js是一个渐进的Node.js框架，可以在TypeScript和JavaScript (ES6、ES7、ES8)之上构建高效、可伸缩的企业级服务器端应用程序。它的核心思想是提供了一个层与层直接的耦合度极小、抽象化极高的一个架构体系 Nest框架底层HTTP平台默认是基于Express 实现的，所以无需担心第三方库的缺失。默认集成了mongoose、TypeOrm、Redis、Graphql、Socket.io，微服务等模块。Nest基于TypeScript编写并且结合了OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的相关理念，为node.js世界带来设计模式和成熟的解决方案。 1.2 安装与启动 全局安装nest—— npm install @nest/cli -g 创建项目—— nest new app-name 创建过程中会让你选择包管理器，npm或者yarn 进入项目—— cd app-name 启动项目—— npm run start 项目默认使用3000端口，打开浏览器输入http://localhost:3000，就可以看到默认的数据了 1.3 入口文件及文件结构 整个项目的入口文件是main.ts，只有8行，利用了nestjs的工厂创建了实例，监听3000端口 一般我们的分包的方式都是相同职责的文件放在一起（比如Egg.js），比如controller包下面都是controller，service包下面都是service，但是在nestjs中，这种方式不如按照功能分包来的方便（login包下面的所有文件都与login功能相关） ├─ app │ ├─ dist // 打包目录 │ ├─ src // 源码 │ │ ├─ main.ts // 入口 │ │ ├─ modules // 业务逻辑代码 │ │ │ └─ login // 跟login相关的代码（controller、service、module等） │ │ └─ app.module.ts // 总的模块组装文件 │ └─ test // 测试相关 1.4 功能DemoController中使用Service中的功能不再需要new一个Service示例，那样既浪费内存，又不容易维护。在NestJS中，使用类似Spring IoC的方式，将service注入到Controller中 以Hello功能为例进行代码演示： 在功能包下的module.ts中实现注入这一操作 import { Module } from &#39;@nestjs/common&#39;; import { HelloController } from &#39;./hello.controller&#39;; import { HelloService } from &#39;./hello.service&#39;; @Module({ imports: [], controllers: [HelloController], providers: [HelloService], }) export class HelloModule {} 在Controller中编写控制器代码 import { Controller, Get, Query } from &#39;@nestjs/common&#39;; import { HelloService } from &#39;./hello.service&#39;; @Controller(&#39;/hello&#39;) export class HelloController { constructor(private readonly helloService: HelloService) {} @Get() hi(@Query() { id }): string { console.log(id); return this.helloService.getHi() + id; } } 可以看到在controller中没有出现任何new的字样，这时候运行代码你会发现 仍然找不到，因为没有在app.module.ts中进行组装，每一个功能就像一个器官，需要在这个文件中进行拼装才能正常工作 到这里答题的流程已经差不多看完了，下面开始详细介绍 2 控制器2.1 创建Controller运行命令 nest g controller hello，可以使用nest自动创建controller文件 2.2 路由通过@Controller注解来创建一级路由，在Controller内部使用@Get、@Post等方法装饰器来创建不同http方法的子路由，例如 @Controller(&#39;/hello&#39;) export class HelloController { constructor(private readonly helloService: HelloService) {} @Get(&#39;hi&#39;) hi(): string { return this.helloService.getHi(); } } 这段代码生成的路由就是/hello/hi，使用GET请求访问 2.3 参数2.3.1 QueryGET请求中一般使用@Query()注解来修饰方法中的参数 @Controller(&#39;/hello&#39;) export class HelloController { constructor(private readonly helloService: HelloService) {} @Get(&#39;hi&#39;) hi(@Query() { id }): string { return this.helloService.getHi() + &#39;——&#39; + id; } } 通过query的形式携带参数 2.3.2 Body在POST请求中一般使用@Body()注解来获取数据 @Post() save(@Body() { message }): string { return &#39;接收到消息:&#39; + message; } 使用http工具发送post请求来测试一下 2.3.3 Headers使用@Headers()注解来获取requestHeader中的数据 @Get(&#39;hi&#39;) hi(@Query() { id }, @Headers() header): string { console.log(header); return this.helloService.getHi() + &#39;——&#39; + id; } 还可以获取某一特定的请求头，比如获取请求中的UA @Get(&#39;hi&#39;) hi(@Query() { id }, @Headers(&#39;user-agent&#39;) UA: string): string { console.log(UA); return this.helloService.getHi() + &#39;——&#39; + id; } 2.3.4 Param@Param()一般用在动态路由，形如：http://localhost:3000/hello/id/123，后面的123是动态的，可以是其他数据 @Get(&#39;id/:id&#39;) getId(@Param() { id }): string { return &#39;接收到ID：&#39; + id; } 2.4 集成swagger文档swaggerAPI文档 运行命令安装swagger npm install @nestjs/swagger swagger-ui-express --save 在main.ts中进行配置 import { NestFactory } from &#39;@nestjs/core&#39;; import { SwaggerModule, DocumentBuilder } from &#39;@nestjs/swagger&#39;; import { AppModule } from &#39;./app.module&#39;; async function bootstrap() { const app = await NestFactory.create(AppModule); const options = new DocumentBuilder() .setTitle(&#39;Nest RESTful API&#39;) .setDescription(&#39;接口文档&#39;) .setVersion(&#39;1.0&#39;) .addBearerAuth() .build(); const document = SwaggerModule.createDocument(app, options); SwaggerModule.setup(&#39;doc&#39;, app, document); await app.listen(3000); } bootstrap(); 然后就可以通过设置的路径去访问了 具体的使用方法见官网文档 3 服务3.1 创建服务可以使用命令行创建服务 nest g service user 运行命令后，nest会自动创建相关文件，并可以自动注册在module中 由创建HelloService服务来示例，首先新建hello.service.ts文件，然后将其定义为provider，使用@Injectable()来修饰 import { Injectable } from &#39;@nestjs/common&#39;; @Injectable() export class HelloService { getHi(): string { return &#39;Hi&#39;; } } @Injectable({scope: Scope.REQUEST})选择作用域 scope名称 说明 SINGLETON 单例模式，整个应用内只存在一份实例 REQUEST 每个请求初始化一次 TRANSIENT 每次注入都会实例化 3.2 依赖注入在Controller的构造函数中通过constructor(private readonly helloService: HelloService) {}来将Service注入到Controller中 乎所有的东西都可以被当作提供者(Provider),比如： service, repository, factory, helper，他们都可以通过constructor 注入依赖关系 可选的依赖项 默认情况下，如果依赖注入的对象不存在会提示错误，中断应用运行，此时可以使用@Optional()来指明选择性注入，但依赖注入的对象不存在时不会发生错误。 @Controller(&#39;users&#39;) export class UserController { constructor(@Optional() private readonly userService:UserService){} } 基于属性的注入 类似于springboot的service注入，不在构造函数中注入，而是作为一个属性 @Controller(&#39;users&#39;) export class UserController { @Inject() private readonly userService:UserService; } 3.3 注册provider编写完的service需要在module中进行注册providers: []，否则无法生效 3.4 导出如果module中的部分文件需要被其他文件依赖，使用exports: []导出 4 中间件 Nest 中间件实际上等价于 express 中间件。 中间件函数可以执行以下任务: 执行任何代码。 对请求和响应对象进行更改。 结束请求-响应周期。 调用堆栈中的下一个中间件函数。 如果当前的中间件函数没有结束请求-响应周期, 它必须调用next()将控制传递给下一个中间件函数。否则, 请求将被挂起。 4.1 自定义中间件编写一个自定义中间件用来打印每个请求的方法 import { Injectable, NestMiddleware } from &#39;@nestjs/common&#39;; import { Request, Response } from &#39;express&#39;; @Injectable() export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: () =&gt; void) { console.log(req.method); next(); } } 然后在app.module.ts中挂载中间件 @Module({ imports: [HelloModule], controllers: [AppController], providers: [AppService], }) export class AppModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) // 应用中间件 .exclude({ path: &#39;hello&#39;, method: RequestMethod.POST }) // 哪些路由和哪些方法不经过中间件 .forRoutes(&#39;hello&#39;); // 中间件服务的路由 } } 5 异常过滤 内置的异常层负责处理整个应用程序中的所有抛出的异常。当捕获到未处理的异常时，最终用户将收到友好的响应。 5.1 编写过滤器需要继承ExceptionFilter，进去看一下接口的结构 需要实现catch方法，接收两个参数：异常和参数主机，然后来编码实现这个接口 import { ArgumentsHost, Catch, ExceptionFilter, HttpException, } from &#39;@nestjs/common&#39;; @Catch(HttpException) export class HttpExceptionFilter implements ExceptionFilter&lt;HttpException&gt; { catch(exception: HttpException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse(); const request = ctx.getRequest(); const status = exception.getStatus(); console.log(exception); const exceptionRes: any = exception.getResponse(); const { error, message } = exceptionRes; response.status(status).json({ status, timestamp: new Date().toISOString(), path: request.url, error, message, }); } } 5.2 挂载全局使用 在main.ts中通过 app.useGlobalFilters(new HttpExceptionFilter()); 来全局挂载过滤器 局部使用 在不同模块的Controller中通过注解添加 @UseFilters(new HttpExceptionFilter()) @Controller(&#39;/hello&#39;) export class HelloController { constructor(private readonly helloService: HelloService) {} /** * 传入ID获取数据 * @param id ID * @param UA user-agent */ @Get(&#39;hi&#39;) @ApiQuery({ name: &#39;id&#39;, required: true }) @ApiResponse({ status: 200, description: &#39;get...&#39;, type: Hello, }) hi(@Query() { id }, @Headers(&#39;user-agent&#39;) UA): string { console.log(UA); if (!id) throw new HttpException( { status: HttpStatus.BAD_REQUEST, message: &#39;参数必填&#39;, error: &#39;id is must&#39;, }, HttpStatus.BAD_REQUEST, ); return this.helloService.getHi() + &#39;——&#39; + id; } } 然后再去访问这个路由，就可以获得格式化的异常 6 管道6.1 内置管道通过路由获取参数时，获取到的值都会是string类型，就像下面代码中 @Get(&#39;id/:id&#39;) @ApiParam({ name: &#39;id&#39;, required: true }) getId(@Param(&#39;id&#39;) id: number): string { console.log(typeof id); return &#39;接收到ID：&#39; + id; } 即使声明了id是number，通过typeof检测仍然打印string 这时候就可以使用内置管道来解决，将代码做如下修改 @Get(&#39;id/:id&#39;) @ApiParam({ name: &#39;id&#39;, required: true }) getId(@Param(&#39;id&#39;, new ParseIntPipe()) id: number): string { console.log(typeof id); return &#39;接收到ID：&#39; + id; } 就可以将路由中获取的参数转换为number类型 管道也可以全局使用，也是在main.ts中使用useGlobalPipe()来挂载全局管道 7 守卫 守卫是一个使用@Injectable()装饰器的类。 守卫应该实现CanActivate接口。 7.1 定义守卫使用注解修饰然后实现接口方法 import { Injectable, CanActivate, ExecutionContext } from &#39;@nestjs/common&#39;; import { Reflector } from &#39;@nestjs/core&#39;; // 反射器 @Injectable() export class Guard implements CanActivate { constructor(private readonly reflector: Reflector) {} canActivate(context: ExecutionContext): boolean { // 使用反射获取到自定义装饰器roles中传入的roles const roles = this.reflector.get&lt;string[]&gt;(&#39;roles&#39;, context.getHandler()); // 如果没有获取到roles，说明不需要守卫 if (!roles) { return true; } const request = context.switchToHttp().getRequest(); const { user } = request.query; return !!roles.find((role) =&gt; role === user); } } 自定义装饰器roles import { SetMetadata } from &#39;@nestjs/common&#39;; // 守卫中通过反射获取这里传入的值 export const Roles = (...roles: string[]) =&gt; SetMetadata(&#39;roles&#39;, roles); 7.2 挂载守卫局部挂载 使用注解@UseGuards()对某一Controller挂载守卫，在需要进行守卫的方法上使用自定义装饰器传入开放权限的角色 @UseFilters(new HttpExceptionFilter()) @UseGuards(RolesGuard) @Controller(&#39;/hello&#39;) export class HelloController { constructor(private readonly helloService: HelloService) {} /** * 传入ID获取数据 * @param id ID * @param UA user-agent */ @Get(&#39;hi&#39;) @ApiQuery({ name: &#39;id&#39;, required: true }) @ApiResponse({ status: 200, description: &#39;get...&#39;, type: Hello, }) @Roles(&#39;admin&#39;) hi(@Query() { id }, @Headers(&#39;user-agent&#39;) UA): string { console.log(UA); if (!id) throw new HttpException( { status: HttpStatus.BAD_REQUEST, message: &#39;参数必填&#39;, error: &#39;id is must&#39;, }, HttpStatus.BAD_REQUEST, ); return this.helloService.getHi() + &#39;——&#39; + id; } } 挂在守卫之后只有user的值为admin时才会获取到数据 正常的业务中不可能使用明文来判断权限 全局挂载 app.useGlobalGuards(new RolesGuard()); 8 配置文件集中管理8.1 邮件服务的配置集中管理 使用到的npm包：@nestjs-modules/mailer nodemailer ！！！注意是@nestjs-modules，@nest-modules会报错 准备工作：获取邮箱授权码，QQ邮箱示例 8.1.1 编写邮件服务email.controller.ts @Controller(&#39;/email&#39;) @UseFilters(new HttpExceptionFilter()) export class EmailController { constructor(private readonly emailService: EmailService) {} @Get(&#39;send&#39;) @ApiTags(&#39;email&#39;) @ApiQuery({ name: &#39;email&#39;, required: true }) send(@Query(&#39;email&#39;) email: string): string { if (!email) { throw new HttpException( { status: HttpStatus.BAD_REQUEST, message: &#39;参数必填&#39;, error: &#39;email is must&#39;, }, HttpStatus.BAD_REQUEST, ); } this.emailService.sendEmail(email); return &#39;ok&#39;; } } email.service.ts @Injectable() export class EmailService { constructor(private readonly mailerService: MailerService) {} sendEmail(email: string): void { this.mailerService.sendMail({ to: email, from: &#39;1984779164@qq.com&#39;, subject: &#39;email test&#39;, template: &#39;welcome&#39;, // html: &#39;&lt;h1&gt;Welcome&lt;/h1&gt;&#39;, }); } } 这里面的html是直接发送的，template需要编译，在打包之后的dist目录下可能会找不到文件，需要在nest-cli.json文件中添加配置项 { &quot;collection&quot;: &quot;@nestjs/schematics&quot;, &quot;sourceRoot&quot;: &quot;src&quot;, &quot;compilerOptions&quot;: { &quot;assets&quot;: [&quot;template/**/*&quot;] } } email.module.ts @Module({ imports: [], controllers: [EmailController], providers: [EmailService], }) export class EmailModule {} app.module.ts @Module({ imports: [ MailerModule.forRootAsync({ useFactory: () =&gt; ({ transport: &#39;smtps://1984779164@qq.com:XXXXX@smtp.qq.com&#39;, // XXXX-&gt;邮箱授权码 defaults: { from: &#39;&quot;nest-modules&quot; &lt;modules@nestjs.com&gt;&#39;, }, template: { dir: path.join(__dirname, &#39;./template/email&#39;), adapter: new PugAdapter(), options: { strict: true, }, }, }), }), HelloModule, EmailModule, ], controllers: [AppController], providers: [AppService], }) export class AppModule {} 在swagger中测试 然后就可以收到邮件了 8.1.2 提取配置项虽然功能实现了，但是配置直接放在代码中不仅会显得特别臃肿（还有其他的配置如数据库等），而且不易于管理，那么下面我们就来提取配置项来集中管理 需要使用的包：nestjs-config 安装完npm包之后，在app.module.ts同级目录下创建config文件夹，一定要在同级目录，然后新建email.ts文件，将刚才app.modules.ts中的有关邮件的配置信息复制过来 export default { transport: &#39;smtps://1984779164@qq.com:qwwsvgcvmjuedhbj@smtp.qq.com&#39;, defaults: { from: &#39;&quot;nest-modules&quot; &lt;modules@nestjs.com&gt;&#39;, }, template: { dir: join(__dirname, &#39;../template/email&#39;), adapter: new PugAdapter(), options: { strict: true, }, }, }; 将app.module.ts中的配置做如下修改 @Module({ imports: [ ConfigModule.load(resolve(__dirname, &#39;config&#39;, &#39;**/!(*.d).{ts,js}&#39;)), MailerModule.forRootAsync({ useFactory: (config: ConfigService) =&gt; config.get(&#39;email&#39;), inject: [ConfigService], }), HelloModule, EmailModule, ], controllers: [AppController], providers: [AppService], }) export class AppModule {} 导入ConfigModule模块，然后向MailerModule中注入ConfigService，然后使用传入的service来获取配置文件 大功告成！！！ 8.2 数据库配置集中管理nest提供了orm映射 使用到的包： @nestjs/typeorm typeorm mysql 首先需要在app.module.ts中注册TypeOrmModule，已经有了上面的例子，这次我们直接创建配置文件database.ts export default { type: &#39;mysql&#39;, host: &#39;localhost&#39;, port: 3306, username: &#39;liuhao&#39;, password: &#39;123456&#39;, database: &#39;nest&#39;, entities: [join(__dirname, &#39;../&#39;, &#39;**/**.entity{.ts,.js}&#39;)], synchronize: true, }; 然后在app.module.ts中添加配置 TypeOrmModule.forRootAsync({ useFactory: (config: ConfigService) =&gt; config.get(&#39;database&#39;), inject: [ConfigService], }), 然后编写controller @Controller(&#39;users&#39;) @ApiTags(&#39;users&#39;) export class UsersController { constructor(private readonly usersService: UsersService) {} @Get(&#39;all&#39;) getAll() { return this.usersService.findAll(); } @Post(&#39;save&#39;) async createOne(@Body() user: User) { await this.usersService.create(user); return true; } } 还有service @Injectable() export class UsersService { constructor( @InjectRepository(UsersEntity) private readonly usersRepository: Repository&lt;UsersEntity&gt;, private connection: Connection, ) { /** * 查询所有用户 */ async findAll(): Promise&lt;UsersEntity[]&gt; { return await this.usersRepository.find(); } /** * 创建用户 * @param user 用户实体 */ async create(user): Promise&lt;UsersEntity[]&gt; { const { username } = user; const u = await getRepository(UsersEntity).findOne({ where: { username } }); if (u) { throw new HttpException( { message: &#39;Input data validation faild&#39;, error: &#39;name must unique&#39;, }, HttpStatus.BAD_REQUEST, ); } return await this.usersRepository.save(user); } } user的实体也需要我们来配置，用实体来对应数据库的表结构——TypeORM文档 @Entity() export class UsersEntity { @PrimaryGeneratedColumn() id: number; @Column({ length: 255 }) username: string; @Column({ length: 255 }) password: string; } 最后一步我们需要在module中注入service和entity @Module({ imports: [TypeOrmModule.forFeature([UsersEntity])], providers: [UsersService], exports: [UsersService], controllers: [UsersController], }) export class UsersModule {} 然后就可以在swagger中测试我们的代码 然后在数据库可视化界面看一下 一个简单的数据库操作就完成了 9 简易服务监控 使用到的npm包：nest-status-monitor @nestjs/platform-socket.io 安装完之后在config目录下创建status.ts文件 export default { pageTitle: &#39;Nest.js Monitoring Page&#39;, port: 3000, path: &#39;/status&#39;, ignoreStartsWith: &#39;/health/alive&#39;, spans: [ { interval: 1, // Every second retention: 60, // Keep 60 datapoints in memory }, { interval: 5, // Every 5 seconds retention: 60, }, { interval: 15, // Every 15 seconds retention: 60, }, ], chartVisibility: { cpu: true, mem: true, load: true, responseTime: true, rps: true, statusCodes: true, }, healthChecks: [], }; 在app.module.ts中引入配置文件，由于该包未实现注入，所以直接添加就行了 StatusMonitorModule.setUp(statusMonitorConfig), StatusMonitorModule是从包中导入的方法，statusMonitorConfig是我们写的配置文件 10 JWT（json web token） 用到的包：@nestjs/passport passport passport-local @nestjs/jwt passport-jwt 本示例仅是模仿登录，真正的登录业务需要配合数据库 先看一下要用到的文件 代码就不在这贴出来了，主要说一下逻辑 首先从controller开始看 controller中有两个方法，一个是登录，另一个是登陆之后获取信息，两个方法用到了两个不同的守卫（策略模式），一个是未登录时获取token，另一个是登陆之后通过token获取数据 这两个策略中（左边是local，右边是jwt） 1.local策略做的事是获取到用户名密码，通过注入的authService中的验证方法来验证用户名是否存在和用户名密码是否匹配，验证通过后返回user实体，否则抛出异常； authService controller中再使用获取到的user实体调用authService中的login方法注册一个token然后返回 在auth.module.ts中进行注册token的配置 2.jwt策略做的事是从request的header中获取token值，然后检验token的合法性，再从token中解析信息返回","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"JavaScript中的数组遍历方法","slug":"技术/JavaScript中的数组遍历方法","date":"2020-11-23T00:08:47.874Z","updated":"2020-11-23T00:10:09.402Z","comments":true,"path":"2020/11/23/技术/JavaScript中的数组遍历方法/","link":"","permalink":"https://easyremember.cn/2020/11/23/技术/JavaScript中的数组遍历方法/","excerpt":"","text":"forEach对数组元素进行指定操作，不改变数组 const arr = [1, 2, 3, 5, 4] arr.forEach((item) =&gt; { console.log(item+1); }) map返回操作后的新数组（不会改变原数组） const arr = [1, 2, 3, 5, 4] const arr2 = arr.map((item) =&gt; { return item * 2 }) console.log(arr2); sort根据指定规则进行数组项的排序（会改变原数组） const arr = [1, 2, 3, 5, 4] arr.sort((a, b) =&gt; { return a - b }) console.log(arr); reduce归并，将数组的所有元素按照指定规则计算出一个值 const arr = [1, 2, 3, 5, 4] const sum = arr.reduce((a, b) =&gt; { return a + b }) console.log(sum); 第一次遍历时a是数组的第一项，b是数组第二项，第二次遍历开始，a就变成了上一次遍历的返回值 every测试所有的数组元素是否可以通过指定的测试 const arr = [1, 2, 3, 5, 4] const isNotZero = arr.every((item) =&gt; { return item !== 0 }) console.log(isNotZero); filter从数组中过滤出符合要求的数组项 const arr = [1, 2, 3, 5, 4] const bigThanThree = arr.filter((item) =&gt; { return item &gt; 3 }) console.log(bigThanThree);","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"记一次文件上传的曲折历史","slug":"技术/记一次文件上传","date":"2020-11-08T02:25:12.454Z","updated":"2020-11-08T02:28:00.840Z","comments":true,"path":"2020/11/08/技术/记一次文件上传/","link":"","permalink":"https://easyremember.cn/2020/11/08/技术/记一次文件上传/","excerpt":"","text":"记一次文件上传的曲折历史工具 Vue element-UI spark-md5 axios 需求上传pdf文件，为了节省时间，对文件进行切片处理，对上传进度进行监控（这里挺有趣） 实现过程1 文件切片思路：使用了File.slice()对文件进行切片处理，将每一份切片放到一个数组中，然后使用Array.map()方法配合axios将每一段切片上传至服务器 HTML主体（pug） el-upload( ref=&quot;resource&quot;, drag :file-list=&quot;resourcefileList&quot;, :before-upload=&quot;resourceBeforeUpload&quot;, accept=&quot;.pdf&quot;, :limit=&quot;1&quot;, action=&quot;&quot;, :http-request=&quot;customUpload&quot;, :on-remove=&quot;removeList&quot; ) i.el-icon-upload .el-upload__text 将文件拖到此处，或 em 点击上传 使用element-ui的upload组件，使用自定义事件 http-request，在customUpload中对文件进行操作 customUpload(content) { // 覆盖默认上传事件 let file = content.file if (!file) return // 将切片固定成10分，也可以固定大小上传 let axiosArray = [] let chunkList = [] let chunkSize = file.size / 10 let current = 0 let fileName = this.formData.identity + &#39;.pdf&#39; while (current &lt; 10) { chunkList.push({ chunk: file.slice(current * chunkSize, (current + 1) * chunkSize), fileName: current + &quot;-&quot; + fileName }) current++ } // 初始化数据 this.percentage = [0,0,0,0,0,0,0,0,0,0] this.uploadOver = false this.progressVisable = true // 切片并发传给后端，要注意切片上传时请求头是 multipart/form-data 合并切片时请求头是x-www-form-urlencoded，只能上传键值对 chunkList.map((item) =&gt; { const index = parseInt(item.fileName.split(&#39;-&#39;)[0]) let form = new FormData() form.append(&quot;file&quot;, item.chunk, item.fileName) form.append(&quot;fileName&quot;, this.formData.identity) axiosArray.push( this.$http.post(&quot;/upload/part&quot;, form, { headers: { &quot;Content-Type&quot;: &quot;multipart/form-data&quot; }, }).then(res=&gt; { res // this.percentage += 10 }) ) }) // 所有切片上传成功后合并 Promise.all(axiosArray).then(res =&gt; { res this.$http.get(`/upload/merge?fileName=${this.formData.identity}`).then(res =&gt; { if(res) { // console.log(res); // this.progressVisable = false this.formData.resource = res.data.obj this.uploadOver = true this.overContent = &#39;上传成功，感谢支持&#39; } }).catch(err =&gt; { err this.uploadOver = true this.overContent = &#39;传输失败，请重试&#39; }) }) }, 这段代码应该很清楚明白了，代码中的identity是文件的MD5值，利用spark-md5计算，目的是为了防止重复文件的上传，计算方法如下 computeMd5(file) { // 计算文件MD5 const fread = new FileReader() const spark = new SparkMD5.ArrayBuffer() return new Promise((resolve, reject) =&gt; { if(!file) { reject(&#39;no file&#39;) } fread.readAsArrayBuffer(file) fread.onload = (e) =&gt; { spark.append(e.target.result) const md5 = spark.end() resolve(md5) } }) }, 这里有一个小插曲，fread.onload是一个异步函数，所以在计算md5值的时候会出现null的情况，这里返回一个Promise，配合调用时的async/await实现同步操作 2 进度条实现原始思路：一共分了10片，每一片上传成功后将进度+10，所有文件上传完成之后就是100%了（你可能一眼看出了这里面的问题，所以我说的原是思路） 问题分析：由于http请求是并行的，所以，看图 上一秒所有的都没完成，进度一直卡在0%，下一秒所有的请求同时完成，瞬间进度100%，进度条俨然成了摆设 新思路：利用axios的onUploadProgress方法，创建一个长度为10的进度数组，然后更改对应的进度数据，利用computed计算属性返回10个分片进度的和 代码实现： chunkList.map((item) =&gt; { const index = parseInt(item.fileName.split(&#39;-&#39;)[0]) let form = new FormData() form.append(&quot;file&quot;, item.chunk, item.fileName) form.append(&quot;fileName&quot;, this.formData.identity) axiosArray.push( this.$http.post(&quot;/upload/part&quot;, form, { headers: { &quot;Content-Type&quot;: &quot;multipart/form-data&quot; }, onUploadProgress: (e) =&gt; { this.$set(this.percentage, index , e.loaded / e.total * 10 | 0) } }) ) }) 这里注意，computed并不能直接监听数组的响应式，需要使用$set这个API来设置元素的值，参数是（数组，下标，新的值） 上面计算的MD5值出了用于鉴别重复文件还可以用来实现秒传功能，两个文件的MD5相同那就表示是同一个文件，直接告诉用户上传完成，其实就是“欺骗用户”","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"uni-app学习笔记（入门）","slug":"笔记/uni-app学习笔记","date":"2020-11-06T08:42:39.312Z","updated":"2020-11-23T00:27:59.626Z","comments":true,"path":"2020/11/06/笔记/uni-app学习笔记/","link":"","permalink":"https://easyremember.cn/2020/11/06/笔记/uni-app学习笔记/","excerpt":"","text":"1 uni-appuni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。 1.1 创建项目安装HBuildX IDE，文件-&gt;新建-&gt;项目，然后选择uni-app项目即可 要打包小程序或APP等需要安装相应的开发者工具，不多介绍，百度即可 1.2 项目目录 1.3 pages.jsonpages字段下配置页面，第一项为启动页 path：页面文件路径 style：配置页面窗口表现 globalStyle配置全局标题样式（page中的样式优先于全局） 参考官网介绍 tabBar指定 tab 栏的表现 list：数组，tab 的列表，详见 list 属性说明，最少2个、最多5个 tab 样式等设置见文档 condition直达模式（仅用于开发模式） 相当于微信开发工具中的自定义编译模式 1.4 uni-app生命周期应用生命周期 应用生命周期仅可在App.vue中监听，在其它页面监听无效。 页面生命周期 2 模板语法Vue的语法，在此不赘述 3 uni-app组件3.1 基础组件view：相当于HTML中的div scroll-view：无限滚动组件 swiper：滑块视图容器，比如轮播图 3.2 表单组件官网文档，表单组件 3.3 导航与传参navigator，进行页面跳转 属性名 类型 默认值 说明 url String 应用内的跳转链接，值为相对路径或绝对路径，如：”../first/first”，”/pages/first/first”，注意不能加 .vue 后缀 open-type String navigate 跳转方式 delta Number 当 open-type 为 ‘navigateBack’ 时有效，表示回退的层数 animation-type String pop-in/out 当 open-type 为 navigate、navigateBack 时有效，窗口的显示/关闭动画效果，详见：窗口动画 animation-duration Number 300 当 open-type 为 navigate、navigateBack 时有效，窗口显示/关闭动画的持续时间。 hover-class String navigator-hover 指定点击时的样式类，当hover-class=”none”时，没有点击态效果 hover-stop-propagation Boolean false 指定是否阻止本节点的祖先节点出现点击态 hover-start-time Number 50 按住后多久出现点击态，单位毫秒 hover-stay-time Number 600 手指松开后点击态保留时间，单位毫秒 target String self 在哪个小程序目标上发生跳转，默认当前小程序，值域self/miniProgram open-type： navigate：保留当前页面，跳转页面 redirect：关闭当前页面，跳转页面 switchTab：跳转到tabBar页面 reLaunch：关闭所有页面，打开目标 navigateBack：返回上层 exit：退出小程序，target=”miniProgram”时生效 传参通过url中的request.query方法传递参数（switchTab无法使用） 4 API4.1 网络uni.request()，发送http请求，接收一个对象参数，包括url，请求方式，发送的数据，成功的响应等 示例 uni.request({ url: &#39;https://www.example.com/request&#39;, //仅为示例，并非真实接口地址。 data: { text: &#39;uni.request&#39; }, header: { &#39;custom-header&#39;: &#39;hello&#39; //自定义请求头信息 }, success: (res) =&gt; { console.log(res.data); this.text = &#39;request success&#39;; } }); 4.2 页面跳转与路由与navigator组件中的每个mode功能对应，也就是说，有两种方法可以实现路由跳转（使用navigator组件和触发事件） uni.navigateTo uni.redirectTo uni.reLaunch uni.switchTab uni.navigateBack uni.preloadPage 4.3 数据缓存带有sync的是同步接口，接收键值对；异步接口接收的是Object，除了键值之外还包括成功的回调函数，失败的回调函数，调用结束的回调函数 uni.setStorage（设置缓存） uni.setStorageSync uni.getStorage（读取缓存） uni.getStorageSync uni.getStorageInfo（获取所有的缓存） uni.getStorageInfoSync uni.removeStorage（移除某个缓存） uni.removeStorageSync uni.clearStorage（清除所有缓存） uni.clearStorageSync 4.4 媒体相关图片属性说明 示例代码 readImage() { uni.chooseImage({ success(res) { uni.getImageInfo({ src: res.tempFilePaths[0], success(img) { console.log(img.width, img.height); } }) } }) } 代码中使用了两个api组合，选择图片和获取图片信息，选择图片成功返回的结果是两个数组，本地文件路径列表和本地文件列表，每一项是一个File 点击选择图片，选中图片点击确认 然后就可以看到宽高信息","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"点击按钮显示评论框点击其他部位隐藏","slug":"随想/点击按钮显示评论框点击其他部位隐藏","date":"2020-10-19T03:52:21.818Z","updated":"2020-10-19T03:53:29.368Z","comments":true,"path":"2020/10/19/随想/点击按钮显示评论框点击其他部位隐藏/","link":"","permalink":"https://easyremember.cn/2020/10/19/随想/点击按钮显示评论框点击其他部位隐藏/","excerpt":"","text":"点击按钮显示评论框点击其他部位隐藏1. 使用纯点击事件（适合多个输入框）点击按钮触发显示事件，修改输入框的状态为显示；在最外层div添加关闭事件，点击其他部位触发关闭事件（需要使用阻止冒泡来中断） .review(@click=&quot;hiddenForm&quot;) el-button(type=&#39;submit&#39;, @click.stop=&quot;showForm&quot;) 显示 .red(v-if=&quot;isShowForm&quot;,@click.stop=&quot;showForm&quot;) el-input 显示隐藏方法如下（isShowForm是显示隐藏标记） methods: { showForm() { // 显示评论框 this.isShowForm = true }, hiddenForm() { // 隐藏评论框 this.isShowForm = false } }, hiddenForm方法在真正使用中 需要绑定到最外层app，否则只会在当期区域生效，如下效果图中当鼠标点击其他部位时不会触发隐藏事件 2. 使用焦点触发隐藏（适合单个输入框）触发显示事件时聚焦到输入框，当失去焦点时触发隐藏事件（好处是不需要在最外层绑定隐藏事件，但是需要阻止失去焦点） .review el-button(type=&#39;submit&#39;, @click.stop=&quot;showForm&quot;) 显示 .red(v-if=&quot;isShowForm&quot;, @mousedown.prevent) el-input(ref=&quot;in&quot;, @blur=&quot;hiddenForm&quot;, @mousedown.stop) el-button(@click=&quot;submit&quot;) click 显示隐藏事件 showForm() { // 显示评论框 if(!this.isShowForm) { this.isShowForm = true this.$nextTick(() =&gt; { this.$refs.in.focus() }) } }, hiddenForm() { // 隐藏评论框 this.isShowForm = false }, submit() { console.log(1); this.$refs.in.blur() } 点击当前div不失去焦点，点击按钮执行事件并隐藏输入框","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"右键在此打开终端","slug":"资源/添加右键菜单","date":"2020-10-07T05:28:25.937Z","updated":"2020-10-07T05:31:27.345Z","comments":true,"path":"2020/10/07/资源/添加右键菜单/","link":"","permalink":"https://easyremember.cn/2020/10/07/资源/添加右键菜单/","excerpt":"","text":"在文件夹中打开终端至当前位置最快捷的方法是按住shift点击鼠标右键，但是程序员都是懒的，我就不想按住shift，于是我想到了通过注册表添加右键菜单 先看下效果 下面开始干活 添加注册表选项按下组合键Win+R，输入regedit，回车 然后找到这个目录 HKEY_CLASSES_ROOT\\Directory\\Background\\shell，然后右键shell文件新建项，命名“在此打开Terminal”（这个随意，根据个人喜好），然后在刚才新建的项上面再新建项，命名“command”（这个不能随意了） 点击“command”看到右边有一个“默认”，右键选择修改，添加数据为 cmd /c set CURRENT_PATH=&quot;%V&quot; &amp; start C:\\Users\\刘浩\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe 注意这里，后面的路径要是你电脑上的terminal路径 确定之后去看一下你的右键就会发现已经有了这个菜单项 爱美之心——图标如果你不满足于此，想带上图标，那也是可以实现滴，首先准备一个最小32*32的ico图标文件 点击刚才出创建的菜单项“在此打开Terminal”（不是最下面的command），右键新建字符串值，命名Icon，值就是你刚才准备好的图标地址（建议放在不会被清理掉的地方），然后再去看一下你的右键菜单，真香","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"JavaScript自动化测试框架——Jest","slug":"笔记/前端测试工具Jest","date":"2020-09-27T07:24:18.018Z","updated":"2020-09-28T02:06:52.639Z","comments":true,"path":"2020/09/27/笔记/前端测试工具Jest/","link":"","permalink":"https://easyremember.cn/2020/09/27/笔记/前端测试工具Jest/","excerpt":"","text":"开始安装运行命令安装Jest npm install --save-dev jest # 或 yarn add --dev jest 简单的示例sum.js function sum(x, y) { return x + y; } module.exports = sum; sum.test.js const sum = require(&#39;../code/sum&#39;); test(&#39;adds 1 + 2 to equal 3&#39;, () =&gt; { expect(sum(1, 2)).toBe(3); }); 在package.json中添加脚本命令 &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot; }, 然后运行 npm run test 测试通过，实际结果跟预期结果相同，然后把预期结果修改一下再来看 提示期望值跟实际值不相符。现在已经写完了第一个测试文件 运行单个测试文件是使用jest /path/code.test.js，注意这里斜杠的方向，不能是反斜杠 让Jest支持ES6Jest只支持CommenJS模块化语法，使用Babel让Jest支持ES6语法 npm install @babel/core @babel/preset-env --save-dev 然后创建babel配置文件.babelrc { &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;node&quot;: &quot;current&quot; } } ] ] } 匹配器通用匹配器测试值的最简单方法是完全相等，就像上面的小示例一样。toBe用于测试基础类型完全相等，检查对象的值需要使用toEqual来递归检查每个字段 test(&#39;equal object&#39;, () =&gt; { const data = {one: 1}; data[&#39;two&#39;] = 2; expect(data).toEqual({ a: 1, b: 2 }) }) 使用not来测试不等于 test(&#39;adds 1 + 2 is not 3&#39;, () =&gt; { expect(sum(1, 2)).not.toBe(4); }); 真理使用真理测试underfined、null和false toBeNull仅匹配null toBeUndefined仅匹配undefined toBeDefined是相反的toBeUndefined toBeTruthy匹配任何语句视为 true 的语句if toBeFalsy匹配任何语句视为错误的内容if 例如 test(&#39;null&#39;, () =&gt; { const n = null; expect(n).toBeNull(); }); 数字比较数字的匹配器方法 toBeGreaterThan大于 toBeGreaterThanOrEqual大于等于 toBeLessThan小于 toBeLessThanOrEqual小于等于 toBe等于 toEqual等于 toBeCloseTo等于（用于浮点数，比如0.1+0.2） test(&#39;adds 1 + 2&#39;, () =&gt; { expect(sum(1, 2)).toBeGreaterThan(2); expect(sum(1, 2)).toBeGreaterThanOrEqual(3); expect(sum(1, 2)).toBeLessThan(4); expect(sum(1, 2)).toBeLessThanOrEqual(3); }); 字符串使用toMatch匹配正则表达式 test(&#39;match str&#39;, () =&gt; { const str = &#39;zhangsan@qq.com&#39; expect(str).toMatch(/^(([^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/) }) 数组使用toContain来检查数组是否包含特定项 test(&#39;array&#39;, () =&gt; { const arr = [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;] expect(arr).toContain(&#39;lisi&#39;) }) 异常使用toThrow来测试函数调用时是否会引发错误 function compileAndroidCode() { throw new Error(&#39;have error&#39;); } test(&#39;compiling android goes as expected&#39;, () =&gt; { expect(compileAndroidCode).toThrow(Error); }); 更多详细API见官网文档 测试异步代码有三种当时测试异步代码，回调、promise和等待（async/await） callback异步操作如下 function asyncFun(callback) { const str = &#39;test&#39; setTimeout(() =&gt; { callback(str) }, 1000) } 测试代码如下 test(&#39;async function&#39;, (done) =&gt; { function callback(data) { try { expect(data).toBe(&#39;test&#39;); done(); } catch (error) { done(error); } } asyncFun(callback) }) 将测试代码作为回调函数传入被测程序，当异步任务执行完成时调用callback来测试 promisepromise的一部测试较为简单只需要用.then或者.catch来捕获异步返回值即可 // async.js function asyncFun() { return Promise.resolve(&#39;test&#39;) } module.exports = asyncFun; // async.test.js test(&#39;promise test&#39;, () =&gt; { return asyncFun().then(data =&gt; { expect(data).toBe(&#39;test&#39;) }) }); promise必须要返回，否则测试将在解析promise之前完成；如果要测试拒绝的结果使用catch代替then async/await如同在js代码中使用async/await组合一样，声明函数async，然后赋值时使用await修饰，假设有一个异步任务asyFun返回一个字符串this is a async function，则测试代码可以这样写 test(&#39;test asyFun&#39;, async () =&gt; { const data = await asyFun(); expect(data).toBe(&#39;this is a async function&#39;); }); 使用预期断言（expect.assertions(number)）来验证是否完成了一定数量的异步代码测试 生命周期钩子 beforeAll()：所有的测试用例执行之前 beforeEach()：每一个测试用例执行之前 afterAll()：所有的测试用例执行完成之后 afterEach()：每一个测试用例执行完成之后 来看具体测试代码，一看就懂 beforeAll(() =&gt; { console.log(&#39;测试开始之前&#39;); }) afterAll(() =&gt; { console.log(&#39;所有的测试用例执行完成&#39;); }) beforeEach(() =&gt; { console.log(&#39;马上开始执行测试用例&#39;); }) afterEach(() =&gt; { console.log(&#39;执行完一个测试用例&#39;); }) test(&#39;promise test&#39;, () =&gt; { return asyncFun().then(data =&gt; { console.log(`测试用例的data:${data}`); expect(data).toBe(&#39;test&#39;) }) }); test(&#39;promise test not ‘dev’&#39;, () =&gt; { return asyncFun().then(data =&gt; { console.log(`测试用例的data:${data}`); expect(data).not.toBe(&#39;dev&#39;) }) }); 运行结果","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Sass学习笔记","slug":"笔记/Sass学习笔记","date":"2020-09-23T09:24:16.818Z","updated":"2020-09-23T09:25:20.131Z","comments":true,"path":"2020/09/23/笔记/Sass学习笔记/","link":"","permalink":"https://easyremember.cn/2020/09/23/笔记/Sass学习笔记/","excerpt":"","text":"sass跟scss基本相同，区别在于sass去掉了分号和大括号，用缩进来区分样式表，而scss保留了大括号和分号 为了便于阅读，本篇使用scss形式 1 变量1-1 声明变量&amp;引用变量使用$来声明变量，引用时直接填入声明的变量名，如 $titlefont-size: 20px; .title{ font-size: $titlefont-size } // 编译后 .title { font-size: 20px; } 2 嵌套规则按照html文档内容的层级关系来编写样式表，与less语法一致，比如有如下的html文档 &lt;div class=&quot;article&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;h2&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 如果直接对h2或p的样式直接修改，会影响到全部的h2和p标签样式，如果按照层级去编写就会嵌套很长的选择器，在sass中 .article { .title { h2 { color: red; } } .content { p { font-size: 17px; } } } 就可以自动编译出嵌套的选择器 2-1 父元素选择器使用&amp;选择父元素，跟less也是一样的，主要用于伪类选择器 .father { p { color: red; } &amp;:hover { cursor: pointer; } } // 可以将伪类选择器直接追加到父类选择器后面 .father p { color: red; } .father:hover { cursor: pointer; } 2-2 群组选择器使用,进行群组嵌套，如 .container { h1, h2, h3 { color: red; } } // 会把内容展开分别嵌套 .container h1, .container h2, .container h3 { color: red; } 2-3 子组合，同层组合选择器使用&gt;选择元素的直接子元素，使用+选择紧跟在对照选择器后面的目标选择器，使用~选择同层全体 .father { &gt; .son { color: red; } + father2 { color: yellow; } ~ fathers { color: black; } } 2-4 属性嵌套可以使用-来组合属性，如 section { border: { style: solid; width: 1px; color: red; } } // 编译后如下 section { border-style: solid; border-width: 1px; border-color: red; } 你可能会觉得这没有什么，直接使用border属性可以组合三种属性，别急，继续看，他还能这么组合 section { border: solid 1px red { left: 0; right: 0; } } // 编译后 section { border: solid 1px red; border-left: 0; border-right: 0; } 3 导入文件使用@import导入导入外部样式，sass和scss后缀名可省略 3-1 默认变量重复声明一个变量后边的赋值会覆盖前面的变量，在导入文件时可能会被定义的样式覆盖，可以使用默认变量值!default声明变量 3-2 嵌套导入.blue-theme {@import &quot;blue-theme&quot;} //生成的结果跟scss文件的内容完全一样 .blue-theme { aside { background: blue; color: #fff; } } 4 注释有两种注释方式，一种会编译到css文件，一种不会被编译 body { color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */ } 5 混合使用@mixin声明一段代码，然后使用@include来提取这段代码 6 继承使用@extend继承一段已经写好的css样式","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"https://easyremember.cn/tags/css/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"函数式编程思想之柯里化","slug":"技术/函数式编程思想之柯里化","date":"2020-09-20T08:33:44.542Z","updated":"2020-09-20T08:34:46.790Z","comments":true,"path":"2020/09/20/技术/函数式编程思想之柯里化/","link":"","permalink":"https://easyremember.cn/2020/09/20/技术/函数式编程思想之柯里化/","excerpt":"","text":"接下来马上开始WWH（what，why，how） W——什么是柯里化 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。 ——百度百科《柯里化》 下面说一点人话 用cfn(1)(2)(3)来实现fn(1,2,3)的效果 W——为什么要柯里化 把一个抽象函数（即只知道参数列表和返回类型的函数模版）作为参数送给另一个函数。这样实现了调用和实现的分离 解决了某些方法只接受一个参数的问题 H——怎么实现柯里化重头戏开始 先来看一个简单的二元函数转一元函数的示例 // 接收一个函数，返回一个柯里化的函数 function curry(fn) { return function (x) { return function (y) { return fn(x, y) } } } function add(x, y) { return x + y } const cAdd = curry(add) console.log(&#39;add方法-&#39; + add(1, 2)); console.log(&#39;cAdd方法-&#39; + cAdd(1)(2)); 类似于在z=x+y中，先确定了x的值，然后下一步把y带入，计算出结果 再来看一个实际一点的用法 const arr = [ { name: &#39;zhangsan&#39;, age: 12 }, { name: &#39;lisi&#39;, age: 12 }, { name: &#39;wangwu&#39;, age: 12 }, ] const getObj = (name, item) =&gt; { return item.name === name } const cfn = curry(getObj) // console.log(cfn(&#39;lisi&#39;).toString()); let result = arr.filter(cfn(&#39;lisi&#39;)) console.log(result); 这段代码中首先定义了一个对象数组，然后使用数组的filter方法来获取某个对象，getObj方法接收两个参数，返回一个boolean值，柯里化之后只需要接收一个参数，因为是在filter函数的回调函数中，所以会自动将数组中的每一项作为参数执行回调函数 这里可能会很难绕出来，打印一下cfn(&#39;lisi&#39;)看一下 可以看到cfn(&#39;lisi&#39;)就只是一个函数，参数y就是filter遍历时的item 这只是二元柯里化，那我要是好多参数怎么办，再写一个？几个参数套几层闭包？ 当然有一劳永逸的方法 function curry(fn) { const length = fn.length; const curryFn = (args) =&gt; (arg) =&gt; { const curryArgs = args.concat(arg); if (curryArgs.length === length) { return fn(...curryArgs); } return curryFn(curryArgs); } return curryFn([]); } 试一下 GOOD！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"重新认识replace","slug":"技术/replace：重新认识一下呗","date":"2020-09-19T06:48:45.777Z","updated":"2020-09-19T06:56:45.931Z","comments":true,"path":"2020/09/19/技术/replace：重新认识一下呗/","link":"","permalink":"https://easyremember.cn/2020/09/19/技术/replace：重新认识一下呗/","excerpt":"","text":"序言以前从来没有发现replace的强大之处，偶然间发现了这个“宝藏API”，写一篇来“纪念”一下 （其实是脑子不好使怕忘了） 循序渐进，先来 普通的字符串普通字符串就通过简单地匹配进行替换就可以了，我原本以为replace就是这个用处 const str = &#39;Hello world&#39; const newStr = str.replace(/Hello/, &#39;Hi&#39;) console.log(newStr); $标记 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的内容。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始 $n：表示从左到右，正则子表达式（组）匹配到的文本 const str = &#39;import Vue from &quot;vue&quot;&#39; const newStr = str.replace(/ from [&#39;|&quot;]([^&#39;&quot;]+)[&#39;|&quot;]/, ` from &quot;/@modules/${&#39;$1&#39;}&quot;`) console.log(newStr); 函数replace的第二个参数可以是函数，这是最“骚”的地方 const str = &#39;abcde&#39; const newStr = str.replace(/(a)(b)(c)/, (s1, s2, s3, s4, s5) =&gt; { console.log(s1); console.log(s2); console.log(s3); console.log(s4); console.log(s5); return s4+s3+s2 }) console.log(newStr); 解读一下：replace第一个参数是正则式，匹配到了a,b,c，然后第二个函数的参数分别是： 假设一共匹配了n个子串 param 1：匹配到的字符串 param 2：匹配到的第一个子串 param 3：匹配到的第二个子串 ······ param n+1：匹配到的第n个子串 param n+2：匹配到的字符串在原字符串的位置 param n+3：原始字符串","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"vite运行原理","slug":"技术/vite运行原理","date":"2020-09-19T05:02:52.481Z","updated":"2020-09-19T05:05:11.631Z","comments":true,"path":"2020/09/19/技术/vite运行原理/","link":"","permalink":"https://easyremember.cn/2020/09/19/技术/vite运行原理/","excerpt":"","text":"现代的浏览器都支持es6的import了，执行import XX from &#39;./xxx&#39;（script标签type=”module”）会发起一个网络请求，vite拦截这个请求去做vue去编译、解析。实现按需加载，不用打包，启动时间和更新大大缩短 与vue-cli的区别： vue-cli基于webpack；vite基于rollup toy-vite加载html第一步首先开启一个代理服务器，使用express和koa都行，这里选择使用koa npm install koa --save 然后开启监听，加载html const fs = require(&#39;fs&#39;) const path = require(&#39;path&#39;) const Koa = require(&#39;koa&#39;) const app = new Koa() app.use(ctx =&gt; { const { request: { url, query } } = ctx if (url === &#39;/&#39;) { // 根目录加载html let content = fs.readFileSync(&#39;./index.html&#39;, &#39;utf-8&#39;) ctx.type = &#39;text/html&#39; ctx.body = content } else if (url.endsWith(&#39;.js&#39;)) { // 拦截.js请求 const p = path.resolve(__dirname, url.slice(1)) ctx.type = &#39;application/javascript&#39; const content = fs.readFileSync(p, &#39;utf-8&#39;) ctx.body = content } }) app.listen(9000, () =&gt; { console.log(&#39;listened to 9000&#39;); }) 使用nodemon来热部署这个server（需要全局安装nodemon npm install nodemon -g） 这时访问localhost:9000会出现一个报错， 因为没有./、../，引入的包来自node_modules，要将这些值标记为npm包 支持node_modules的import 这时正统vite打包之后的main.js中引入的vue，那这时我们应该就有了些许想法：把import XX from &#39;xx&#39;替换为import XX from &#39;@modules/xx&#39; 最简单暴力的办法——使用正则替换，定义一个 function rewriteImport(content) { return content.replace(/ from [&#39;|&quot;]([^&#39;&quot;]+)[&#39;|&quot;]/g, function (s0, s1) { if (s1[0] !== &#39;.&#39; &amp;&amp; s1[1] !== &#39;/&#39;) { return ` from &quot;/@modules/${s1}&quot;` } else { return s0 } }) } 将原来的content用rewriteImport方法包裹一下，这时候已经替换成功了，然后再将这些请求从node_modules中查找 再追加一段代码，让其能够在node_modules中进行查找 else if (url.startsWith(&#39;/@modules/&#39;)) { const prefix = path.resolve(__dirname, &#39;node_modules&#39;, url.replace(&#39;/@modules/&#39;, &#39;&#39;)) const module = require(prefix + &#39;/package.json&#39;).module const p = path.resolve(prefix, module) console.log(p); } 已经可以成功的拿到了地址 支持.vue文件的importnpm包已经拿到了，现在就要再来处理.vue单文件组件，template模板=&gt;render函数 使用官方库@vue/compiler进行单文件解析 else if (url.indexOf(&#39;.vue&#39;) &gt; -1) { // 解析单文件 const p = path.resolve(__dirname, url.split(&#39;?&#39;)[0].slice(1)) // 使用官方库解析单文件 const { descriptor } = compilerSfc.parse(fs.readFileSync(p, &#39;utf-8&#39;)) console.log(descriptor); } 可以在控制台看到已经获取了template对象 再来看一眼vite解析之后的Vue 再按照这个格式去正则替换 if (!query.type) { ctx.type = &#39;application/javascript&#39; ctx.body = ` ${rewriteImport(descriptor.script.content.replace(&#39;export default&#39;, &#39;const __script = &#39;))} import { render as __render } from ${url}?type=template __script.render = __render export default __script ` } 然后再将template变成render函数 else if (query.type == &quot;template&quot;) { const template = descriptor.template const render = compilerDom.compile(template.content, { mode: &quot;module&quot; }).code ctx.type = &#39;application/javascript&#39; ctx.body = rewriteImport(render) } 到这里就差不多完成了 效果展示toy-vite vite 代码已上传码云","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Vue3的基础API变化","slug":"技术/Vue3API变化","date":"2020-09-19T00:33:27.474Z","updated":"2020-09-19T00:35:04.864Z","comments":true,"path":"2020/09/19/技术/Vue3API变化/","link":"","permalink":"https://easyremember.cn/2020/09/19/技术/Vue3API变化/","excerpt":"","text":"setup之前已经了解过了setup，是composition-api用来返回数据的，他可以接收两个参数setup(props, context)，第一个参数是Vue2中的props，第二个参数是一个上下文对象，可以调用Vue2中的this上的方法（setup中访问不到this） 响应式数据基础数据使用ref，引用类型使用reactive获得响应式，上一篇已经说过了，本篇不再赘述 说一下之前没有提到的几个API unref如果参数是ref产生的响应式数据，返回这个参数的.value，如果不是返回这个参数本身 isRef检查参数是否是ref对象 toRef将reactive创建的响应式对象的某个属性拿出来，赋值给一个变量，效果类似于ref创建了一个响应式数据 比如 let data = reactive({ name: &quot;张三&quot;, age: 13, }); let ageRef = toRef(data, &quot;age&quot;); // ageRef.value和data.age访问的是同一属性，改变他们的值都会互相影响 如果 const dom = ref(null)，那么变量dom将会是一个DOM元素的引用（onMounted之后才可以获取），dom.value = document 计算属性类似于Vue2的计算属性，composition-api中传入一个函数获得一个制度的计算属性 let count = ref(1) const countPro = computed(() =&gt; { return &#39;count:&#39; + count.value }) {{countPro}} // count:1 传入get和set方法获得一个可读可写的计算属性 let count = ref(1) const countPro = computed({ get: () =&gt; count.value + 1, set: val =&gt; { count.value = val - 1 } }) countPro.value = 1 console.log(count.value) // 0 监听器监听ref类型数据let count = ref(1); watch(count, (count, prevCount) =&gt; { console.log(&#39;new:&#39;+count); console.log(&#39;old:&#39;+prevCount); }); ref类型数据watch方法接收两个参数，第一个参数是要监听的数据；第二个参数是一个函数，这个函数有两个参数，第一个参数是新的值，第二个参数是旧的值 监听多个数据源watch([count1,count2], ([count1, count2], [prevCount1, prevCount2]) =&gt; { console.log(count1); console.log(count2); console.log(&#39;---------&#39;); console.log(prevCount1); console.log(prevCount2); }) 监听reactive类型数据let data = reactive({ name: &quot;张三&quot;, age: 13, }); watch(() =&gt; data.age, (age, prevAge) =&gt; { console.log(&quot;new:&quot; + age); console.log(&quot;old:&quot; + prevAge); }) reactive类型数据watch方法第一个参数是一个箭头函数，返回reactive响应对象监听的对象 监听多个数据源watch([ () =&gt; data.name, () =&gt; data.age], ([name, age], [prevName, prevAge]) =&gt; { console.log(name); console.log(age); console.log(&#39;---------&#39;); console.log(prevName); console.log(prevAge); }) 清除监视调用watch的返回值可以清除监视器 // 注册监听器 const stop = watch(xx, (xx. prevxx) =&gt; { /** XXXX*/ }) // 取消监听 stop() 生命周期钩子新版的生命周期只能在setup()函数中使用，变化是将beforeCreate和created合并为setup，其他的生命周期前面加上on，使用方法：向函数内部传箭头函数 provide/inject可以不限层级传递数据，同Vue2中一样，composition-api中使用方法如下（只能在setup函数中使用） // 父组件 provide(&#39;数据key&#39;, &#39;数据value&#39;) // value可以是ref数据 // 子组件 const getData = inject(&#39;数据key&#39;)","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Vue3初体验","slug":"技术/Vue3初体验","date":"2020-09-18T04:21:58.577Z","updated":"2020-09-18T04:23:04.218Z","comments":true,"path":"2020/09/18/技术/Vue3初体验/","link":"","permalink":"https://easyremember.cn/2020/09/18/技术/Vue3初体验/","excerpt":"","text":"安装Vue3基于vite实现工程化，首先安装vite # 安装生成器 npm install -g create-vite-app # 创建Vue3项目 create-vite-app vue3-camp # 安装依赖 npm install 差异入口文件Vue2new Vue(render() {}).$mount() Vue3// ↓--App.vue createApp(App).mount(&#39;#app&#39;) API（两种API可以混用） Vue2option-api，每次新添加数据需要从data等里面新增数据，需要来回翻动（同一颜色为同一功能所需数据） export default { data() { return { number: 1 } }, methods: { add() { this.number++ } }, } Vue3什么是composition-apicomposition-api，将同一功能的数据放在同一块内 为什么要用composition-api维护大型组件时不再需要上下翻动 怎么使用composition-api// 使用ref可以将基本数据类型变为响应式，引用类型使用reactive import { ref, reactive, toRefs } from &#39;vue&#39; export default { setup() { let number = ref(1) function add() { number.value++ } return { number, add } } } 这还不足以看出composition-api的优势，再来看一个todo示例，直接将不同的功能模块放在不同的方法中 import { reactive, toRefs } from &quot;vue&quot;; export default { setup() { let { addTodos, state } = todoDemo(); return { addTodos, ...toRefs(state) }; // 响应式对象需要state.val，使用toRefs将数组解构，可以直接val }, }; // 也可以在单独的js文件中 function todoDemo() { let state = reactive({ todos: [ { id: 0, name: &quot;学习&quot; }, { id: 1, name: &quot;玩游戏&quot; }, ], val: &quot;&quot;, }); function addTodos() { state.todos.push({ id: state.todos.length, name: state.val }) state.val = &#39;&#39; } return { addTodos, state }; } 更多API不在此多说，官网文档","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"filter过滤器","slug":"技术/filter过滤器","date":"2020-09-15T11:53:27.165Z","updated":"2020-09-15T12:13:09.646Z","comments":true,"path":"2020/09/15/技术/filter过滤器/","link":"","permalink":"https://easyremember.cn/2020/09/15/技术/filter过滤器/","excerpt":"","text":"过滤器（filter）是输送介质管道上不可缺少的一种装置，通常安装在减压阀、泄压阀、定水位阀 ，方工过滤器其它设备的进口端设备。 ——百度百科《过滤器》 这是百度百科的介绍，正巧Vue中过滤器的使用就是通过管道符号|，不知道是有意设计还是巧合 闲话少说，开始主题 什么是过滤器过滤器用于改变渲染结果 现在的过滤器经过一番修改只能作用于插值表达式的数据渲染了 来看一下官网的示例 Vue.filter(&#39;capitalize&#39;, function (value) { if (!value) return &#39;&#39; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) }) 这个过滤器的功能是获取字符串的第一个字符转换为大写，通过使用过滤器 为什么要用过滤器当有些数据需要需要渲染出来才能看得懂（比如时间戳）时，使用过滤器可以获得更好的展示效果 怎么使用过滤器过滤器有两种类型，一种是局部过滤器，定义在组件中，可以在单个组件中使用；另一种是全局过滤器，在创建Vue实例之前定义，可以在任何组件中使用。当全局过滤器和局部过滤器重名时，会采用局部过滤器 使用时间戳过滤器来做示例，在main.js中添加如下代码 // 全局挂载过滤器 Vue.filter(&#39;formatDate&#39;, function (date) { const n = new Date(date) return n.getFullYear() + &#39;-&#39; + (n.getMonth() + 1) + &#39;-&#39; + n.getDate() + &#39; &#39; + n.getHours() + &#39;:&#39; + n.getMinutes() + &#39;:&#39; + n.getSeconds() }) 然后在某一个需要转换时间戳的组件中使用 .info .time i.el-icon-time {{article.createAt | formatDate}} 然后可以看到页面中的渲染效果如下 还是这个过滤的局部定义方法为 filter: { formatDate: function(date) { const n = new Date(date) return n.getFullYear() + &#39;-&#39; + (n.getMonth() + 1) + &#39;-&#39; + n.getDate() + &#39; &#39; + n.getHours() + &#39;:&#39; + n.getMinutes() + &#39;:&#39; + n.getSeconds() } } 过滤器可以串联使用 {{message | filter1 | filter2}} // 将filter1渲染结果作为filter2的参数","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"elementUI踩坑记录","slug":"技术/elementUI踩坑","date":"2020-09-13T11:58:37.724Z","updated":"2020-10-19T04:11:13.233Z","comments":true,"path":"2020/09/13/技术/elementUI踩坑/","link":"","permalink":"https://easyremember.cn/2020/09/13/技术/elementUI踩坑/","excerpt":"","text":"导航栏与路由不匹配问题描述使用Element-UI Vue组件框架时，使用导航菜单NavMenu时，点击可以更改选中状态，但是，当路由改变不是通过导航菜单改变时，选中状态是不改变的 也就是说，只有在点击导航栏某一项时选中状态才会改变，如图，在点击浏览区返回键之后选中状态依旧没有改变 解决办法通过计算属性将路由和选中状态绑定，使用$route.path获取当前路由 &lt;template lang=&quot;pug&quot;&gt; .my-nav el-menu.el-menu( :default-active=&quot;route&quot;, mode=&quot;horizontal&quot;, active-text-color=&quot;#409eff&quot;, router ) el-menu-item(index=&quot;/&quot;) 首页 el-menu-item(index=&quot;/class&quot;) 分类 el-menu-item(index=&quot;/hot-user&quot;, disabled) 名人堂 el-menu-item(index=&quot;/collection&quot;) 藏品展示 &lt;/template&gt; &lt;script&gt; export default { computed: { route() { return &#39;/&#39; + this.$route.path.replace(&quot;/&quot;, &quot;&quot;); }, }, }; &lt;/script&gt; 将路由路径第一个/之后的内容替换为，然后与default-active绑定，每一次路由改变都会更改这个值，从而实现同步改变 效果图 步骤条问题描述步骤条文字与图标不对应 解决办法步骤条样式添加 text-align: left; 键盘事件问题描述添加键盘事件监听无法生效 解决办法添加.native修饰符 `@keyup.delete.native=”KeyUpDelete”` Dialog对话框问题描述点击空白处不关闭等默认属性无法改变 解决办法修改引入element组件的默认配置 import Vue from &#39;vue&#39; import Element from &#39;element-ui&#39; import &#39;element-ui/lib/theme-chalk/index.css&#39; Element.Dialog.props.closeOnClickModal.default = false Element.Dialog.props.showClose.default = false Vue.use(Element) upload上传组件问题描述 通过action属性发送请求出现跨域问题 不被请求拦截器拦截无法添加token 解决办法 配置代理，直接使用代理发送请求，如下 添加token请求头，使用:headers属性添加请求头，在data中添加token变量 不要对上传组件样式进行scoped限制，会丢失样式","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Vue动态组件","slug":"技术/动态组件","date":"2020-09-13T03:13:24.458Z","updated":"2020-09-13T03:14:11.933Z","comments":true,"path":"2020/09/13/技术/动态组件/","link":"","permalink":"https://easyremember.cn/2020/09/13/技术/动态组件/","excerpt":"","text":"让多个组件使用同一个挂载点，并动态切换，这就是动态组件。 常规实现方案使用v-if来实现子组件之间的切换，使用一个索引控制，当索引匹配成功时组件显示（使用v-show也可以） v-if：v-if 控制元素显示或隐藏是把dom元素整个的渲染或者删除 v-show：改变css样式display控制显示隐藏 回到正题，引入三个组件，然后使用v-if控制显示隐藏 &lt;template lang=&quot;pug&quot;&gt; .steps el-steps(:active=&quot;active&quot;, finish-status=&quot;success&quot;) el-step(title=&quot;步骤 1&quot;) el-step(title=&quot;步骤 2&quot;) el-step(title=&quot;步骤 3&quot;) .son(v-if=&quot;active === 1&quot;) component1 .son(v-if=&quot;active === 2&quot;) component2 .son(v-if=&quot;active === 3&quot;) component3 el-button(style=&quot;margin-top: 12px;&quot;, @click=&quot;next&quot;) 下一步 el-button(style=&quot;margin-top: 12px;&quot;, @click=&quot;pre&quot;, v-if=&quot;active &gt; 0&quot;) 上一步 &lt;/template&gt; &lt;script&gt; import component1 from &#39;../components/component1&#39; import component2 from &#39;../components/component2&#39; import component3 from &#39;../components/component3&#39; export default { components: { component1, component2, component3, }, data() { return { active: 0, }; }, methods: { next() { if (this.active++ &gt; 2) this.active = 0; }, pre() { if (this.active-- &lt; 1) this.active = 0; }, }, }; &lt;/script&gt; 效果 内置组件component试过组件id来控制显示哪个组件，先将组件名放在数组中，通过索引获取数组中的组件名来绑定组件，使用计算属性监听，当索引发生变化时，计算属性的值随之改变 看代码 &lt;template lang=&quot;pug&quot;&gt; .steps h2 component el-steps(:active=&quot;active&quot;, finish-status=&quot;success&quot;) el-step(title=&quot;步骤 1&quot;) el-step(title=&quot;步骤 2&quot;) el-step(title=&quot;步骤 3&quot;) component(:is=&quot;componentId&quot;) el-button(style=&quot;margin-top: 12px;&quot;, @click=&quot;next&quot;) 下一步 el-button(style=&quot;margin-top: 12px;&quot;, @click=&quot;pre&quot;, v-if=&quot;active &gt; 0&quot;) 上一步 &lt;/template&gt; &lt;script&gt; import component1 from &#39;../components/component1&#39; import component2 from &#39;../components/component2&#39; import component3 from &#39;../components/component3&#39; export default { components: { component1, component2, component3, }, data() { return { active: 0, componentArr: [&#39;component1&#39;, &#39;component2&#39;, &#39;component3&#39;] }; }, computed: { componentId() { return this.componentArr[this.active] } }, methods: { next() { if (this.active++ &gt; 2) this.active = 0; }, pre() { if (this.active-- &lt; 1) this.active = 0; }, }, }; &lt;/script&gt; &lt;/style&gt; 效果 可以看出两种方式实现的效果基本无差异，如果动态组件涉及表单，可以使用keep-alive缓存表单内容","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"created和mounted的区别","slug":"技术/created和mounted的区别","date":"2020-09-11T09:02:04.381Z","updated":"2020-09-11T09:03:21.632Z","comments":true,"path":"2020/09/11/技术/created和mounted的区别/","link":"","permalink":"https://easyremember.cn/2020/09/11/技术/created和mounted的区别/","excerpt":"","text":"先来丢一张官网生命周期 可以从这张示意图中看出，mount主要是挂载el也就是DOM，mount结束之前跟DOM有关的操作无法执行，比如getElementById create阶段是注入数据，这时候可以进行ajax请求等不涉及dom的操作","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Vue2双向绑定原理","slug":"技术/defineproperty与Vue2","date":"2020-09-11T08:31:24.962Z","updated":"2020-09-11T09:02:40.373Z","comments":true,"path":"2020/09/11/技术/defineproperty与Vue2/","link":"","permalink":"https://easyremember.cn/2020/09/11/技术/defineproperty与Vue2/","excerpt":"","text":"先上效果图 Vue的双向绑定采用数据劫持配合发布者——订阅者模式，通过Object.defineproperty()劫持各个属性getter和setter，数据变动时,发布消息给依赖收集器Dep，然后通知观察者，做出对应的回调，更新视图 在案例中MyVue作为入口，整合Observer，Compile，Watcher，通过Observer来监听数据变化通过Compile来编译模板，利用Watcher来连接Compile和Observer，来实现双向绑定 MyVue作为入口，经过Compile解析之后渲染到页面，同时添加观察者Observer来监听数据变化，当数据变化时通知依赖收集器Dep，将变化分发给watcher然后再渲染视图 数据劫持示例代码 const obj = {}; function property(obj, key, value) { Object.defineProperty(obj, key, { enumerable: true, configurable: false, get() { return &#39;姓名：&#39; + value; }, set(newVal) { value = newVal; console.log(&#39;修改了数据&#39;); } }) } property(obj, &#39;name&#39;, &#39;张三&#39;); console.log(obj.name); 运行图 当数据读取时会加上“姓名：”，数据修改时会提示修改数据，此时对象obj除了name之外，还有name的getter和setter两个方法 代码入口class MyVue { constructor(options) { this.$el = options.el; this.$data = options.data; this.$options = options; if (this.$el) { // 观察者 new Observer(this.$data); // 指令解析器 new Compile(this.$el, this) } } Compile指令解析器，解析网页元素中的双大括号、v-model、v-on……等元素。对指令节点进行判断，然后遍历其所有属性，看是否有匹配的指令的属性。首先要获得dom元素，然后对含有dom元素上含有指令的节点进行处理，建一个fragment片段，将需要解析的dom元素存到fragment片段中在做处理，接下来需要遍历所有节点，对含有指令的节点进行特殊的处理 class Compile { constructor(el, vm) { // 赋值/获取节点 this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; // 获取子元素文档碎片 const frag = this.fragment(this.el); // console.log(frag); // 编译模板 this.compile(frag); // 追加子元素到根元素 this.el.appendChild(frag); } compile(fragment) { const children = fragment.childNodes; [...children].forEach(child =&gt; { if (this.isElementNode(child)) { // 元素节点 this.compileElement(child); } else { // 文本节点 this.complieText(child); } if (child.childNodes &amp;&amp; child.childNodes.length) { this.compile(child) } }); } complieText(text) { const content = text.textContent; if(/\\{\\{(.+?)\\}\\}/.test(content)) { compileUtil[&#39;text&#39;](text, content, this.vm); } } compileElement(node) { const attributes = node.attributes; [...attributes].forEach(attribute =&gt; { const { name, value } = attribute; if (this.isDire(name)) { const [, dirctive] = name.split(&#39;-&#39;); const [dirName, eventName] = dirctive.split(&#39;:&#39;); // 更新视图 compileUtil[dirName](node, value, this.vm, eventName); // 删除指令 node.removeAttribute(&#39;v-&#39; + dirctive); } else if(this.isEventName(name)) {// 判断@符号 let [, eventName] = name.split(&#39;@&#39;); compileUtil[&#39;on&#39;](node, value, this.vm, eventName); } else if(this.isBindName(name)) { let [, attr] = name.split(&#39;:&#39;); compileUtil[&#39;bind&#39;](node, value, this.vm, attr); } }) } isBindName(name) { return name.startsWith(&#39;:&#39;) } isEventName(name) { return name.startsWith(&#39;@&#39;) } isDire(name) { return name.startsWith(&#39;v-&#39;) } fragment(el) { // 创建文档碎片 const nodeFrag = document.createDocumentFragment(); while (el.firstChild) { nodeFrag.appendChild(el.firstChild); } return nodeFrag; } isElementNode(node) { return node.nodeType === 1; } } Observer遍历循环对所有属性值进行监听，并对其进行数据劫持。通过observe()方法进行遍历向下找到所有的属性，并通过defineReactive()方法进行数据劫持监听。知道监听器Observer是在get函数中执行了添加订阅者的操作的，所以我们只需要在订阅者Watcher在初始化时触发相对应的get函数来执行添加订阅者的操作，借助依赖收集器 class Observer { constructor(data) { this.observer(data); } observer(data) { if(data &amp;&amp; typeof data === &#39;object&#39;) { Object.keys(data).forEach(key =&gt; { this.defineReactive(data, key, data[key]); }) } } defineReactive(data, key, value) { this.observer(value); const depend = new Dep(); // 劫持 Object.defineProperty(data, key, { enumerable: true, configurable: false, get() { // 数据初始化的时候添加订阅 Dep.target &amp;&amp; depend.addSub(Dep.target) return value; }, set: (newValue) =&gt; { this.observer(newValue); if(newValue !== value) { value = newValue; } // 通知Dep变化 depend.notify(); } }) } } Dep依赖收集器，主要负责添加订阅以及发布通知 class Dep { // 收集watcher,通知watcher constructor() { this.subs = []; } // 收集watcher addSub(watcher) { this.subs.push(watcher); } // 通知watcher更新 notify() { console.log(&quot;观察者&quot;, this.subs); this.subs.forEach(watcher =&gt; { watcher.update() }) } } Watcher将Compile和Observer关联起来 class Watcher { constructor(vm, express, callback) { this.vm = vm; this.express = express; this.callback = callback; // 保存旧值 this.oldValue = this.getOldValue(); } getOldValue() { Dep.target = this; let old = compileUtil.getValue(this.express, this.vm); Dep.target = null; return old; } update() { const newValue = compileUtil.getValue(this.express, this.vm); if(newValue !== this.oldValue) { this.callback(newValue); } } } 上面图中的updater放在了compileUtil中 const compileUtil = { // 获取data中的对象值 getValue(express, vm) { return express.split(&#39;.&#39;).reduce((data, currentVal) =&gt; { // console.log(currentVal); return data[currentVal] }, vm.$data) }, setValue(express, vm, inputValue) { return express.split(&#39;.&#39;).reduce((data, currentVal) =&gt; { data[currentVal] = inputValue; }, vm.$data) }, // 区分开{{}}--{{}} getContentValue(express, vm) { return express.replace(/\\{\\{(.+?)\\}\\}/g, (...args) =&gt; { return this.getValue(args[1], vm); }) }, // v-text text(node, express, vm) { let value; if(express.indexOf(&#39;{{') !== -1) { // {{msg}} value = express.replace(/\\{\\{(.+?)\\}\\}/g, (...args) =&gt; { // 绑定观察者 new Watcher(vm, args[1], (newValue) =&gt; { this.updater.textUpdater(node, this.getContentValue(express, vm)); }) return this.getValue(args[1], vm); }) } else { value = this.getValue(express, vm); } this.updater.textUpdater(node, value); }, // v-html html(node, express, vm) { let value = this.getValue(express, vm); new Watcher(vm, express, (newValue) =&gt; { this.updater.htmlUpdater(node, newValue); }); this.updater.htmlUpdater(node, value); }, // v-model model(node, express, vm) { // 数据-视图 const value = this.getValue(express, vm); new Watcher(vm, express, (newValue) =&gt; { this.updater.modelUpdater(node, newValue); }); // 视图-数据-视图 node.addEventListener(&#39;input&#39;, e =&gt; { this.setValue(express, vm, e.target.value); }) this.updater.modelUpdater(node, value); }, // v-on on(node, express, vm, event) { const f = vm.$options.methods &amp;&amp; vm.$options.methods[express]; node.addEventListener(event, f.bind(vm), false); }, bind(node, express, vm, attribute) { const value = this.getValue(express, vm); this.updater.bindUpdater(node, attribute, value); }, updater: { textUpdater(node, value) { node.textContent = value; }, htmlUpdater(node, value) { node.innerHTML = value; }, modelUpdater(node, value) { node.value = value; }, bindUpdater(node, attribute, value) { node.setAttribute(attribute, value); } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"git入门操作","slug":"技术/git基本操作","date":"2020-09-10T06:49:07.044Z","updated":"2020-09-10T06:50:35.752Z","comments":true,"path":"2020/09/10/技术/git基本操作/","link":"","permalink":"https://easyremember.cn/2020/09/10/技术/git基本操作/","excerpt":"","text":"基本操作最常用的操作都在这张流程图中 git add：将文件添加到暂存区 git commit：将暂存区文件提交到本地仓库 git push：将本地仓库推送到远程仓库 git pull：从远程仓库拉取并合并 git clone：克隆远程仓库到本地（也就是下载） git checkout：见下方 其他命令都很简单，展开说一下checkout 未添加缓存时撤销文件修改（没有add，已添加缓存使用reset退回） 放弃单个文件修改：git checkout -- filepathname 放弃全部文件修改：git checkout . 切换或新建分支，使用git checkout -b branchName来创建一个新的分支，如图 插一句：合并分支git merge gitignore常用的过滤规则 /list/：过滤整个文件夹 *.zip：过滤所有的.zip文件 /list/a.doc：过滤文件夹下的特定文件 使用!表示不过滤，如!/list/不过滤这个文件夹","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"webpack工作原理","slug":"技术/webpack工作原理","date":"2020-09-09T11:51:27.685Z","updated":"2020-09-09T11:52:27.276Z","comments":true,"path":"2020/09/09/技术/webpack工作原理/","link":"","permalink":"https://easyremember.cn/2020/09/09/技术/webpack工作原理/","excerpt":"","text":"工作流程图主要介绍工作原理，webpack基础不再赘述 流程大致为，转载自 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数； 开始编译： 用上一步得到的参数初始化Complier对象，加载所有配置的插件，执行对象的run方法开始执行编译； 确定入口： 根据配置中的entry找出所有入口文件； 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤的处理； 完成模块编译： 在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成： 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 手动实现分析入口文件const fs = require(&#39;fs&#39;) module.exports = class Webpack{ constructor(options) { console.log(options); const {entry, output} = options; this.entry = entry this.output = output } run() { console.log(&#39;webpack run&#39;); this.parse(this.entry) } parse(entryFile) { // 分析入口文件 const content = fs.readFileSync(entryFile, &#39;utf-8&#39;) console.log(content); } } 解析依赖关系不推荐使用字符串截取，使用@babel/parser来解析内部语法，需要安装npm包 使用parser解析读取到的文件内容 parse(entryFile) { // 分析入口文件 const content = fs.readFileSync(entryFile, &#39;utf-8&#39;) console.log(content); // 分析依赖及以来的路径 // 使用parser把内容抽象成语法树 const ast = parser.parse(content, { sourceType: &#39;module&#39; }) console.log(ast); } 运行结果如下 可以发现里面折叠了3个Node结点，打开来看一下 什么？看懂了！！！大神收下膝盖，不过相信很多人跟我一样第一眼看到时蒙逼的吧，不慌，再好好看看 打开index.js的时候你可能会发现点什么 3行代码，3个结点，别太早下结论，来验证一下 再加点东西 import {add} from &#39;./expo.js&#39; import {minus} from &#39;./expo.js&#39; add(1,2) minux(3,2) console.log(&#39;hello webpack&#39;); 然后再看解析结果（终端放不开，找了个工具盛一下） 这下稳了 ImportDeclaration表示引入依赖，ExpressionStatement表示表达式 然后再来根据分析结果，遍历引入的依赖，使用@babel/traverse，需要安装npm包 const dependencies = [] traverse(ast, { ImportDeclaration({node}) { // 可以分析表达式 const finalName = path.join(path.dirname(entryFile), node.source.value) // 拼接路径 // console.log(finalName); dependencies.push(finalName) } }) console.log(dependencies); 打印一下，可以看到已经获取到了引入的依赖 然后就是将ES6等语法转换为浏览器可以执行的代码，使用@babel/core和@babel/preset-env工具 const {code} = transformFromAst(ast, null, { presets: [&#39;@babel/preset-env&#39;] }) console.log(code); 可以看到已经将es6的import转换成了require。到这里依赖的分析已经完成了，将解析到的结果作为一个对象返回出去 return { entryFile, dependencies, code } 然后我们拿到了这么一个东西 然后还要解析依赖中是否存在依赖。。。 run() { const info = this.parse(this.entry) // console.log(info); // 处理其他模块，然后汇总 this.modules.push(info) for(let i = 0; i &lt; this.modules.length; i++) { const item = this.modules[i] const {dependencies} = item if(dependencies) { for(let j in dependencies) { this.modules.push(this.parse(dependencies[j])) } } } console.log(this.modules); } 如果你看过webpack打包的代码，你会发现，打包出来的代码都是以对象形式存在的，我们还要继续处理 生成文件解析完成了就要把解析好的代码输出到文件中 file(code) { // 生成文件 const filePath = path.join(this.output.path, this.output.filename) const newCode = JSON.parse(code) const bundle = `(function() { })(${newCode})` fs.writeFileSync(filePath, bundle, &#39;utf-8&#39;) } 新建一个dist目录，然后运行，会看到已经自动生成了一个main.js 这时其实是有问题的，路径还是原来的引用路径，但是文件到了dist目录下，需要对路径进行处理 因为在对象中有绝对地址，所以直接读取出来 function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]) } 然后就来到了webpack的核心require，他模仿了Node中的require操作，是一个立即执行函数，所以文件能直接在浏览器运行 file(code) { // 生成文件 const filePath = path.join(this.output.path, this.output.filename) const newCode = JSON.stringify(code) const bundle = `(function(graph) { function require(module){ function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]) } var exports = {}; (function(require, exports, code) { eval(code) })(localRequire, exports, graph[module].code) return exports } require(&#39;${this.entry}&#39;) })(${newCode})` fs.writeFileSync(filePath, bundle, &#39;utf-8&#39;) } 代码代码已上传码云","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"hexo博客SEO优化","slug":"资源/hexo博客SEO优化","date":"2020-09-09T03:24:28.983Z","updated":"2020-09-09T03:28:10.410Z","comments":true,"path":"2020/09/09/资源/hexo博客SEO优化/","link":"","permalink":"https://easyremember.cn/2020/09/09/资源/hexo博客SEO优化/","excerpt":"","text":"hexo博客SEO优化众所周知，自己写的文章基本不会被百度收录，要主向百度推送自己的地址 每写一篇文章都要向百度推送一次地址当然不是我的风格，必须有一种一劳永逸的方法——通过sitemap自动抓取地址 生成sitemap安装插件 npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 然后全局编译一下，访问http://127.0.0.1:4000/sitemap.xml 如果能正常看到xml数据就可以进行下一步了（发布一下），这里有个坑，如果你遇到了这个问题 检查一下文章文件名有没有&amp;，如果有的话改掉它 注册百度站长百度搜索“百度站长”，登录之后添加网站 每一步都有说明，不再赘述，最后一步验证建议使用html验证，只需要加一个标签就行了 添加完网站之后添加收录 提交自己刚才的xml地址就完事了，等待收录","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"webpack笔记","slug":"笔记/webpack","date":"2020-09-08T11:14:28.126Z","updated":"2021-02-23T06:51:21.853Z","comments":true,"path":"2020/09/08/笔记/webpack/","link":"","permalink":"https://easyremember.cn/2020/09/08/笔记/webpack/","excerpt":"","text":"1 简介1.1 webpack 五个核心概念1.1.1 Entry入口，指示webpack以哪个文件为入口起点开始打包，分析构建内部依赖图 1.1.2 Output输出，指示webpack打包后的资源bundles输出到哪里去，以及怎么命名 1.1.3 Loader加载器，可以让webpack能够去处理非js文件（webpack自身之理解javascript） 1.1.4 Plugins插件，可以用于执行更广范围的任务，插件的范围包括从打包优化和压缩一直到重新定义环境变量等 1.1.5 Mode模式，指示webpack使用相应模式的配置 development：能让代码本地调试运行的环境 production：能让代码优化上线的运行环境 2 webpack 初体验2.1 创建一个webpack项目 创建一个目录，初始化包管理 npm init 运行命令npm install webpack webpack-cli -D 新建src文件夹用于存放代码，新建build文件夹用于存放打包好的文件 编辑代码 运行命令（开发环境） webpack ./src/index.js -o ./build/build.js --mode=development 默认只能处理js/json文件 2.2 打包css样式资源 新建css文件style.css 在index.js中引入 import &#39;style.css&#39; 创建webpack.config.js文件来配置webpack（使用commentJS） const { resolve } = require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, // 模式，不能同时存在 // mode: &#39;production&#39; entry: &#39;./src/index.js&#39;, // 入口文件 output: { filename: &#39;built.js&#39;, // 输出文件名 path: resolve(__dirname, &#39;build&#39;) // 输出路径 }, module: { // loader配置 rules: [{ test: /\\.css$/,// css结尾的文件 use: [// 执行顺序：从右到左，从下到上，依次执行 &#39;style-loader&#39;,// 创建爱你style标签，将js中的样式资源插入，添加到head &#39;css-loader&#39;,// 将css文件变成commentjs模块加载js中，内容是字符串 ] }] }, plugins: [ // 插件配置 ], } 安装所需要的loader 运行命令 webpack 使用less、scss等预编译语法需要下载对应的loader，配置方式同上，再添加一个rule对象 2.3 打包HTML文件 安装打包html的插件 npm install html-webpack-plugin-D 在webpack.config.js中引入并添加配置 const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); ··· plugins: [ // 插件配置 // html-webpack-plugin // 功能： 创建一个空的html文件引入打包之后的所有资源 new HtmlWebpackPlugin({ // 赋值目标文件并引入打包的资源 template: &#39;./src/index.html&#39; }) ], 在创建html模板的时候不要引入资源 2.4 打包图片文件图片添加略过，只给出配置方式 module: { // loader配置 rules: [{ test: /\\.(jpg|png|gif|jpeg)$/, // 只有一个loader的时候可以直接loader+loader名 loader: &#39;url-loader&#39;,// 下载时需要下载url-loader和file-loader options: { /** * 限制大小，小于限制就会被base64处理 * 优点减少请求数量，减轻服务器压力 * 缺点图片会更大，文件请求速度会变慢 */ limit: 200 * 1024 } }] }, 如果html模板中添加了图片，添加一个额外的loader来解析 { test: /\\.html$/, loader: &#39;html-withimg-loader&#39; // 处理html中的图片 } 但是，因为url-loader默认使用es6模块化解析，而html-loader引入图片是commentjs 解析时会出现[object Module] 解决办法：关闭ur-loader的ES6解析，在url-loader的options中添加 esModule: false 2.5 打包其他资源{ exclude: /\\.(css|html|jpg|png|gif|jpeg)$/, loader: &#39;file-loader&#39; } 除了这匹配到的后缀文件之外，其他的文件用file-loader打包 2.6 使用devServer开发服务器：用来自动编译，热更新等 在内存中编译打包，不会有任何输出 运行：webpack-dev-server 运行npm install webpack-dev-server -D安装 webpack.config.js中添加配置 devServer: { contentBase: resolve(__dirname, &#39;build&#39;),// 项目构建后的路径 compress: true,// 启动gzip压缩 port: 3000,// 端口号 open: true,// 打开默认浏览器 } 运行webpack-dev-server 3 开发环境配置const { resolve } = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // mode: &#39;production&#39; entry: &#39;./src/index.js&#39;, output: { filename: &#39;built.js&#39;, path: resolve(__dirname, &#39;build&#39;) }, module: { rules: [{ test: /\\.css$/, use: [ &#39;style-loader&#39;, &#39;css-loader&#39;, ] },{ test: /\\.(jpg|png|gif|jpeg)$/, loader: &#39;url-loader&#39;, options: { limit: 200 * 1024, esModule: false } },{ test: /\\.html$/, loader: &#39;html-loader&#39; }] }, plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39; }) ], devServer: { contentBase: resolve(__dirname, &#39;build&#39;), compress: true, port: 3000, open: true, } } 4 生产环境搭建4.1 提取css成单独文件 安装插件 npm install mini-css-extract-plugin -D 修改webpack.config.js配置文件 const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); ··· module: { rules: [{ test: /\\.css$/, use: [ // &#39;style-loader&#39;, MiniCssExtractPlugin.loader,// 替换style-loader，提取css成单独文件 &#39;css-loader&#39;, ] }, ···] }, plugins: [ ··· new MiniCssExtractPlugin({ filename: &#39;css/style.css&#39; }) ], 运行打包命令 4.2 css兼容性处理使用到postcss 运行 npm install postcss-loader postcss-preset-env -D 修改webpack.config.js的css相关部分配置 { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, { loader: &#39;postcss-loader&#39;, options: { ident: &#39;postcss&#39;, plugins: () =&gt; [ require(&#39;postcss-preset-env&#39;)() ] } } ] } 在package.json中添加浏览器版本控制 &quot;browerslist&quot;: { &quot;development&quot;: [ &quot;last 1 chrome version&quot;, &quot;last 1 firefox version&quot;, &quot;last 1 safair version&quot; ], &quot;production&quot;: [ &quot;&gt;0.2%&quot;, &quot;not dead&quot;, &quot;not op_mini all&quot; ] } 运行打包 4.3 压缩css使用插件 optimize-css-assets-webpack-plugin 运行npm install optimize-css-assets-webpack-plugin -D webpack.config.js中引入 const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;); ··· plugins: [ ··· new OptimizeCssAssetsWebpackPlugin() ] 4.4 js语法检查使用eslint，使用airbnb规则检查js语法 运行 npm install eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import -D安装所需的依赖和插件 在package.json中设置eslintConfig，继承airbnb &quot;eslintConfig&quot;: { &quot;extends&quot;: &quot;airbnb-base&quot; } webpack.config.js中添加rules { test: /\\.js$/, exclude: /node_modules/,// 只检查自己的代码，不检查第三方库中的代码 loader: &#39;eslint-loader&#39;, options: { fix: true// 自动修复eslint错误 } } 使用 // eslint-disable-next-line控制下一行不进行检查 4.5 js兼容性处理使用babel-loader进行兼容性处理 运行 npm install babel-loader @babel/core @babel/preset-env @babel/polyfill -D 添加webpack.config.js的rules { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;] } }, @babel/polyfill属于高级语法支持，在需要兼容的js文件中引入即可 import ‘@babel/polyfill’ @babel/polyfill属于暴力支持，回事打包文件变的非常大，所以一般采用按需加载的方式：core.js 运行 npm install corejs -D 修改之前的兼容性配置规则 { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, options: { presets: [ [ &#39;@babel/preset-env&#39;, { useBuiltIns: &#39;usage&#39;,// 按需加载 corejs: { version: 3 }, targets: {// 制定兼容浏览器版本 chrome: &#39;60&#39;, firefox: &#39;50&#39;, ie: &#39;9&#39;, safari: &#39;10&#39; } } ] ] } }, 4.6 HTML和js压缩4.6.1 js压缩将模式调整为production即可实现js代码压缩 4.6.2 HTML压缩在html的插件中添加设置 new HtmlWebpackPlugin({ // 复制目标文件并引入打包的资源 template: &#39;./src/index.html&#39;, minify: { // 移除空格 collapseWhitespace: true, // 移除注释 removeComments: true } }), 5 生产环境配置const { resolve } = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;); module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;js/built.js&#39;, path: resolve(__dirname, &#39;build&#39;) }, module: { // loader配置 rules: [{ test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, { loader: &#39;postcss-loader&#39;, options: { ident: &#39;postcss&#39;, plugins: () =&gt; [ require(&#39;postcss-preset-env&#39;)() ] } } ] }, { test: /\\.(jpg|png|gif|jpeg)$/, loader: &#39;url-loader&#39;, options: { limit: 200 * 1024, esModule: false } }, { test: /\\.html$/, loader: &#39;html-loader&#39; }, { test: /\\.js$/, exclude: /node_modules/, enforce: &#39;pre&#39;,// 优先执行 loader: &#39;eslint-loader&#39;, options: { fix: true } }, { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, options: { presets: [ [ &#39;@babel/preset-env&#39;, { useBuiltIns: &#39;usage&#39;, corejs: { version: 3 }, targets: { chrome: &#39;60&#39;, firefox: &#39;50&#39;, ie: &#39;9&#39;, safari: &#39;10&#39; } } ] ] } }, ] }, plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, minify: { collapseWhitespace: true, removeComments: true } }), new MiniCssExtractPlugin({ filename: &#39;css/style.css&#39; }), new OptimizeCssAssetsWebpackPlugin() ], devServer: { contentBase: resolve(__dirname, &#39;build&#39;), compress: true, port: 3000, open: true, }, // mode: &#39;development&#39;, mode: &#39;production&#39;, } babel和eslint可能会产生冲突使用enforce: ‘pre’让eslint先执行 6 性能优化篇6.1 开发环境性能优化6.1.1 优化打包构建速度6.1.1.1HMR——hot module replacement（模块热替换）只会重新打包这一个模块，不会重新打包 配置devServer devServer: { contentBase: resolve(__dirname, &#39;build&#39;), compress: true, // 启动gzip压缩 port: 3000, // 端口号 open: true, // 打开默认浏览器 hot: true,// 开启热更新 }, 样式文件热更新基于’style-loader’； js文件默认不能使用HMR功能； HTML文件默认不能使用HMR功能，同时会导致问题，HTML文件不能热更新，解决办法：修改entry入口，将html文件引入（不需要做HMR） 6.1.1.2 oneOf减少loader检索每个文件在检索的的时候会每个rules都验证一遍，将所有的rules都放到oneOf中就可以验证到所在的规则不再继续验证 这样出现了问题，js可能会有多个loader，解决办法：oneOf中保留一条rule，其他的取出来与oneOf平级 6.1.2 优化代码调试source-map：提供语言代码构建后代码映射技术（构建代码出错，追踪源代码错误） 添加devtool devtool: &#39;source-map&#39;, [inline- |hidden- | eval-][nosources-][cheap-[module-]]source-map分别对应： inline-内联：（汇集在一起）错误代码准确信息和源代码错误位置 hidden-外部：代码错误原因，没有错误位置，不能追踪代码错误 eval-内联：（分别跟每个文件对应）错误代码准确信息和源代码错误位置（位置信息是哈希值） nosources-外部：错误代码准确信息，没有源代码错误信息 cheap-外部：错误代码准确信息和源代码错误位置（只精确到行，提示整行错误） cheap-module-外部：错误代码准确信息和源代码错误位置 source-map`外部：错误代码准确信息和源代码错误位置： 模式使用 开发环境：速度快，开发更友好 速度快eval&gt;inline&gt;cheap&gt;··· eval-cheap-source-map eval-source-map 调试更友好 source-map cheap-module-source-map cheap-source-map –&gt;eval-source-map / eval-cheap-module-source-map 生产环境：源代码要不要隐藏 内联会让代码体积变大，使用外部方式 source-map ··· 隐藏代码 nosource-source-map// 全部隐藏 hidden-source-map// 隐藏源代码 –&gt;source-map / cheap-module-source-map 6.2生产环境性能优化缓存机制babel缓存修改js打包配置，开启缓存 { test: /\\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;, options: { presets: [ [ &#39;@babel/preset-env&#39;, { useBuiltIns: &#39;usage&#39;, // 按需加载 corejs: { version: 3 }, targets: { // 制定兼容浏览器版本 chrome: &#39;60&#39;, firefox: &#39;50&#39;, ie: &#39;9&#39;, safari: &#39;10&#39; } } ] ], cacheDirectory: true// 开启缓存 } }, 强缓存模式，所有的数据都要缓存，从新打包之后不会试用新的文件 文件资源缓存hash这里修改输出文件名，每次到打包之后的文件都不一样，这就不加绝了强制缓存带来的不刷新了（取10位hash值） output: { filename: &#39;js/built[hash:10].js&#39;, // 输出文件名 path: resolve(__dirname, &#39;build&#39;) // 输出路径 }, 所有的js和css文件共用一个哈希值，重新打包会导致所有的缓存失效 chunkhash根据chunk生成的hash值，如果打包源来自同一个chunk，那么hash值相同 此时，js和css的hash值还是相同，因为css是在js中引入的，同属于一个chunk contenthash根据文件内容生成hash，不同文件hash值一定不一样 filename: &#39;js/built[contenthash:10].js&#39; 如果单独提取了css，css命名修改为 new MiniCssExtractPlugin({ filename: &#39;css/style-[contenthash:10].css&#39; }) tree shaking去除无用代码 必须使用ES6模块化 开启production环境 打包是会自动摇去没有用的叶子 在package.json中配置&quot;sideEffects&quot;: false所有代码都没有副作用 ​ 问题：可能会把css文件干掉，解决&quot;sideEffects&quot;: [&quot;*.css&quot;] code split文件分割 多入口文件分割 添加webpack.config.js配置项，将node中的代码单独打包一个chunks，自动分析多入口文件中有没有公共文件，如果有会单独打包成一个chunk optimization: { splitChunks: { chunks: &#39;all&#39; } }, 通过js代码，让某个文件单独打包成一个chunk 懒加载、预加载懒加载document.getElementById(&#39;btn&#39;).onclick = function() { import(/* webpackChunkName: &#39;test&#39;*/&#39;./js/test.js&#39;) .then(({mul}) =&gt; { console.log(mul(4, 5)); }) } 将引入放在事件的回调函数中，事件触发时才加载js文件 配合eslint语法检查是有问题的，在.eslintrc文件汇总设置 &quot;allowImportExportEverywher&quot;: true，允许在任何地方import 预加载将引入改为 import(/* webpackChunkName: &#39;test&#39;, webpackPrefetch: true */&#39;./js/test.js&#39;) 预加载会提前将js文件加载 区别 懒加载：文件需要才加载 预加载：使用之前加载，浏览器空闲再加载（兼容性较差） 正常加载：并行加载 PWA渐进式网络开发应用程序（离线可访问） ​ workbox–&gt;workbox-webpack-plugin 运行 npm install workbox-webpack-plugin -D 修改webpack.config.js配置 const WorkboxWebpackPlugin = require(&#39;workbox-webpack-plugin&#39;); ··· plugin: [ ··· new WorkboxWebpackPlugin.GenerateSW({ clientsClaim: true, skipWaiting: true }) ] 帮助serviceworker快速启动；删除旧的serviceworker 在入口文件中注册serviceworker，处理兼容 if(&#39;serviceWorker&#39; in navigator) { window.addEventListener(&#39;load&#39;, () =&gt; { navigator.serviceWorker.register(&#39;./service-worker.js&#39;) .then(() =&gt; { console.log(&#39;sw注册成功&#39;) }).catch(() =&gt; { console.log(&#39;sw注册失败&#39;) }) }) } eslint不识别window，navigator等全局变量，修改package.json配置 &quot;eslintConfig&quot;: { &quot;extends&quot;: &quot;airbnb-base&quot;, &quot;env&quot;: { &quot;browser&quot;: true// 支持浏览器全局变量 } } 构建代码 多进程打包消耗时间长的才需要多进程打包，多进程开始需要时间，进程通信也需要时间 运行npm install thread-loader -D 修改webpack.config.js中babel所在的rule { test: /\\.js$/, exclude: /node_modules/, use: [ { loader: &#39;thread-loader&#39;,// 多进程打包 options: { workers: 2,// 使用两个进程 } }, { loader: &#39;babel-loader&#39;, ··· } ] }, externals忽略某些包，比如CDN引入的 在webpack.config.js第一级目录下添加 externals: { // 包名： npm库名 jquery: &#39;jQuery&#39; } dll 新建一个配置文件，例如 webpack.dll.js const {resolve} = require(&#39;path&#39;); const webpack = require(&#39;webpack&#39;); module.exports = { entry: { // [name]: 要打包的库名 jquery: [&#39;jquery&#39;] }, output: { filename: &#39;[name].js&#39;, path: resolve(__dirname, &#39;dll&#39;), library: &#39;[name]_[hash]&#39;// 打包库里暴露的内容叫什么名 }, plugins: [ // 打包生成一个映射关系 new webpack.DllPlugin({ name: &#39;[name]_[hash]&#39;,// 映射库暴露的内容名称 path: resolve(__dirname, &#39;dll/manifast.json&#39;)// 输出文件路径 }) ], mode: &#39;production&#39; } 运行命令 webpack --config webpack.dll.js 运行 npm install add-asset-html-webpack-plugin -D 修改webpack.config.js配置 const webpack = require(&#39;webpack&#39;); const AddAssetHtmlWebpackPlugin = require(&#39;add-asset-html-webpack-plugin&#39;); ··· plugins: [ ··· // 告诉webpack那些文件不需要打包，以及映射关系 new webpack.DllReferencePlugin({ manifest: resolve(__dirname, &#39;dll/manifest&#39;) }), // 将文件打包输出，并在html自动引入该文件 new AddAssetHtmlWebpackPlugin({ filepath: resolve(__dirname, &#39;dll/&#39;) }) ]","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"pug模板渲染","slug":"笔记/pug模板渲染","date":"2020-09-08T01:04:47.328Z","updated":"2020-09-20T00:35:34.997Z","comments":true,"path":"2020/09/08/笔记/pug模板渲染/","link":"","permalink":"https://easyremember.cn/2020/09/08/笔记/pug模板渲染/","excerpt":"","text":"开始 pug由jade改名而来，通过缩进（表示标签间的嵌套关系）的方式来编写代码的过程，在编译的过程中，不需要考虑标签是否闭合的问题。可以加快写代码速度，也为代码复用提供了便捷。 编译pug模板需要安装npm包 $ npm install pug 新建pug模板 div p #{name}今年#{age}岁了 通过js解析pug模板，需要引入pug模块 const pug = require(&#39;pug&#39;); const compiledFunction = pug.compileFile(&#39;template.pug&#39;); console.log(compiledFunction({ name: &#39;张三&#39;, age: 14, })); console.log(compiledFunction({ name: &#39;李四&#39;, age: 25, })); 使用node运行js文件，结果如图 也可以将解析和渲染放在一起，但是这样会对性能造成影响，这个问题可以通过缓存解决 console.log(pug.renderFile(&#39;template.pug&#39;, { name: &#39;王五&#39;, age: 30, })); 语法注释使用//可以转义生成html注释；使用//-表示pug内部的注释，不转义；条件注释直接写，&lt;开头的会被当作文本 属性用逗号作为属性分隔符，不加也可（可以使用JavaScript表达式）；当属性有很多时可以分多行 div(class=&#39;pug-style&#39; id=&#39;div-1&#39;) - var isTrue = true p(class=isTrue ? &#39;success&#39; : &#39;faild&#39;) #{name}今年#{age}岁了 当属姓名中含有一些可能会产生语法冲突的字符时，使用&quot;&quot;、&#39;&#39;将这些属性名包裹起来，或者使用逗号将前后属性分隔开 属性可以使用JavaScript语法嵌入，例如： - var url = &#39;www.baidu.com&#39; a(href=&#39;http://&#39; + url) 如果运行环境支持ES6，可以使用模板字符串${} 使用!=可以不转义（不推荐，很危险，会遭到脚本攻击） true和false的使用 //- 默认为true input(type=&#39;checkbox&#39; checked) input(type=&#39;checkbox&#39; checked=true) //- fasle不变异 input(type=&#39;checkbox&#39; checked=false) //- toString保留true的值 input(type=&#39;checkbox&#39; checked=true.toString()) //- 编译结果如下 &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot;/&gt; 如果声明doctype html缩写样式checked就不会映射属性 行内样式使用{}，类属性使用[]可以嵌入 a(style={color: &#39;red&#39;, &#39;background-color&#39;: &#39;#409eff&#39;}) - var classes = [&#39;test&#39;, &#39;test2&#39;] a(class=[&#39;blue-div&#39;, &#39;big-div&#39;], class=classes) 属性名有短横线连接的，属性名需要加引号，否则可能会出错 字面值 a.button = &lt;a class=&quot;button&quot;&gt;&lt;/a&gt; .content = &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;（div过于常见，可以省略） a#main-link = &lt;a id=&quot;main-link&quot;&gt;&lt;/a&gt; #content = &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; 使用&amp;attributes可以将一个对象追加到属性列表中（有一定的危险性，减少使用） 分支条件类C语言中都会有switch这个语法，pug中使用case表示 pug中在没有遇到非空语句之前会一直执行下去，当不想传递分支时使用- break来中断分支传递 循环使用for控制循环 -for (var i = 0; i &lt; 5; i++) li item //- 输出 &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; 通过each控制循环 - var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] each item in arr li= item //- 输出 &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; 另外，可以用while控制循环 使用=可以转义代码，等号换行或者行内紧贴父标签；使用!=可以不转义输出，比如携带标点符号等 条件使用if可以进行条件判断 - var user = {name: &#39;张三&#39;} - var isTrue = false div if isTrue h2.blue 描述 else if user h2.green 描述 p.des= user.name else h2.red 描述 //- 输出 &lt;div&gt; &lt;h2 class=&quot;green&quot;&gt;描述&lt;/h2&gt; &lt;p class=&quot;des&quot;&gt;张三&lt;/p&gt; &lt;/div&gt; unless等价于!= 包含使用include关键字引入外部文本，可以是pug文件，也可以是js文件等 被包含的文件的路径，如果是一个绝对路径（如 include /root.pug），那么前面会加上 options.basedir 选项属性来进行解析。否则，路径应该相对于正在被编译的当前文件 嵌入 #{}转义，可以添加正确的任意JavaScript表达式。 如果需要#{}文本，可以使用\\或者#{}来转义 使用!{}不转义，具有一定的危险性 使用#[]转义pug语句 *混入这是pug很强大的一个功能，类似于函数编程，可以传参 mixin eat(food) li 中午吃#{food} ul +eat(&#39;炸鸡&#39;) +eat(&#39;烤鸭&#39;) //- 输出 &lt;ul&gt; &lt;li&gt;中午吃炸鸡&lt;/li&gt; &lt;li&gt;中午吃烤鸭&lt;/li&gt; &lt;/ul&gt; 也可以把代码块传入，类似于Vue的插槽，通过block接收传进来的代码块 mixin user(name) .user h2 #{name} if block block else p 没有详细资料 +user(&#39;张三&#39;) +user(&#39;张三&#39;) p age: 14 p address: china //- 输出 &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;张三&lt;/h2&gt; &lt;p&gt;没有详细资料&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;张三&lt;/h2&gt; &lt;p&gt;age: 14&lt;/p&gt; &lt;p&gt;address: china&lt;/p&gt; &lt;/div&gt; 可以传入属性，在引用混入的时候传入属性 mixin link(href, name) a(class!=attributes.class, href=href) name //- 使用!=防止二次转义 +link(&#39;www.baidu.com&#39;, &#39;百度&#39;)(class=&quot;button&quot;) //- 输出 &lt;a class=&quot;button&quot; href=&quot;www.baidu.com&quot;&gt;name&lt;/a&gt; 支持ES6的展开运算符 mixin ulArr(className, ...items) ul(class=className) each item in items li= item else li 没有内容 +ulArr(&#39;ulArr&#39;, 1,2,3,4) 结束，又一门新技能最后推荐一个在线转换HTML和pug的网站","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Android笔记","slug":"笔记/Android笔记","date":"2020-09-07T12:09:01.520Z","updated":"2020-09-07T12:11:32.797Z","comments":true,"path":"2020/09/07/笔记/Android笔记/","link":"","permalink":"https://easyremember.cn/2020/09/07/笔记/Android笔记/","excerpt":"","text":"Android笔记 xml中的各种字符串数据建议放在values目录下的string.xml中 &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;HelloWorld&lt;/string&gt; &lt;/resources&gt; 1. 活动1.1 创建活动在包下右键创建新的活动 1.2 创建并加载布局在资源目录下的layout文件夹下右键创建新的布局资源（Android Studio默认创建） 配置好布局之后在活动类下添加布局 public class List extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_list); } 1.3在活动中使用ToastToast是安卓应用中一种比较常用的提示方式 添加方法也比较简单 Toast.makeText(this, &quot;click add&quot;, Toast.LENGTH_SHORT).show(); makeText方法参数： this：上下文，如果嵌套太深this指向会错误，可改为当前活动.this、getContext()，也可以在外层定义一个Context that = this;用来传递this “click add”：字符串，Toast要显示的信息，可以是变量 Toast.LENGTH.SHORT：显示时间2秒，LONG是3.5秒 show()方法不要忘记添加 1.4在活动中使用menu在res下创建menu目录，新建xml文件，内容格式如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;Add&quot;/&gt; &lt;item android:id=&quot;@+id/sub_item&quot; android:title=&quot;Sub&quot;/&gt; &lt;/menu&gt; 在要添加menu的活动中添加菜单，格式如下 @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return super.onCreateOptionsMenu(menu); } @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { Context that = this; switch (item.getItemId()) { case R.id.add_item: Toast.makeText(that, &quot;click add&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.sub_item: Toast.makeText(this, &quot;click sub&quot;, Toast.LENGTH_SHORT).show(); break; default: break; } return super.onOptionsItemSelected(item); } 1.5在活动之间穿梭一个安卓应用通常不止一个活动，需要在不同的活动之间来回穿梭来完成各种操作 1.5.1显式穿梭顾名思义，显示穿梭很明显能看出要跳转到那个活动 在页面中有一个按钮，点击按钮触发切换活动的事件 Button btn_third = (Button) findViewById(R.id.btn_third); btn_third.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent3 = new Intent(MainActivity.this, List.class); startActivity(intent3); } }); 先给button添加事件监听，当触发时间时，使用Intent穿梭事件 Intent构造函数： MainActivity.this：上下文 List.class：要跳转的活动（反射） 活动需要在Mainfest中注册，这些在创建活动时Android Studio默认添加了，如果没有会报错 1.5.2隐式穿梭隐式穿梭不会很容易看出要跳转的目的、 首先，隐式穿梭需要配置Mainfest &lt;activity android:name=&quot;.List&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.hello.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;com.example.hello.MY_CATEGORY&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 然后在跳转时使用另一种方式 Button btn_third = (Button) findViewById(R.id.btn_third); btn_third.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent3 = new Intent(&quot;com.example.hello.MAIN&quot;); // 只使用了android.intent.category.DEFAULT，这里可以不添加category,如果自定义了category就必须要添加 intent3.addCategory(&quot;com.example.hello.MY_CATEGORY&quot;); startActivity(intent3); } }); 配置时注意action和category的包路径，只有action和category一致才会进行跳转 更多隐式穿梭用法 跳转网页 点击事件如下 Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;)); startActivity(intent); 在Mainfest对应事件中添加data标签 &lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter tools:ignore=&quot;AppLinkUrlError&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;http&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 拨打电话 1.5.3 活动之间传递数据在许多情况下，活动之间切换需要携带数据，Intent提供了putExtra方法来传递数据，在MainActivity中通过按钮触发事件，携带参数跳转到SecondActivity Button btn = (Button) findViewById(R.id.button1); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, SecondActivity.class); intent.putExtra(&quot;extra_value1&quot;, 10); intent.putExtra(&quot;extra_value2&quot;, &quot;by first&quot;); startActivityForResult(intent, 1); } }); startActivityForResult(intent, 1);不同的请求通过请求码进行区分 在SecondActivity中接收参数并显示到页面上 final Intent intent = getIntent(); String str = intent.getStringExtra(&quot;extra_value2&quot;); int i = intent.getIntExtra(&quot;extra_value1&quot;, -1); // int类型的数据接收时可以设置默认值 String string = str + i; TextView textView = (TextView) findViewById(R.id.textView); textView.setText(string); 1.5.4向上一个活动返回数据当然，SecondActivity也可以向MainActivity传递数据 @Override public void onBackPressed() { // super.onBackPressed(); Intent intent1 = new Intent(); intent1.putExtra(&quot;data_return&quot;, &quot;I am second&quot;); setResult(RESULT_OK, intent1); finish(); } 当按下返回键时（可以通过其他事件触发），向主页面传递数据，这里要设置result返回的状态 在主活动中接收SecondActivity传回来的数据 @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode) { case 1: if (resultCode == RESULT_OK) { assert data != null; String returnStr = data.getStringExtra(&quot;data_return&quot;); Toast.makeText(this, returnStr, Toast.LENGTH_SHORT).show(); } break; default: break; } } onActivityResult(requestCode, resultCode, data) requestCode：请求码，在发送请求时携带的code resultCode：响应码，活动返回数据时设置的code data：接收的数据 1.6 活动的生命周期 1.7 活动的启动模式参考活动的启动模式 2. UI组件相关省略 2.1 布局2.1.1 线性布局LinearLayout android:layout_width=&quot;match_parent&quot;控制宽度，父组件的宽度，改为 wrap_content就是自身元素的宽度 android:layout_height=&quot;match_parent&quot;控制高度 android:orientation=&quot;vertical&quot;控制纵向排列，如果改为 vertical就会变为水平排列 android:layout_gravity=&quot;right&quot;控制元素的对齐方式 android:layout_weight=&quot;1&quot;类似于css中的flex：1 2.1.2 相对布局RelativeLayout相对于parent进行定位 android:layout_alignParentLeft=”true” android:layout_alignParentright=”true” android:layout_alignParentTop=”true” android:layout_alignParentBottom=”true” android:layout_centerInParent=”true” 相对于控件进行定位 android:layout_above=”@id/button3”上 android:layout_below=”@id/button3”下 android:layout_toLeftOf=”@id/button3” android:layout_toRightOf=”@id/button3” android:layout_alignBottom=”@id/button3”两个控件底边对齐 alignBottom、alignTop、alignLeft、alignRight 2.1.3帧布局FrameLayout2.1.4 百分比布局由Android X支持库提供 导入支持库 搜索percentLayout，添加依赖 然后布局文件中使用百分比布局 &lt;androidx.percentlayout.widget.PercentFrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;right&quot; app:layout_widthPercent=&quot;50%&quot; android:src=&quot;@drawable/wj&quot; tools:ignore=&quot;RtlHardcoded&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_close&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; app:layout_widthPercent=&quot;50%&quot; android:text=&quot;关闭&quot; /&gt; &lt;/LinearLayout&gt; &lt;/androidx.percentlayout.widget.PercentFrameLayout&gt; 2.2 控件2.2.1 创建自定义控件首先新建控件的title.xml布局 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;Button android:id=&quot;@+id/back_btn_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#409eff&quot; android:text=&quot;返回&quot; /&gt; &lt;TextView android:id=&quot;@+id/title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#409eff&quot; android:layout_weight=&quot;1&quot; android:text=&quot;TextView&quot; /&gt; &lt;Button android:id=&quot;@+id/edit_btn_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#409eff&quot; android:text=&quot;菜单&quot; /&gt; &lt;/LinearLayout&gt; 然后在想要引入title的布局中引入&lt;include layout=&quot;@layout/title&quot; /&gt;即可 但是这样给title控件添加事件的时候需要给每一个活动都添加，太过于繁琐 于是有了简便的方法 public class TitleLayout extends LinearLayout { public TitleLayout(Context context, @Nullable AttributeSet attrs) { super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title, this); Button back_btn = (Button)findViewById(R.id.back_btn_title); Button edit_btn = (Button)findViewById(R.id.edit_btn_title); back_btn.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { ((Activity)getContext()).finish(); } }); edit_btn.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { Toast.makeText(getContext(), &quot;click edit&quot;, Toast.LENGTH_SHORT).show(); } }); } } 然后在想要引入控件的活动xml中使用包名引入 &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;com.example.helloworld.TitleLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;/LinearLayout&gt; 2.2.2 ListView列表控件首先创建ListView布局 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;ListView android:id=&quot;@+id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 然后在活动中添加 public class List extends AppCompatActivity { private String[] data = {&quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;fire&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;fire&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;fire&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;, &quot;fire&quot;}; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_list); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(List.this, android.R.layout.simple_list_item_1, data); ListView listView = (ListView) findViewById(R.id.list); listView.setAdapter(adapter); } } 定制ListView 图标 新建一个菜单类，属性是名称和图标 public class Fruit { private String name; private int imageId; public Fruit(String name, int imageId) { this.name = name; this.imageId = imageId; } public String getName() { return name; } public int getImageId() { return imageId; } } 新建list选项布局 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; /&gt; &lt;/LinearLayout&gt; 新建适配器继承自ArrayAdapter public class FruitAdapter extends ArrayAdapter { private int resourceId; public FruitAdapter(@NonNull Context context, int resource, @NonNull List&lt;Fruit&gt; objects) { super(context, resource, objects); resourceId = resource; } @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) { Fruit fruit = (Fruit) getItem(position); @SuppressLint(&quot;ViewHolder&quot;) View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; } } 最后再修改List活动 public class FruitList extends AppCompatActivity { private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_list); addData(); FruitAdapter fruitAdapter = new FruitAdapter(FruitList.this, R.layout.fruit_item, fruitList); ListView listView = (ListView)findViewById(R.id.list); listView.setAdapter(fruitAdapter); } // 初始化list private void addData() { for(int i = 0; i &lt; 10; i++) { Fruit apple = new Fruit(&quot;apple&quot;, R.drawable.icon); fruitList.add(apple); } } } 然后运行出来的List就带上了图标 点击事件 在List活动中添加事件监听 listView.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { Fruit fruit = fruitList.get(position); Toast.makeText(FruitList.this, fruit.getName(), Toast.LENGTH_SHORT).show(); } }); 优化 public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) { Fruit fruit = (Fruit) getItem(position); // @SuppressLint(&quot;ViewHolder&quot;) View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); View view; if(convertView == null) { view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); } else { view = convertView; } ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; } 对convertView进行判断，当为空时使用LayoutInflater加载布局，不为空时直接使用convertView，提高了运行效率 public class FruitAdapter extends ArrayAdapter { private int resourceId; public FruitAdapter(@NonNull Context context, int resource, @NonNull List&lt;Fruit&gt; objects) { super(context, resource, objects); resourceId = resource; } @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) { Fruit fruit = (Fruit) getItem(position); // @SuppressLint(&quot;ViewHolder&quot;) View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); View view; ViewHolder viewHolder; if(convertView == null) { view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView)view.findViewById(R.id.fruit_image); viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_name); view.setTag(viewHolder); } else { view = convertView; viewHolder = (ViewHolder) view.getTag(); } viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; } class ViewHolder { ImageView fruitImage; TextView fruitName; } } 修改FruitAdapter，新建内部类，对控件实例进行缓存，新建实例时通过setTag方法将实例存储，convertView不为空时使用getTag获取缓存的实例 2.2.3 RecycleView3. 碎片碎片可以有效解决手机平板分辨率不同产生的布局难看的问题，当屏幕分辨率大的时候引入两个碎片 3.1 碎片使用创建碎片 设置好碎片布局之后在活动的xml布局中引入fragment，选择要引入的碎片，调整布局 效果如图 3.2 动态使用碎片再创建一个新的右侧碎片 修改当前活动 public class MainActivity2 extends AppCompatActivity implements View.OnClickListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Button button = (Button)findViewById(R.id.left_btn); button.setOnClickListener(this); replaceFragment(new FragmentRight()); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.left_btn: replaceFragment(new FragmentAnotherRight()); break; default: break; } } public void replaceFragment(Fragment fragment) { FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.right_layout, fragment); fragmentTransaction.commit(); } } 活动创建时初始化一个右侧碎片，当左侧按钮触发时更换一个右侧碎片 3.3 返回栈实现了动态添加碎片之后还有一个问题，当点击返回按钮时会直接退出活动，要返回上一个碎片就需要添加一个返回栈 只需要修改replaceFragment方法，调用addToBackStack方法，一般传入null即可 public void replaceFragment(Fragment fragment) { FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.right_layout, fragment); fragmentTransaction.addToBackStack(null); fragmentTransaction.commit(); } 3.4 碎片通信 3.5 碎片生命周期 3.6 使用限定符响应式布局在res目录下新建layout-large或者layout-sw600dp文件夹，新建一个同名的活动布局，当满足条件时，安卓会自动加载相应的布局 普通的布局只有一个fragment大屏设备的引入两个fragment 手机模拟器 平板模拟器 4. 广播机制4.1 简介 标准广播：异步执行，所有的广播接收器会在同一时间接收到广播消息，不能被截断 有序广播：同步执行，只有一个接收器能接受广播消息，接收完才能依次执行，可以被截断 4.2 接收广播4.2.1 动态注册广播接收器可以动态的对自己感兴趣的广播进行注册，可以在代码中注册也可以在AndroidMainfest中注册，前者称为动态注册，后者称为静态注册 4.2.1.1 动态注册监听网络变化在代码中进行注册 public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private NetworkChangeReceiver changeReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ActivityController.addActivity(this); // 广播 intentFilter = new IntentFilter(); intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); changeReceiver = new NetworkChangeReceiver(); registerReceiver(changeReceiver, intentFilter); } @Override public void onDestroy() { super.onDestroy(); unregisterReceiver(changeReceiver); } } public class NetworkChangeReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { ConnectivityManager connectivityManager = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo(); if(networkInfo != null &amp;&amp; networkInfo.isConnected()) { Toast.makeText(context, &quot;网络已连接&quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(context, &quot;网络未连接&quot;, Toast.LENGTH_SHORT).show(); } } } connectivityManager.getActiveNetworkInfo();需要添加权限，Android Studio可以自动添加 当网络连接发生变化时会弹出Toast进行消息提示 4.2.2 静态注册开机自启 new -&gt; other -&gt; Broadcast Recriver 在AndroidMainfest.xml中添加代码 &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; ··· &lt;application&gt; ··· &lt;receiver android:name=&quot;.BootCompleteReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt; 4.3 发送自定义广播4.3.1 标准广播新建一个广播接收器，并静态注册，这里的action是自定义的不再是系统服务 在活动中通过按钮发送广播并携带数据 Button btn_receiver = (Button)findViewById(R.id.btn_receiver); btn_receiver.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(&quot;com.example.helloworld.MY_RECEIVER&quot;); intent.putExtra(&quot;my_blog&quot;, &quot;test&quot;); sendBroadcast(intent); } }); 在接收器中接收数据并显示 public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String msg = intent.getStringExtra(&quot;my_blog&quot;); Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); } } 4.3.2 有序广播4.4 本地广播全局系统的广播存在安全隐患容易被其他程序截获，本地广播只能在程序内部进行传递，提高安全性 导入第三方依赖LocalBroadcastManager 新建本地广播接收器 在活动中动态注册接收器，并添加事件发送广播 `javapublic class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private LocalBroadcastManager localBroadcastManager; private LocalReceiver localReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ActivityController.addActivity(this); intentFilter = new IntentFilter(); localBroadcastManager = LocalBroadcastManager.getInstance(this); intentFilter.addAction(&quot;com.example.helloworld.LOCAL_BROADCAST&quot;); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); Button btn_local = (Button)findViewById(R.id.btn_local); btn_local.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(&quot;com.example.helloworld.LOCAL_BROADCAST&quot;); intent.putExtra(&quot;my_blog&quot;, &quot;test local&quot;); localBroadcastManager.sendBroadcast(intent); } }); } @Override public void onDestroy() { super.onDestroy(); localBroadcastManager.unregisterReceiver(localReceiver); } } &gt; 本地广播只能动态注册 ### 4.5 最佳实践——强制下线 + 创建广播接收器接收强制下线广播 + 接收器添加提示框提示强制下线 + 关闭所有活动，通过ActivityController + 重启登陆活动 ## 5. 数据持久化 ### 5.1 文件存储 新建一个文件操作活动，在布局文件中添加一个`EditText` ```xml &lt;EditText android:id=&quot;@+id/file_edit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:hint=&quot;edit in here&quot; /&gt; 5.1.1 将数据存储到文件在活动中添加代码，编写保存文件的方法并且在活动销毁时触发保存事件 public class FileActivity extends AppCompatActivity { private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_file); editText = (EditText)findViewById(R.id.file_edit); } @Override protected void onDestroy() { super.onDestroy(); String input = editText.getText().toString(); save(input); } public void save(String inputText) { FileOutputStream fileOutputStream = null; BufferedWriter bufferedWriter = null; try { fileOutputStream = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); bufferedWriter = new BufferedWriter(new OutputStreamWriter(fileOutputStream)); bufferedWriter.write(inputText); } catch (IOException e) { e.printStackTrace(); } finally { if(bufferedWriter != null) { try { bufferedWriter.close(); Toast.makeText(FileActivity.this, &quot;saved success&quot;, Toast.LENGTH_SHORT).show(); } catch (IOException e) { e.printStackTrace(); } } } } } 5.1.2 从文件中读取数据在活动中增加加载方法，活动创建时先读取文件，有文件直接加载 public class FileActivity extends AppCompatActivity { private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_file); editText = (EditText)findViewById(R.id.file_edit); String text = load(); if(!TextUtils.isEmpty(text)) { editText.setText(text); editText.setSelection(text.length()); Toast.makeText(FileActivity.this, &quot;loading success&quot;, Toast.LENGTH_SHORT).show(); } } ··· public String load() { FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try { in = openFileInput(&quot;data&quot;); reader = new BufferedReader(new InputStreamReader(in)); String line = &quot;&quot;; while((line = reader.readLine()) != null) { content.append(line); } } catch (IOException e) { e.printStackTrace(); } finally { if(reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } return content.toString(); } } 5.2 SharedPreferences存储存储文件是xml格式 首先创建一个活动，布局中添加两个按钮，一个save一个load 5.2.1将数据存储到SharedPreferences中首先需要获取SharedPreferences对象，Android中提供了三种方式获取SharedPreferences对象 Context类中的getSharedPreferences()方法，两个参数：指定SharedPreferences文件名；指定操作模式，目前只有MODE_PRIVATE可选 Activity类中getPreferences()方法：只有一个参数：操作模式。（默认当前活动名为SharedPreferences文件名） PreferenceManager类中getDefaultSharedPreferences()方法：静态方法，接收一个Context参数，使用当前包名为前缀来命名SharedPreferences文件 SharedPreferences.Editor editor = getSharedPreferences(&quot;data_preference&quot;, MODE_PRIVATE).edit(); editor.putString(&quot;name&quot;, &quot;Tom&quot;); editor.putInt(&quot;age&quot;, 20); editor.putBoolean(&quot;married&quot;, false); editor.apply(); 5.2.2从SharedPreferences中读取数据从上面可以看出SharedPreferences存储文件非常简单，读取文件更为简便，从SharedPreferences对象中一系列get方法即可获得数据 SharedPreferences editor_load = getSharedPreferences(&quot;data_preference&quot;, MODE_PRIVATE); String name = editor_load.getString(&quot;name&quot;, &quot;&quot;); int age = editor_load.getInt(&quot;age&quot;, 0); Boolean married = editor_load.getBoolean(&quot;married&quot;, false); 5.2.3 代码及效果展示public class PreferencesActivity extends AppCompatActivity implements View.OnClickListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_preferences); Button btn_save = (Button)findViewById(R.id.btn_preference_save); btn_save.setOnClickListener(this); Button btn_load = (Button)findViewById(R.id.btn_preference_load); btn_load.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn_preference_save: SharedPreferences.Editor editor = getSharedPreferences(&quot;data_preference&quot;, MODE_PRIVATE).edit(); editor.putString(&quot;name&quot;, &quot;Tom&quot;); editor.putInt(&quot;age&quot;, 20); editor.putBoolean(&quot;married&quot;, false); editor.apply(); Toast.makeText(PreferencesActivity.this, &quot;file save succeed&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.btn_preference_load: SharedPreferences editor_load = getSharedPreferences(&quot;data_preference&quot;, MODE_PRIVATE); String name = editor_load.getString(&quot;name&quot;, &quot;&quot;); int age = editor_load.getInt(&quot;age&quot;, 0); Boolean married = editor_load.getBoolean(&quot;married&quot;, false); String marry = married?&quot;结婚了&quot;:&quot;没结婚&quot;; Toast.makeText(PreferencesActivity.this, name+&quot;今年&quot;+age+&quot;岁&quot;+marry, Toast.LENGTH_SHORT).show(); break; default: break; } } } 5.3 数据库SQLiteSQLite是一款轻量级关系数据库，支持SQL语法，遵循ACID 5.3.1 创建数据库略 5.3.2 LitePal操作数据库通过JavaBean操作数据库 引入依赖LitePal 配置xml映射app.src.main目录下新建assets目录，新建litepal.xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;litepal&gt; &lt;dbname value=&quot;BookStore&quot; /&gt; &lt;version value=&quot;1&quot; /&gt; &lt;list&gt;&lt;/list&gt; &lt;/litepal&gt; 修改Mainfest，application新加属性android:name=&quot;org.litepal.LitePalApplication&quot; 创建数据库创建JavaBean 添加活动代码，当数据库访问一次之后就创建了 对数据进行操作需要让JavaBean继承DataSupport 添加数据 更新数据一种方法是将要修改的数据值全部set然后save在set要修改的值再次save 另一种方法用updateAll book.setPrice(14.5); book.updateAll(&quot;name = ? and author = ?&quot;, &quot;Tom&quot;,&quot;第一行代码&quot;); 设置要修改的价格，然后使用updateAll方法，方法中的参数是约束条件，当当与where查询，只修改匹配到的信息 删除数据使用DataSupport中的deleteAll方法，第一个参数是眼删除的表名，第二个参数是查询条件 DataSupport.deleteAll(Book.class, &quot;price &lt; ?&quot;, &quot;14&quot;); 查询数据使用 List&lt;Book&gt; list = DataSupport.findAll(Book.class);可以将所有的数据返回到一个List中 此外，还支持原生查询 Cursor cursor = DataSupport.findBySQL(&quot;select * from book where name = ?&quot;, &quot;第一行代码&quot;); 返回的是一个Cuesor对象，需要将数据一一取出 6. 跨程序共享数据——内容提供器6.1 运行时权限安卓6.0以上加入了运行时权限，危险权限需要用户授权 参考代码 public class PermissionActivity extends AppCompatActivity { List&lt;String&gt; contacts = new ArrayList&lt;&gt;(); ArrayAdapter&lt;String&gt; adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission); ListView list = (ListView) findViewById(R.id.list_contact); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, contacts); list.setAdapter(adapter); if (ContextCompat.checkSelfPermission(PermissionActivity.this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(PermissionActivity.this, new String[]{Manifest.permission.READ_CONTACTS}, 1); } else { readContacts(); } } private void readContacts() { Cursor cursor = null; try { cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); if(cursor != null) { while (cursor.moveToNext()) { String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); contacts.add(name+ &quot;\\n&quot; +number); } adapter.notifyDataSetChanged(); } } catch (Exception e) { e.printStackTrace(); } finally { if(cursor != null) { cursor.close(); } } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { readContacts(); } else { Toast.makeText(PermissionActivity.this, &quot;no permission&quot;, Toast.LENGTH_SHORT).show(); } break; default: break; } } } 6.2 创建内容提供器7. 运用手机多媒体7.1 使用通知首先获取通知管理器对象，然后创建通知对象，通过通知管理器下发通知，每个通知的id都是不同的 代码示例通过按钮触发通知 Button btn_notification = (Button)findViewById(R.id.btn_notification); btn_notification.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); Notification notification = new Notification.Builder(PermissionActivity.this) .setContentTitle(&quot;1条新消息&quot;) .setContentText(&quot;XXX请求添加好友&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .build(); manager.notify(1, notification); } }); 这里可以看到按钮点击之后通知栏显示了一条通知 但是，这里的通知不能点击，要再让它可以点击 这时需要用到PendingIntent，可以理解为延时的Intent 将代码稍作改装，就得到了可以点击的通知 Button btn_notification = (Button)findViewById(R.id.btn_notification); btn_notification.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(PermissionActivity.this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(PermissionActivity.this, 0, intent, 0); NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); Notification notification = new Notification.Builder(PermissionActivity.this) .setContentTitle(&quot;1条新消息&quot;) .setContentText(&quot;XXX请求添加好友&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pendingIntent) .build(); manager.notify(1, notification); } }); 距离完成还差一步，点击通知之后通知应该是消失的 有两种方法： 通知追加setAutoCancel方法 ··· .setAutoCancel(true) 通过通知管理器的canael方法根据通知id消除通知 ··· NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); manager.cancel(1) 长文本通知 .setStyle(new Notification.BigTextStyle().bigText(&quot;* 当URL没有指定文件名时(比如：https://www.w3schools.com/css/)，&quot; + &quot;服务器将返回默认的文件名，&quot; + &quot;通用的默认文件名是：index.html、index.htm、default.html、和default.html\\n&quot; + &quot;* 但如果你的服务器仅配置了“index.html”作为默认文件名，那么你的文件就必须命名index.html，不能用index.htm\\n&quot; + &quot;* 不过服务器可以配置多个默认的文件名，所以你可以根据需要设置多个默认文件名\\n&quot; + &quot;* 总而言之，HTML文件的完整扩展名是.html，我们没有理由不用它啊~~~&quot;)) 图片通知： .setStyle(new Notification.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.wj))) 7.2 调用摄像头和相册8. 网络8.1 webView应用程序内引入网页，不需要打开系统浏览器 创建活动，布局添加webview组件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.WebActivity&quot;&gt; &lt;WebView android:id=&quot;@+id/web_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 编辑活动代码 public class WebActivity extends AppCompatActivity { @SuppressLint(&quot;SetJavaScriptEnabled&quot;) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_web); WebView webView = (WebView)findViewById(R.id.web_view); // 设置允许js，否则网页逻辑可能无法运行 webView.getSettings().setJavaScriptEnabled(true); webView.setWebViewClient(new WebViewClient()); webView.loadUrl(&quot;http://www.baidu.com&quot;); } } 该活动需要网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 8.2 HTTP协议访问网络8.2.1 HttpURLConnection安卓上发送HTTP请求有两种方式HttpURLConnection和HttpClient，由于HttpClientd的API数量多，扩展困难已经在6.0被移除 创建布局 &lt;Button android:id=&quot;@+id/btn_http&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;HTTP请求&quot; /&gt; &lt;TextView android:id=&quot;@+id/text_http&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 编辑活动代码 public class WebActivity extends AppCompatActivity { TextView responseText; @SuppressLint(&quot;SetJavaScriptEnabled&quot;) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_web); Button sentRequest = (Button)findViewById(R.id.btn_http); responseText = (TextView)findViewById(R.id.text_http); sentRequest.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { sendRequestWithHttpURLConnection(); } }); } private void sendRequestWithHttpURLConnection() { new Thread(new Runnable() { @Override public void run() { // 创建HttpURLConnection对象 HttpURLConnection connection = null; BufferedReader reader = null; try { // URL URL url = new URL(&quot;http://www.baidu.com&quot;); connection = (HttpURLConnection)url.openConnection();// 建立连接 connection.setRequestMethod(&quot;GET&quot;);// 请求方式 connection.setConnectTimeout(8000);// 超时时间 connection.setReadTimeout(8000); InputStream in = connection.getInputStream(); // 获取输入流 reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { response.append(line); } showResponse(response.toString()); } catch (Exception e) { e.printStackTrace(); } finally { // 完成后需要关闭连接 if(reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } if(connection != null) { connection.disconnect(); } } } }).start(); } private void showResponse(final String response) { runOnUiThread(new Runnable() { @Override public void run() { responseText.setText(response); } }); } } 耗时的操作不能再主线程中进行，开一个线程处理； new Thread().start; 不要忽略start 更新UI不能在子线程中，会闪退，通过runOnUiThread切换回主线程 POST请求 connection.setRequestMethod(&quot;POST&quot;);// 请求方式 DataOutputStream out = new DataOutputStream(connection.getOutputStream()); out.writeBytes(&quot;name=Tom&amp;password=123456&quot;); 在获取输入流之前把要提交的数据写入 8.2.2 使用OKHttp在AndroidX中添加依赖okhttp（squareup公司的） 添加新的方法使用OkHttp，把button的绑定事件改为sendRequestWithOkHttp private void sendRequestWithOkHttp() { new Thread(new Runnable() { @Override public void run() { try { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(&quot;http://www.baidu.com&quot;).build(); Response response = client.newCall(request).execute(); String responseData = Objects.requireNonNull(response.body()).string(); showResponse(responseData); } catch (Exception e) { e.printStackTrace(); } } }).start(); } 就可以看到跟原来一样的效果 8.3 解析XML数据进行网络传输通常有两种格式XML和JSON 课本P334 8.4 解析JSON数据 使用GSON 添加依赖gson 可以把JSON的格式映射成一个对象 8.5 网络方法封装将网络方法封装到HttpUtil类中，方法作为静态方法直接调用 如 public class HttpUtil { public static void sendGetRequestWithOkHttp(String address, okhttp3.Callback callback) { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); } } 调用 private void sendRequestWithOkHttp() { new Thread(new Runnable() { @Override public void run() { HttpUtil.sendGetRequestWithOkHttp(&quot;http://www.baidu.com&quot;, new okhttp3.Callback() { @Override public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException { String responseData = Objects.requireNonNull(response.body()).string(); showResponse(responseData); } @Override public void onFailure(@NotNull Call call, @NotNull IOException e) { e.printStackTrace(); } }); } }).start(); }","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/tags/笔记/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Vue中的跨域问题","slug":"技术/Vue中的跨域问题","date":"2020-09-07T10:08:59.597Z","updated":"2020-09-07T11:12:50.343Z","comments":true,"path":"2020/09/07/技术/Vue中的跨域问题/","link":"","permalink":"https://easyremember.cn/2020/09/07/技术/Vue中的跨域问题/","excerpt":"","text":"Vue中的跨域问题什么是跨域？跨域问题其实就是浏览器的同源策略所导致的。 「同源策略」是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 MDN 什么是同源呢？ 协议+域名+端口，三者一致认为是同源 例如： http://www.baidu.com:8080和http://www.baidu.com:8081二者端口不一样，跨域 http://www.jingdong.com和http://www.baidu.com二者域名不一样，跨域 https://www.baidu.com和http://www.baidu.com二者协议端口都不一样，跨域（https://默认端口443，http://默认端口80） http://www.baidu.com/a.js和http://www.baidu.com/b.js，这两者是同源的 怎么解决跨域 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 加粗为常用，jsonp基本过时，了解一下原理 JSONP在发送Ajax请求时，不论请求的资源是何种类型都通不过同源策略，但是！！！你会发现&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;等没有这种限制。然后，js是支持json的，那么把json数据放到js中就可以接收了。废话少说上代码 &lt;!--本地请求--&gt; &lt;script&gt; var local = function(data) { console.log(&#39;请求到的数据是：&#39;, data); } &lt;/script&gt; &lt;script src=&quot;/js/jsonp.js&quot;&gt;&lt;/script&gt;&lt;!--可以是请求接口--&gt; &lt;!--服务器（js）--&gt; local(&#39;data from jsonp!&#39;) 然后运行页面 完事，这就是jsonp，jquery的ajax中也提供了jsonp的请求方式，缺陷只能发送GET请求 CORS普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 Vue跨域解决在vue.config.js中配置跨域，注释已经很清楚了吧，不懂可以QQ，微信，电邮问我 module.exports = { devServer: { host: &quot;localhost&quot;, port: 8000, // 端口号 https: false, // 是否https open: true, //配置自动启动浏览器 // proxy: &#39;http://127.0.0.1:8080&#39; // 配置跨域处理,只有一个代理 // 配置多个代理 proxy: { &#39;/socket.io&#39;: { target: &#39;http://127.0.0.1:7001/&#39;, // 要访问的接口 ws: true, // 是否启用websockets changeOrigin: true, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite: { &#39;^/api&#39;: &#39;&#39; //在请求中用&#39;/api&#39;代替target里面的地址,比如我要调用&#39;http://40.00.100.100:3002/user/add&#39;，直接写&#39;/api/user/add&#39;即可 } }, } } };","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Socket.IO前端后端一起拿捏","slug":"技术/Socket.IO前端后端一起拿捏","date":"2020-09-07T09:17:53.747Z","updated":"2020-09-08T11:08:21.502Z","comments":true,"path":"2020/09/07/技术/Socket.IO前端后端一起拿捏/","link":"","permalink":"https://easyremember.cn/2020/09/07/技术/Socket.IO前端后端一起拿捏/","excerpt":"","text":"Socket.IO前端后端一起拿捏后端——Egg 环境搭建后端socket使用Egg的周边——egg-socket.io 安装运行命令安装 $ npm i egg-socket.io --save 配置在plugin中开启插件 io: { enable: true, package: &#39;egg-socket.io&#39;, }, 在config中配置插件相关信息 // socket config.io = { // init: { wsEngine: &#39;uws&#39; }, init: {}, // 默认ws namespace: { // 命名空间 &#39;/&#39;: { connectionMiddleware: [ &#39;connection&#39; ], // 连接中间件 packetMiddleware: [ &#39;filter&#39; ], // 数据包中间件 }, }, }; 目录结构 编码首先把刚才配置文件中的两个中间件编写完成 connection.ts import { Context } from &#39;egg&#39;; // 这个中间件的作用是提示用户连接与断开的，连接成功的消息发送到客户端，断开连接的消息在服务端打印 export default function connection(): any { return async (ctx: Context, next: () =&gt; Promise &lt; any &gt;) =&gt; { ctx.socket.emit(&#39;res&#39;, &#39;connected!&#39;); await next(); // execute when disconnect. console.log(&#39;disconnection!&#39;); }; } filter.ts import { Context } from &#39;egg&#39;; // 这个中间件的作用是将接收到的数据再发送给客户端 export default function filter(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { ctx.socket.emit(&#39;res&#39;, &#39;packet received!&#39;); console.log(&#39;packet:&#39;, ctx.packet); await next(); }; } 然后配置路由，通过路由分发给controller处理 import { Application } from &#39;egg&#39;; export default (app: Application) =&gt; { const { controller, router, middleware, io } = app; io.route(&#39;chat&#39;, io.controller.chat.index); // 这里需要注意route的两个参数，第一个参数要与第二个参数controller的文件名一致 // 如果配置中有其他的命名空间‘/othername’，路由配置方法如下 // io.of(&#39;/othername&#39;).route(&#39;default&#39;, io.controller.default.index); }; 注意，因为egg-socket.io中没有.d.ts，所以io会挂载不到app上，在下面的目录下添加代码即可 添加代码如下 import { Socket, Server } from &#39;socket.io&#39;; declare module &#39;egg&#39; { export interface Application { io: Serverr &amp; EggSocketIO &amp; Namespace; } export interface Context { socket: Socket } interface EggSocketIO { middleware: xxx; controller: xxx; } interface Namespace { route(event: string, handler: Function): any } } 然后就是controller的代码了 import { Controller } from &#39;egg&#39;; export default class ChatController extends Controller { public async index() { const { ctx } = this; const message = ctx.args[0]; ctx.socket.emit(&#39;res&#39;, `Hi! I&#39;ve got your message: ${message}`); // 这里可以调用service，只是示例就不搞辣么复杂了 } } /* // 在controller 中 // 发送给自己 this.socket.emit(&#39;eventName&#39;, &#39;value&#39;); // 发送给除了自己外的所有人 this.socket.broadcast.emit(&#39;eventName&#39;, &#39;value&#39;); // 发送给所有人，包括自己 this.server.sockets.emit(&#39;eventName&#39;, &#39;value&#39;); */ 测试代码写完然后使用socket.io-client测试一下连接（需要使用npm安装， npm install socket.io-client –save） // eslint-disable-next-line @typescript-eslint/no-var-requires const socket = require(&#39;socket.io-client&#39;)(&#39;http://127.0.0.1:7001/&#39;); socket.on(&#39;connect&#39;, () =&gt; { console.log(&#39;connect!&#39;); socket.emit(&#39;chat&#39;, &#39;hello world!&#39;); }); socket.on(&#39;res&#39;, msg =&gt; { console.log(&#39;res from server: %s!&#39;, msg); }); 然后node ./client.js 客户端运行结果如下 服务端结果如下（关闭服务端时触发中间件，打印了disconnection） 试了很多办法，一直没法用ws访问连接，只能通过socket.io-client跑通 代码代码已经上传码云#socket 前端——Vue 前端使用vue-socket.io，这其实是对socket.io-client的封装，然后挂载到Vue实例 使用也是很简单，安装npm包 $ npm install vue-socket.io --save 然后配置main.js，将组件挂载到Vue实例 import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; import router from &#39;./router&#39; import store from &#39;./store&#39; import VueSocketIO from &#39;vue-socket.io&#39; Vue.config.productionTip = false Vue.use(new VueSocketIO({ debug: false, // 生产环境关闭 connection: &#39;http://127.0.0.1:7001&#39;, vuex: { // store, // actionPrefix: &#39;SOCKET_&#39;, // mutationPrefix: &#39;SOCKET_&#39; }, // options: { path: &quot;/my-app/&quot; } })) new Vue({ router, store, render: h =&gt; h(App) }).$mount(&#39;#app&#39;) 然后新建一个page，这里只加了一个简单的按钮来触发事件 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;sendMessageToServer&quot;&gt;send&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { msg: &#39;&#39; } }, sockets: { connect: function () { console.log(&#39;连接成功&#39;); }, res: function (val) { console.log(&#39;接收到服务端消息:&#39;, val); }, }, methods: { sendMessageToServer: function() { this.$socket.emit(&#39;chat&#39;, &#39;test111&#39;); // 第一个参数决定了调用后端的哪个socket路由 } } } &lt;/script&gt; &lt;style lang=&quot;less&quot; scoped&gt; &lt;/style&gt; 然后运行项目，查看效果 实战先来看效果 东西就这么个东西，感觉没啥好说的，直接上代码吧，传送门 主要记一下过程中遇到的问题 给输入框添加回车事件时，第三方框架中不可以直接用`@keyup.enter，而是要用@keyup.enter.native` 后端在往前端发送消息时使用的主题是什么，前端就用什么主题接收，比如","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"node","slug":"node","permalink":"https://easyremember.cn/tags/node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Vue插槽组件","slug":"技术/Vue组件之slot插槽","date":"2020-08-30T08:09:24.323Z","updated":"2020-09-05T09:34:39.830Z","comments":true,"path":"2020/08/30/技术/Vue组件之slot插槽/","link":"","permalink":"https://easyremember.cn/2020/08/30/技术/Vue组件之slot插槽/","excerpt":"","text":"Vue组件之slot插槽 vue里提供了一种将父组件的内容和子组件的模板整合的方法：内容分发，通过slot插槽来实现。 匿名插槽父组件使用子组件时，在子组件标签内部编写内容，子组件内部可以使用来接收传入的内容，插槽可以设置默认内容，当无内容传入时使用默认内容 &lt;!-- SlotTest.vue --&gt; &lt;template&gt; &lt;div&gt; 下面是solt接收到的值： &lt;slot&gt;default data&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 在父组件中直接使用子组件，没有传入数据 &lt;template&gt; &lt;div&gt; &lt;slot-test&gt; &lt;!-- data from father --&gt; &lt;/slot-test&gt; &lt;/div&gt; &lt;/template&gt; 可以看到渲染子组件的时候使用了默认值 然后将子组件中加入数据，子组件中渲染了父组件中传入的数据 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 意思是：通过这种方式传递的参数（data=”slot data”），只能在子组件中访问到（通过props接收），父组件中是访问不到的 具名插槽当组件中需要多个插槽时，使用匿名插槽会非常不方便 标签有一个name属性，用来定义额外插槽，具名插槽中的内容使用标签包裹，声明v-slot:name，配对的内容放置到相应的插槽内部，其余内容放置到默认插槽中 &lt;!-- father --&gt; &lt;template&gt; &lt;div&gt; &lt;slot-test&gt; 这里 &lt;template v-slot:first&gt; 第一个插槽 &lt;/template&gt; &lt;template v-slot:second&gt; 第二个插槽 &lt;/template&gt; 其余内容全部放到默认插槽 &lt;/slot-test&gt; &lt;/div&gt; &lt;/template&gt; &lt;!-- son --&gt; &lt;template&gt; &lt;div&gt; 下面是solt接收到的值： 1. &lt;slot name=&quot;first&quot;&gt;default data&lt;/slot&gt; 2. &lt;slot name=&quot;second&quot;&gt;default data&lt;/slot&gt; 3. &lt;slot&gt;default data&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 来看一下眼效果，很清晰明了。任何没有被包裹在带有 v-slot 的 &lt;template&gt; 中的内容都会被视为默认插槽的内容，相当于 作用域插槽当我们想在父组件中访问子组件内部的一些数据时，就需要在子组件内部的元素上动态绑定一个自定义属性，将数据传递到自定义属性上，通过slot传递给父组件使用 代码示例 &lt;!-- 子组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;slot name=&quot;user&quot; v-bind:user=&quot;user&quot;&gt; &lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { user: { name: &#39;张三&#39;, age: 15 } } }, } &lt;/script&gt; &lt;!-- 父组件 --&gt; &lt;template&gt; &lt;div&gt; &lt;slot-test&gt; &lt;template v-slot:user=&quot;slotProps&quot;&gt; {{slotProps.user.name}}今年{{slotProps.user.age}}岁。 &lt;/template&gt; &lt;/slot-test&gt; &lt;/div&gt; &lt;/template&gt; 当独占默认插槽时可以简写为（不可以和具名插槽混用） &lt;slot-test v-slot=&quot;slotProps&quot;&gt; {{slotProps.user.name}}今年{{slotProps.user.age}}岁。 &lt;/slot-test&gt; 更多用法","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"小爱课程表使用手册","slug":"生活/小爱课程表使用文档——山东工商学院-SDTBU","date":"2020-08-28T11:08:09.118Z","updated":"2020-09-14T11:28:51.463Z","comments":true,"path":"2020/08/28/生活/小爱课程表使用文档——山东工商学院-SDTBU/","link":"","permalink":"https://easyremember.cn/2020/08/28/生活/小爱课程表使用文档——山东工商学院-SDTBU/","excerpt":"","text":"小爱课程表使用手册——山东工商学院-SDTBU 注意：需要小米手机或者非小米手机安装小爱课程表APP非小米手机可能会有部分功能无法使用 效果展示 正式步骤1. 打开小爱课表 控制中心下拉打开小爱捷径（没有可以在编辑中加入），小爱捷径找到课程表捷径 唤醒小爱同学语音助手，告诉她“课程表” 2. 设置打开小爱课程表设置，将一天上课节数调整为10（4-4-2） 3. 选择学校需要提前连接校园网 打开小爱课程表右上角设置，下拉找到选择学校 输入山东工商学院，选项中找到并点击【山东工商学院-SDTBU】 点击教务网站导入 4. 导入课表 点击教务管理系统学生端，登录智慧山商 登录之后点击学期课表 打开要添加的学期课表之后点击屏幕下方一键导入 PS：如果没绑定手机号可能会让你绑定手机，点击取消之后进入的是那个绿色的智慧山商，这时候要退出到小爱课表的设置界面，再点导入键重新进入，一定要是图上的页面才可以导入 PPS：当前周数不对可以在设置中调整 5. 反馈如果信息导入成功点击一个完美支持一下，如果存在导入失败或存在使用问题加Q反馈，点击这里加Q","categories":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/categories/工具/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://easyremember.cn/tags/悦读/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/categories/工具/"}]},{"title":"对比call和apply","slug":"技术/call和apply","date":"2020-08-27T14:47:40.917Z","updated":"2020-09-09T02:55:14.055Z","comments":true,"path":"2020/08/27/技术/call和apply/","link":"","permalink":"https://easyremember.cn/2020/08/27/技术/call和apply/","excerpt":"","text":"call&amp;apply&amp;bindcallcall方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数 语法function.call(thisArg, arg1, arg2, ...) 参数 thisArg：在 function 函数运行时使用的 this 值 arg1, arg2, …：参数列表 示例function fullName() { return this.firstName + this.lastName } function Person(first, last) { this.firstName = first this.lastName = last } var p = new Person(&#39;zhang&#39;, &#39;san&#39;) var p2 = new Person(&#39;li&#39;, &#39;si&#39;) console.log(fullName.call(p)); console.log(fullName.call(p2)); 首先实例化两个Person对象，然后将两个对象实例传给fullName.call() 可以看到控制台已经打印出了两个实例的信息 再来看一下带参数的，这是与apply方法的区别之处 var obj = { name: &#39;张三&#39;, age: 19, func: function (from, to) { console.log(this.name + &#39;今年&#39; + this.age + &#39;,从&#39; + from + &#39;来，要到&#39; + to + &#39;去&#39;); } } obj.func(&#39;北京&#39;, &#39;上海&#39;) var p = { name: &#39;李四&#39;, age: 25 } obj.func.call(p, &#39;天津&#39;, &#39;南京&#39;) apply调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数 语法func.apply(thisArg, [argsArray]) 参数 thisArg：在 function 函数运行时使用的 this 值 [argsArray]：数组或者类数组对象，数组元素将作为单独的参数传给 func 函数 apply方法与call方法的区别就在此处，call接收参数列表，apply接收数组 示例仍然使用call中的主要代码，更容易看出区别 var obj = { name: &#39;张三&#39;, age: 19, func: function (from, to) { console.log(this.name + &#39;今年&#39; + this.age + &#39;,从&#39; + from + &#39;来，要到&#39; + to + &#39;去&#39;); } } obj.func(&#39;北京&#39;, &#39;上海&#39;) var p = { name: &#39;李四&#39;, age: 25 } obj.func.apply(p, [&#39;喀什&#39;, &#39;连云港&#39;]) bind创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数 语法function.bind(thisArg[, arg1[, arg2[, ...]]]) 参数 thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用 new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … （可选）当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。 示例function func(a, b, c) { return a + b + c; } var newFunc = func.bind(null, 10) console.log(newFunc(20, 30)); 将 10 作为默认的第一个参数，只需要传入两个参数即可，传多个参数只会取前两个 function Person(name, age) { this.name = name; this.age = age; } var _Person = Person.bind({}); var p = new _Person(&#39;zhangsan&#39;, 30); // Person {name: &quot;zhangsan&quot;, age: 30} 还可以用来复制对象","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Axios","slug":"笔记/Axios","date":"2020-08-27T04:14:58.150Z","updated":"2020-09-14T23:46:15.530Z","comments":true,"path":"2020/08/27/笔记/Axios/","link":"","permalink":"https://easyremember.cn/2020/08/27/笔记/Axios/","excerpt":"","text":"Axios简介及安装简介axios是基于promise用于浏览器和node.js的http客户端 特点： 能够拦截请求 支持浏览器和node服务器 支持Promise 安装运行命令 $ npm install axios 也可以通过cdn引入 &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 使用示例GETaxios.get(&#39;http://127.0.0.1:7001/news&#39;).then(response =&gt; { console.log(response); }).catch(error =&gt; { console.log(error); }) 如果需要发送参数，有两种方式，第一种就是上面的示例url后添加参数，第二种是将要发送的数据作为对象放到get方法的参数中 axios.get(&#39;http://127.0.0.1:7001/news&#39;, { params: { id: 123 } }).then(response =&gt; { console.log(response); }).catch(error =&gt; { console.log(error); }) POSTaxios.post(&#39;http://127.0.0.1:7001/add&#39;, { name: &#39;zhangsan&#39;, password: &#39;123456&#39; }).then(response =&gt; { console.log(response); }).catch(error =&gt; { console.log(error); }) axios的APIaxios(config)axios({ method: &#39;POST&#39;, url: &#39;http://127.0.0.1:7001/add&#39;, data: { name: &#39;zhangsan&#39;, password: &#39;123456&#39; } }); // 获取远程图片 axios({ method:&#39;get&#39;, url:&#39;http://127.0.0.1:7001/img&#39;, responseType:&#39;stream&#39; }) .then(function(response) { response.data.pipe(fs.createWriteStream(&#39;bg.jpg&#39;)) }); axios(url[, config])不添加config，默认GET请求 别名 axios.request(url); axios.get(url[,config]); axios.delete(url[,config]); axios.head(url[,config]); axios.options(url[,config]); axios.post(url[,data[,config]]); axios.put(url[,data[,config]]); axios.patch(url[,data[,config]]); 请求和响应请求配置{ // `url` 是用于请求的服务器 URL url: &#39;/user&#39;, // `method` 是创建请求时使用的方法 method: &#39;get&#39;, // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#39;https://some-domain.com/api/&#39;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &#39;PUT&#39;, &#39;POST&#39;, 和 &#39;PATCH&#39; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: &#39;Fred&#39; }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: &#39;janedoe&#39;, password: &#39;s00pers3cret&#39; }, // `responseType` 表示服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39; responseType: &#39;json&#39;, // default // `responseEncoding` 响应编码 responseEncoding: &#39;utf8&#39;, // default // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // Do whatever you want with the native progress event }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // &#39;proxy&#39; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: &#39;127.0.0.1&#39;, port: 9000, auth: { username: &#39;mikeymike&#39;, password: &#39;rapunz3l&#39; } }, // `cancelToken` 指定用于取消请求的 cancel token cancelToken: new CancelToken(function (cancel) { }) } 响应结构{ // `data` 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &#39;OK&#39;, // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {}, // &#39;request&#39; 请求信息 request: {} } 拦截器// 添加一个请求拦截器 axios.interceptors.request.use( config =&gt; { const token = token; token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; { return Promise.error(error); }) // 添加一个响应拦截器 axios.interceptors.response.use( response =&gt; { if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, error =&gt; { return Promise.reject(error.response); }) Vue -axiosmain.js引入Axios import axios from &#39;axios&#39; axios.defaults.withCredentials = true //跨域 axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/json&#39; Vue.use(axios) Vue.prototype.$http = axios // 将axios挂载到Vue原型，可以直接在Vue对象中this.$http来发送请求","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://easyremember.cn/tags/Node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Promise学习笔记","slug":"笔记/Promise","date":"2020-08-20T09:41:38.591Z","updated":"2021-01-23T07:37:02.527Z","comments":true,"path":"2020/08/20/笔记/Promise/","link":"","permalink":"https://easyremember.cn/2020/08/20/笔记/Promise/","excerpt":"","text":"Promise学习笔记参考视频教程 知识铺垫函数对象和实例对象 函数对象：将函数作为对象使用 实例对象：new 函数产生的对象(执行构造函数) 只有在new出实例对象之后，函数才能叫做构造函数 function Person() { } var p = new Person(); console.log(Person.prototype) 在这段代码中p是实例对象，Person是构造函数，打印Person原型时，Person是函数对象 回调函数 同步回调：立即执行，完全执行完了才结束，不会放入回调队列 异步回调：不会立即执行，放入回调队列中将来执行 const arr = [1, 2, 3]; arr.forEach(item =&gt; { console.log(item); }); console.log(&#39;foreach之后&#39;); setTimeout(() =&gt; { console.log(&#39;callback&#39;); }, 0); console.log(&#39;setTime之后&#39;); 上面一段是同步回调，按照顺序执行；下面一段是异步函数，放到队列中执行，主线程执行完毕之后才执行 错误处理 错误的类型 Error: 所有错误的父类型 ReferenceError: 引用的变量不存在 TypeError: 数据类型不正确的错误 RangeError: 数据值不在其所允许的范围内 SyntaxError: 语法错误 错误处理 捕获错误: try … catch 抛出错误: throw error 错误对象 message属性: 错误相关信息 stack属性: 函数调用栈记录信息 Promise理解和使用什么是Promise 抽象表达: Promise是JS中进行异步编程的新的解决方案(旧的是谁？纯回调callback) 具体表达: 从语法上来说: Promise是一个构造函数 从功能上来说: promise对象用来封装一个异步操作并可以获取其结果 promise的状态改变(只有2种结果,，只能改变一次) pending变为resolved pending变为rejected 无论成功还是失败都会有一个 结果，成功的称为value，失败的称为reason promise的基本流程(pending，图里面写错了) 为什么使用Promise 指定回调函数的方式更加灵活：可以在请求发出甚至结束后指定回调函数 支持链式调用，可以解决回调地狱问题 怎么使用Promise简单的示例 const p = new Promise((resolve, reject) =&gt; { const d = Date.now(); if (d % 2 === 1) { resolve(&#39;success&#39;) } else { reject(&#39;faild&#39;) } }) p.then(value =&gt; console.log(value), reason =&gt; console.log(reason)) .then()接收两个函数，第一个是成功的回调（onResolved），第二个是失败的回调（onRejected） 主要API Promise构造函数: Promise (excutor) {} Promise.prototype.then方法: (onResolved, onRejected) =&gt; {} Promise.prototype.catch方法: (onRejected) =&gt; {}，拦截失败操作，返回promise对象，如果catch之前有reject，直接跳到reject，中间所有的.then都不执行 Promise.resolve方法: (value) =&gt; {}，修改状态为成功 Promise.reject方法: (reason) =&gt; {}，修改状态为失败 Promise.all方法: (promises) =&gt; {}，参数为一个可迭代对象，等所有的promise对象都完成之后状态变为resolved，返回结果可迭代对象；如果过有失败结果，状态变为rejected，失败原因是第一个失败的promise对象的结果 Promise.race方法: (promises) =&gt; {}，参数为一个可迭代对象，如果有任何一个promise解决或者拒绝，返回的promise就会解决或者拒绝 存在的问题 改变状态不一定是resolve和reject，也可以发生错误或者抛出异常 同一个promise对象添加多个.then都会执行 改变promise状态和指定回调函数谁先谁后 正常情况下是先指定回调函数再改变状态 先改变状态再指定回调：①在执行器中直接调用resolve()/reject()②延迟更长时间才调用then() 什么时候得到数据 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据 不论成功失败，回调函数永远是异步执行 .then返回promise的状态——由指定的回调函数执行的结果决定 抛出异常，新的promise变为rejected，reason为跑出的异常 返回的是非promise任意值，状态改为resolved，value是返回值 返回值是一个新的promise，这个promise的结果就会成为新的promise的结果 自定义Promise整体结构由于ES6和CommenJS都需要编译才能使用，所以自定义Promise需要使用ES5模块语法（自调用函数） (function (window) { /* Promise：构造函数 excutor: 执行器 */ function Promise(excutor) { } /* Promise 原型对象.then 指定成功和失败的回调函数 返回一个新的Promise */ Promise.prototype.then = function (onResolved, onRejected) { } /* Promise 原型对象.catch 指定失败的回调函数 返回一个新的Promise */ Promise.prototype.catch = function (onRejected) { } /* Promise 原型对象.resolve 返回一个指定value的Promise */ Promise.resolve = function (value) { } /* Promise 原型对象.reject 返回一个指定reason的Promise */ Promise.reject = function (reason) { } /* Promise 原型对象.all 返回一个Promise，所有promise都成功才成功，一个失败就失败 */ Promise.all = function (promises) { } /* Promise 原型对象.race 返回一个Promise，由第一个完成的promise决定 */ Promise.race = function (promises) { } // 暴露Promise window.Promise = Promise; })(window) 构造函数/* Promise：构造函数 excutor: 执行器 */ function Promise(excutor) { this.status = &#39;pending&#39;; // 状态 this.data = undefined; // 数据 this.callbacks = []; // 保存回调函数，结构：{onResolved() {}, onReject() {}} function resolve(value) { // 当前状态不是pending结束 if (this.status !== &#39;pending&#39;) { return } // 修改状态 this.status = &#39;resolved&#39;; // 保存数据 this.data = value; // 立即执行callback if (this.callbacks.length &gt; 0) { this.callbacks.forEach(callbacksObj =&gt; { setTimeout(() =&gt; { // 异步执行回调 callbacksObj.onResolved(value) }, 0) }); } } function reject(reason) { // 当前状态不是pending结束 if (this.status !== &#39;pending&#39;) { return } // 修改状态 this.status = &#39;rejected&#39;; // 保存数据 this.data = value; // 立即执行callback if (this.callbacks.length &gt; 0) { this.callbacks.forEach(callbacksObj =&gt; { setTimeout(() =&gt; { // 异步执行回调 callbacksObj.onRejected(reason) }, 0) }); } } // 立即执行excutor try { excutor(resolve, reject); } catch (error) { // 抛出异常变为rejected reject(error); } } Promise.then()/.catch()先来看一下这个例子，将fn赋值给f，两种方法，第二种比第一种简介，在.then内部返回数据时会用到 function fn() { } var f = function fn() { } var f = fn; 正片开始 /* Promise 原型对象.then 指定成功和失败的回调函数 返回一个新的Promise */ Promise.prototype.then = function (onResolved, onRejected) { onResolved = typeof onResolved === &#39;function&#39; ? onResolved : value =&gt; value onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; {throw reason} const _this = this; // 返回一个新的promise return new Promise((resolve, reject) =&gt; { // 指定调用回调函数 function handle(callback) { try { const result = callback(_this.data); if (result instanceof Promise) { // 类型为promise，结果是这个promise的结果 // result.then( // value =&gt; resolve(value), // reason =&gt; reject(reason) // ) result.then(resolve, reject); } else { resolve(result); // 非promise返回结果 } } catch (error) { // 抛出异常，失败 reject(error); } } if (_this.status === PENDING) { _this.callbacks.push({ onResolved(value) { handle(onResolved) }, onRejected(reason) { handle(onRejected) } }) } else if (_this.status === RESOLVED) { setTimeout(() =&gt; { handle(onResolved) }) } else { setTimeout(() =&gt; { handle(onRejected) }) } }) } /* Promise 原型对象.catch 指定失败的回调函数 返回一个新的Promise */ Promise.prototype.catch = function (onRejected) { return this.then(undefined, onRejected) } Promise.resolve()/reject() /* Promise 原型对象.resolve 返回一个指定value的Promise */ Promise.resolve = function (value) { // 返回一个成功/失败的promise return new Promise((resolve, reject) =&gt; { if (value instanceof Promise) { value.then(resolve, reject) } else { resolve(value) } }) } /* Promise 原型对象.reject 返回一个指定reason的Promise */ Promise.reject = function (reason) { // 返回一个失败的promise return new Promise((resolve, reject) =&gt; { reject(reason); }) } Promise.all()/race() /* Promise 原型对象.all 返回一个Promise，所有promise都成功才成功，一个失败就失败 */ Promise.all = function (promises) { const values = new Array(promises.length); // 保存所有成功的value let resolveCount = 0; // 计数器，计算成功的数量 return new Promise((resolve, reject) =&gt; { // 获取每个promise的结果 promises.forEach((p, index) =&gt; { p.then( value =&gt; { resolveCount++; values[index] = value; if (resolveCount === promises.length) { // 所有都完成才会resolve resolve(values) } }, reason =&gt; { reject(reason) } ) }) }) } /* Promise 原型对象.race 返回一个Promise，由第一个完成的promise决定 */ Promise.race = function (promises) { return new Promise((resolve, reject) =&gt; { promises.forEach((p) =&gt; { p.then( value =&gt; { resolve(value) }, reason =&gt; { reject(reason) } ) }) }) } 代码代码已经上传码云","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"原型和原型链","slug":"技术/原型和原型链","date":"2020-08-19T00:53:18.162Z","updated":"2020-09-05T09:35:16.583Z","comments":true,"path":"2020/08/19/技术/原型和原型链/","link":"","permalink":"https://easyremember.cn/2020/08/19/技术/原型和原型链/","excerpt":"","text":"原型和原型链 javascript是动态的，并且本身不提供一个 class 实现。（在 ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的）。 每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性 __proto__就是指向对象原型的属性 例如有一个Person对象，实例化一个实例对象之后它的__proto__指向Object 每个函数都会自带一个prototype属性，指向对象原型 function Person(name) { this.name = name; } Person.prototype.age = 12; var zhangsan = new Person(&#39;zhangsan&#39;); console.log(zhangsan); 可以看到实例的原型中已经有了age属性 实例对象.__proto__ === 构造函数.prototype 上面的例子中 zhangsan.__proto__ === Person.prototype Person.prototype.__proto__ === Object.prototype zhangsan——Person——Object这种原型与原型层层相链接的过程即为原型链 当读取实例属性时，如果找不到就会从原型链一层一层地往上找，一直到最顶层为止 所有对象的原型最终都指向Object，而Object.prototype.__proto__ === null","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"vuex入门","slug":"技术/vuex入门","date":"2020-08-18T11:03:09.232Z","updated":"2020-09-05T09:34:40.320Z","comments":true,"path":"2020/08/18/技术/vuex入门/","link":"","permalink":"https://easyremember.cn/2020/08/18/技术/vuex入门/","excerpt":"","text":"vuex入门优势 集中管理数据，易于后期开发和维护 高效的实现组件之间的数据共享，提高开发效率 vuex中数据都是响应式的，实时保持页面同步 哪些数据适合存储到Vuex中只有组件之间需要共享的数据，才有必要存储到Vuex中 Vuex核心概念State提供唯一的公共数据源 const store = new Vuex.store({ state: { count: 0 } }) 组件中访问State数据 第一种方式：this.$store.state.全局数据名 第二种方式：按需导入import {mapState} from &#39;vuex&#39;，通过mapState函数，将当前组件需要的全局数据映射为当前组件的computed计算属性 computed: { ...mapState([&#39;count&#39;]) } Mutation用于变更store中的数据 只能通过mutation变更Store数据，不可以直接操作Store中的数据 可以集中监控所有数据变化 在vuex中定义方法 const store = new Vuex.store({ mutations: { add(state) { state.count++ } } }) 方法一：通过this.$store.commit方法触发vuex中的方法 methods: { btnHandle1() { this.$store.commit(&#39;add&#39;) } } 可以在触发mutation的时候传递参数 const store = new Vuex.store({ mutations: { addN(state, step) { state.count += step } } }) ······ btnHandle2() { this.$store.commit(&#39;add&#39;, 3) } 方法二：从Vuex中按需导入mapMutations函数，将需要的mapMutations函数映射为当前组建的methods方法 import {mapMutations} from &#39;vuex&#39; ··· methods: { ...mapMutations([&#39;sub&#39;]), Handle() { this.sub() } } 带参数 methods: { ...mapMutations([&#39;subN&#39;]), Handle2() { this.subN(3) } } mutation函数中不可以执行异步操作 Action用于处理异步任务，Action 提交的是 mutation，而不是直接变更状态 const store = new Vuex.Store({ state: { count: 0 }, mutations: { add (state) { state.count++ } }, actions: { addAsync(context, step) { setTimeout(() =&gt; { context.commit(&#39;add&#39;, step) },1000) } } }) 方法一：通过 $store.dispatch()触发Action btnHandle3() { this.$store.dispatch(&#39;addAsync&#39;) } 携带参数 addAsyncN(context, step) { setTimeout(() =&gt; { context.commit(&#39;addN&#39;, step) },1000) } ······ btnHandle4() { this.$store.dispatch(&#39;addAsyncN&#39;, 3) } 方法二：从vuex中按需导入mapActions函数，将需要的actions函数映射为组建的methods import {mapActions} from &#39;vuex&#39; ······ methods: { ...mapActions([&#39;subAsync&#39;]), Handle3() { this.subAsync() } } 携带参数 methods: { ...mapActions([&#39;subAsyncN&#39;]), Handle4() { this.subAsyncN(3) } } Getter用于对Store中的数据进行加工处理形成新的数据，不会修改原有数据 对Store中的数据进行加工处理形成新的数据，类似于Vue中的计算属性 Store中的数据发生变化，Getter的数据也会跟着改变 定义getter getters: { showNum(state) { return &#39;当前最新数量是【&#39; + state.count + &#39;】&#39; } } 获取getter 方法一：通过this.$store.getters.getter的方法名 this.$store.getters.showNum 方法二：按需导入mapGetters函数，通过mapGetters函数，将当前组件需要的全局数据映射为当前组件的computed计算属性 import {mapGetters} from &#39;vuex&#39; ······ computed: { ...mapGetters([&#39;showNum&#39;]) }, Vuex模块化管理随着功能和数据不断增加，store会越来越臃肿，把不同的功能单独拆分处理，可以方便管理 └── store └── index.js # 总的store └── modules └── modulesA.js # 模块A └── modulesB.js # 模块B · # 其他模块 规模较小的可以将不同的核心放在一个模块js中，分多了反而不方便 user.js const state = {} const actions = {} _______________ export defult { namespaced: true, state, actions, } index.js import moduleA from &#39;./modules/modulesA&#39; ___________ modules: { moduleA } Vuex模块化管理调用不同功能划分模块之后引入数据的方式略有改变 state方法一： this.$store.state.moduleA.key2，在原来直接引入数据的基础上，添加了模块名 方法二： computed: { ...mapState({ key: state =&gt; state.moduleA.key1 }) ------------------- ...mapState(&#39;moduleA&#39;, { key: &quot;key1&quot; }), }, 将模块中的key1赋值给计算属性key,两种方法结果是一样的 mutations方法一： this.$store.commit(&#39;moduleA/changeValue&#39;)，在原来直接调用方法名的基础之上添加模块名 方法二： methods: { ...mapMutations(&#39;moduleA&#39;,[&#39;changeValue&#39;]), handle() { this.changeValue() } } 在引入方法之前添加模块名 actions同mutataions 方法一： this.$store.dispatch(&#39;moduleA/changeAsync&#39;) 方法二： methods: { ...mapActions(&#39;moduleA&#39;, [&#39;changeAsync&#39;]), handle() { this.changeAsync() } } getters方法一 computed: { ...mapGetters(&#39;moduleA&#39;,{ dKey: &quot;detailValue&quot; }) }, 方法二 this.$store.getters[&#39;moduleA/getMethods&#39;] Vuex状态管理 组件通过调用actions触发mutations来修改state，state经过getters包装之后显示到组件； 组件不能直接修改state，只让mutation修改state","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"原生JS实现AJAX","slug":"技术/原生JS实现AJAX","date":"2020-08-18T08:14:27.923Z","updated":"2020-09-05T09:35:10.625Z","comments":true,"path":"2020/08/18/技术/原生JS实现AJAX/","link":"","permalink":"https://easyremember.cn/2020/08/18/技术/原生JS实现AJAX/","excerpt":"","text":"原生JS实现AJAX什么是AjaxAJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），不是新的编程语言，而是一种使用现有标准的新方法，不重新加载整个页面的情况下更新部分页面 Ajax工作原理 XHR(XMLHttpRequiest)创建XHR对象新版本的浏览器都支持XHR对象，直接实例化即可var xhr = new XMLHttpRequest(); XHR请求如果要将数据发送到服务器，使用XMLHttpRequest 对象的 open() 和 send() 方法 open(method, url, async) method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) string：仅用于 POST 请求发送数据 GET请求function load() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { document.getElementById(&quot;box&quot;).innerHTML = xhr.responseText; } } xhr.open(&#39;GET&#39;, &#39;/promise.js&#39;, true); xhr.send(); } 声明一个函数，函数中实例化一个XHR实例对象，当xhr的状态改变成相应的状态时，将请求到的文本插入HTML文档中 POST请求过程相同，只是在send中加入要发送的数据 封装每次请求都要写这一堆东西太过繁琐，将代码抽离出来作为单独的模块 var Ajax = { get: function (url,callback) { var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { callback(xhr.responseText); } } }, post: function (url, data, callback) { var xhr = new XMLHttpRequest(); xhr.open(&#39;POSt&#39;, url, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { callback(xhr.responseText); } } xhr.send(data); } } function load() { Ajax.get(&#39;/promise.js&#39;, (res) =&gt; { document.getElementById(&quot;box&quot;).innerHTML = res; }); } get请求传入url和callback，ststus变为200时触发callback readystate status 反馈内容 基于Promise封装var Ajax = { get: function (url) { return new Promise((resolve, reject) =&gt; { var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status === 0)) { resolve(xhr.responseText); } } }) }, post: function (url, data) { return new Promise((resolve, reject) =&gt; { var xhr = new XMLHttpRequest(); xhr.open(&#39;POSt&#39;, url, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 0) { resolve(xhr.responseText); } } xhr.send(data); }) } } function load() { const p = Ajax.get(&#39;/promise.js&#39;).then(value =&gt; { console.log(value); }).catch(reason =&gt; { console.log(reason); }) } 把异步操作封装到Promise，调用起来相当方便，这样可以请求到数据，但判断状态如果加上else就会走else分支，目前没有找到原因","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"ES6和CommonJS的模块化","slug":"技术/ES6和CommonJS","date":"2020-08-18T01:10:06.072Z","updated":"2020-09-09T02:55:20.645Z","comments":true,"path":"2020/08/18/技术/ES6和CommonJS/","link":"","permalink":"https://easyremember.cn/2020/08/18/技术/ES6和CommonJS/","excerpt":"","text":"ES6和CommonJS的模块化 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 导出导入对比ES6ES6采用import/export来进行导出导入操作，还有一种导出方式export default，一般使用了export default的不允许同时使用export CommonJScjs采用require/module.exports来进行导入导出操作 ES6是引用，CommonJS是拷贝ES6导入的是模块的引用，当模块内部的值发生改变时，引用的值也会改变 print.js代码如下 export let num = 9; export function logNum() { num++; } 引用如下 可以看到每在浏览器点击一次button都会打印出num的值+1 CommonJS模块输出的是值的拷贝，模块内部的变化不会影响到输出值 print.js代码修改为如下 let num = 9; function logNum() { num++; } module.exports = { num, logNum } 然后再点击button会看到控制台打印出的数值一直不变 此外，export default导出的效果也跟CommenJS相同 let num = 9; function logNum() { num++; } export default { num, logNum } 引入时接收为一个对象 打印结果同样不变 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 运行时加载: CommonJS 模块就是对象（即module.exports属性）；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载” 此外 CommonJs是动态语法可以写在判断里，ES6 Module静态语法只能写在顶层","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Egg实用中间件","slug":"技术/Egg常用的包","date":"2020-08-17T08:17:39.921Z","updated":"2020-09-05T09:37:20.810Z","comments":true,"path":"2020/08/17/技术/Egg常用的包/","link":"","permalink":"https://easyremember.cn/2020/08/17/技术/Egg常用的包/","excerpt":"","text":"Egg常用的插件egg-mysql安装与配置首先安装egg-mysql的包 $ npm i --save egg-mysql 然后在plugin.ts开启插件 mysql: { enable: true, package: &#39;egg-mysql&#39;, }, 再然后在config中配置数据库信息 单数据库// mysql数据库 config.mysql = { client: { // 单数据库信息配置 host: &#39;localhost&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;liuhao&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;ssmbuild&#39;, // 数据库名 }, app: true, // 是否加载到 app 上，默认开启 agent: false, // 是否加载到 agent 上，默认关闭 }; 使用方法 await app.mysql.query(sql, values); 多数据库// mysql数据库 config.mysql = { clients: { // 多据库信息配置 db1: { host: &#39;localhost&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;liuhao&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;ssmbuild&#39;, // 数据库名 }, db2: { host: &#39;mysql.com&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;root&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;test&#39;, // 数据库名 } }, app: true, // 是否加载到 app 上，默认开启 agent: false, // 是否加载到 agent 上，默认关闭 }; 使用方法 const client1 = app.mysql.get(&#39;db1&#39;);await client1.query(sql, values); const client2 = app.mysql.get(&#39;db2&#39;);await client2.query(sql, values); 注意egg-mysql没有index.d.ts，所以编译不过，在typings/index.d.ts中添加配置 import &#39;egg&#39;; declare module &#39;egg&#39; { interface mysql { get(tableName: String, find: {}): Promise&lt;Any&gt; insert(tableName: String, find: {}): Promise&lt;Any&gt; update(tableName: String, find: {}): Promise&lt;Any&gt; delete(tableName: String, find: {}): Promise&lt;Any&gt; query(sql: String, values: Any[]): Promise&lt;Any&gt; } interface Application { mysql: mysql; } } 详见寒风傲天博文 CRUDCreate使用insert方法插入一条记录，插入成功判定 result.affectedRows === 1 // controller public async insert() { const { ctx } = this; const book = { bookName: &#39;js&#39;, bookCounts: 2, detail: &#39;test&#39;, }; const result = await ctx.service.book.create(book); if (result.affectedRows === 1) { ctx.body = &#39;插入成功&#39;; } else { ctx.body = &#39;插入失败&#39;; } } // service public async create(book) { const { app } = this; const result = await app.mysql.insert(&#39;books&#39;, book); return result; } 结果如图 Read使用 get 方法或 select 方法获取一条或多条记录。select 方法支持条件查询与结果的定制。 // controller public async index() { const { ctx } = this; const result = await ctx.service.book.select(); await ctx.render(&#39;book.ejs&#39;, { result, }); } // service public async select(options?: object) { const { app } = this; const result = await app.mysql.select(&#39;books&#39;, options); return result; } 来看下效果 定制查询 Update&amp;Delete使用 update 方法更新数据库记录 const result = await app.mysql.update(&#39;posts&#39;, row, options); // 参数: 表名，更新的数据，查询参数 const updateSuccess = result.affectedRows === 1; // 插入成功判定 使用 delete 方法删除数据库记录 const result = await app.mysql.delete(&#39;posts&#39;, options); 直接执行sql查询使用 query 执行sql 语句 const id = 1; cosnt count = 4; const results = await app.mysql.query(&#39;select * from books where id = ? and bookCounts &gt; ?&#39;, [id, count]); 事务 代码代码已上传码云#2部分 egg-sequelize安装与配置安装egg-sequelize和mysql2 $ npm install --save egg-sequelize mysql2 在plugin中开启插件 sequelize: { enable: true, package: &#39;egg-sequelize&#39;, }, 在config中配置sequelize // 配置sequellize config.sequelize = { dialect: &#39;mysql&#39;, // 数据库类型 database: &#39;ssmbuild&#39;, // 数据库名称 host: &#39;127.0.0.1&#39;, // 数据库ip地址 port: 3306, // 数据库端口 username: &#39;liuhao&#39;, // 数据库用户名 password: &#39;123456&#39;, // 数据库密码 }; 经测试这种方式可以进行操作，但是，不能自动生成表，需要手动建表 配置sequelize-cli安装 $ npm install --save-dev sequelize-cli 在项目根目录下新建一个 .sequelizerc 配置文件 &#39;use strict&#39;; const path = require(&#39;path&#39;); module.exports = { config: path.join(__dirname, &#39;database/config.json&#39;), &#39;migrations-path&#39;: path.join(__dirname, &#39;database/migrations&#39;), &#39;seeders-path&#39;: path.join(__dirname, &#39;database/seeders&#39;), &#39;models-path&#39;: path.join(__dirname, &#39;app/model&#39;), }; 然后运行命令初始化配置文件和目录 $ npx sequelize init:config $ npx sequelize init:migrations 根目录下会生成数据库相关文件夹 将config.js中的数据库配置改为自己的配置 然后运行命令生成表，以user为例 $ npx sequelize migration:generate --name=users 可以看到多了一个users.js文件，开始配置user模型 module.exports = { // 在执行数据库升级时调用的函数，创建 users 表 up: async (queryInterface, Sequelize) =&gt; { /** * Add altering commands here. * * Example: * await queryInterface.createTable(&#39;users&#39;, { id: Sequelize.INTEGER }); */ const { INTEGER, STRING } = Sequelize; await queryInterface.createTable(&#39;users&#39;, { id: { type: INTEGER, // INTEGER就是mysql中的int primaryKey: true, autoIncrement: true, // 自动增长 }, name: STRING(20), url: STRING(100), country: STRING(10), }, { // timestamps: false, // 去除createAt updateAt createdAt: false, // 表示不启用created_at updatedAt: false, // 表示不启用updated_at freezeTableName: true, // 使用自定义表名 // 使用自定义表名之后上面写的users就直接就是你的表名，如果不加的话，你就可以写user，但是自己的表名为users，程序会自动将s加上 tableName: &#39;users&#39;, // 自定义的表名，也可以不写，直接用define后面的也可以 // 只要你使用了freezeTableName，程序就不会自动给你加上s了 }); }, // 在执行数据库降级时调用的函数，删除 users 表 down: async queryInterface =&gt; { /** * Add reverting commands here. * * Example: * await queryInterface.dropTable(&#39;users&#39;); */ await queryInterface.dropTable(&#39;users&#39;); }, }; 然后变更数据库 # 升级数据库 $ npx sequelize db:migrate # 如果有问题需要回滚，可以通过 `db:migrate:undo` 回退一个变更 # npx sequelize db:migrate:undo # 可以通过 `db:migrate:undo:all` 回退到初始状态 # npx sequelize db:migrate:undo:all 可以看到数据库中已经有了users表 编码OK，配置已经完成，现在开始进行愉快的编码 首先在app目录下新建一个model文件夹，将user模型添加到model下面，然后就可以通过app.model.User 或者 ctx.model.User 访问了，以insert为例 // controller public async add() { const { ctx } = this; const result = await ctx.service.user.createUser({ name: &#39;zhangsan&#39;, url: &#39;http://zhangsan.com&#39;, country: &#39;CN&#39;, }); ctx.body = result; } // service public async createUser(user: object) { const res = await this.ctx.model.User.create(user); return res; } 然后就可以看到已经插入数据成功 更多sequelize使用方法不多赘述，见之前的博文，传送门 代码代码已上传码云#3部分 egg-passport这里用微博的第三登录做为示范 安装及配置首先运行命令安装passport支持 $ npm i --save egg-passport $ npm i --save egg-passport-weibo 然后开启插件 passport: { enable: true, package: &#39;egg-passport&#39;, }, passportWeibo: { enable: true, package: &#39;egg-passport-weibo&#39;, }, 然后在config.default中配置申请到的身份码 // weibo登录 config.passportWeibo = { key: &#39;your key&#39;, secret: &#39;your secret&#39;, }; 编码首先在router中挂载路由，这里使用的是插件提供的语法糖（这里挂载的时候可能会报错，因为没有index.d.ts文件，这个问题解决办法上面说过，这里不再赘述） export default (app: Application) =&gt; { const { controller, router } = app; router.get(&#39;/&#39;, controller.home.index); app.passport.mount(&#39;weibo&#39;); // 相当于 // const github = app.passport.authenticate(&#39;github&#39;, {}); // router.get(&#39;/passport/github&#39;, github); // router.get(&#39;/passport/github/callback&#39;, github); }; 然后在controller中编写登录操作 public async index() { // const { ctx } = this; // // ctx.body = await ctx.service.test.sayHi(&#39;egg&#39;); // await ctx.render(&#39;login.ejs&#39;); const { ctx } = this; if (ctx.isAuthenticated()) { ctx.body = `&lt;div&gt; &lt;h2&gt;${ctx.path}&lt;/h2&gt; &lt;hr&gt; Logined user: &lt;img src=&quot;${ctx.user.photo}&quot;&gt; ${ctx.user.displayName} / ${ctx.user.id} | &lt;a href=&quot;/logout&quot;&gt;Logout&lt;/a&gt; &lt;pre&gt;&lt;code&gt;${JSON.stringify(ctx.user, null, 2)}&lt;/code&gt;&lt;/pre&gt; &lt;hr&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/user&quot;&gt;User&lt;/a&gt; &lt;/div&gt;`; } else { ctx.session.returnTo = ctx.path; ctx.body = ` &lt;div&gt; &lt;h2&gt;${ctx.path}&lt;/h2&gt; &lt;hr&gt; Login with &lt;a href=&quot;/passport/weibo&quot;&gt;Weibo&lt;/a&gt; &lt;hr&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/user&quot;&gt;User&lt;/a&gt; &lt;/div&gt; `; } } 由于我的服务器已经过期，没有可用的网站来审核，所以申请到的oauth码不能使用，如果通过审核，这就可以使用了 此外 API ctx.user - 获取当前已登录的用户信息 ctx.isAuthenticated() - 检查该请求是否已授权 ctx.login(user, [options]) - 为用户启动一个登录的 session ctx.logout() - 退出，将用户信息从 session 中清除 ctx.session.returnTo= - 在跳转验证前设置，可以指定成功后的 redirect 地址 还提供了 API： app.passport.verify(async (ctx, user) =&gt; {}) - 校验用户 app.passport.serializeUser(async (ctx, user) =&gt; {}) - 序列化用户信息后存储进 session app.passport.deserializeUser(async (ctx, user) =&gt; {}) - 反序列化后取出用户信息 app.passport.authenticate(strategy, options) - 生成指定的鉴权中间件 options.successRedirect - 指定鉴权成功后的 redirect 地址 options.loginURL - 跳转登录地址，默认为 /passport/${strategy} options.callbackURL - 授权后回调地址，默认为 /passport/${strategy}/callback app.passport.mount(strategy, options) - 语法糖，方便开发者配置路由 代码代码已上传码云#4部分 egg-jwtjwt（jsonwebtoken）是我认为潜力最大的一种用户状态验证方式 JWT原理三部分组成，用.分割 header: 一个json对象，描述JWT的元数据 payload: 一个 JSON 对象，用来存放实际需要传递的数据 signature: 对header和payload两部分的签名，防止数据被篡改 安装与配置运行命令安装 $ npm i egg-jwt --save 开启插件 jwt: { enable: true, package: &#39;egg-jwt&#39;, } 在config.default中配置秘钥 // JWT秘钥 config.jwt = { secret: &#39;xiaofeng&#39;, }; 编码生成登录页使用post方法提交表单不再列出，主要给出生成token的操作（同样jwt没有index.d.ts，需要手动配置，见前文） public async add() { const { ctx, app } = this; ctx.cookies.set(&#39;username&#39;, ctx.request.body.username); const token = app.jwt.sign({ username: ctx.request.body.username, }, app.config.jwt.secret); ctx.set({ authorization: token }); //设置headers ctx.body = token; } 效果如图 验证import { Context } from &#39;egg&#39;; // 自定义的中间件：验证token export default function jwtAuth(options: any): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { const token = ctx.request.header.authorization; let decode = &#39;&#39;; if (token) { try { // 解码token decode = await ctx.app.jwt.verify(token, options.secret); console.log(&#39;decode======&gt;&#39;, decode); await next(); } catch (error) { ctx.status = 401; ctx.body = { message: error.message, }; return; } } else { ctx.status = 401; ctx.body = { message: &#39;没有token&#39;, }; return; } }; } 自定义验证token中间件，在路由文件中添加需要token才能访问的路由 import { Application } from &#39;egg&#39;; export default (app: Application) =&gt; { const { controller, router, middleware } = app; const token = middleware.jwtAuth(app.config.jwt); router.get(&#39;/news&#39;, token, controller.news.index); }; 没有获得token访问需要登录的路由时会提示没有token使用接口测试工具绑定一个已经生成的token可以看到成功解析了token 代码代码已上传码云#5部分,验证部分在#8 egg-validateegg-validate用于对参数进行检验，比如检验一个用户名是不是字符串ctx.validate({ userName: &#39;string&#39; }); 安装及配置运行命令 $ npm i egg-validate --save plugin中开启插件 validate: { enable: true, package: &#39;egg-validate&#39;, }, config中配置 // validate, 参数校验器 config.validate = { convert: true, // 对参数可以使用convertType规则进行类型转换 // validateRoot: false, // 限制被验证值必须是一个对象。 }; 编码编写一个post请求，接收一个对象作为参数 （validator需要手动挂载，使用什么方法添加什么规则） import { Controller } from &#39;egg&#39;; // 规则 const createRule = { name: &#39;string&#39;, age: { type: &#39;number&#39;, min: 0, max: 100, }, sex: [ &#39;man&#39;, &#39;woman&#39; ], }; export default class PostsController extends Controller { public async index() { const { ctx } = this; ctx.body = &#39;posts index&#39;; } public async create() { const { ctx, app } = this; // ctx.validate(createRule, ctx.request.body); // 自动处理错误，422 const error = app.validator.validate(createRule, ctx.request.body); // 返回错误信息，开发者处理 console.log(error); ctx.status = 201; } } 效果如图，当出现错误时返回错误，没有错误error为空，created是自动加的 更多规则 自定义规则使用app.validator.addRule添加更多自定义规则（需要手动挂载） 例如： app.validator.addRule(&#39;newRule&#39;, (rule, value)=&gt;{ if (value.length &lt; 3 || value.length &gt; 10) { console.log(&quot;用户名的长度应该在3-10之间&quot;); } }); 自定义规则需要单独在一个文件中添加 代码代码已上传码云#6部分 egg-cors 请求跨域是我们在日常开发中经常碰到的问题 egg解决跨域也是非常的简单，只要开启egg-cors就行了 安装及配置运行命令 $ npm i egg-cors --save plugin中开启插件 cors: { enable: true, package: &#39;egg-cors&#39;, }, config中配置 // 关闭csrf config.security = { csrf: { enable: false, // 关闭csrf }, domainWhiteList: [ &#39;*&#39; ], // 白名单 }; // CORS config.cors = { origin: &#39;*&#39;, allowMethods: &#39;GET,HEAD,PUT,POST,DELETE,PATCH&#39;, }; 然后就可以了 代码代码已上传码云#7部分","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://easyremember.cn/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"EggJS学习笔记","slug":"笔记/EggJS学习笔记","date":"2020-08-15T15:14:19.584Z","updated":"2020-09-05T09:36:10.076Z","comments":true,"path":"2020/08/15/笔记/EggJS学习笔记/","link":"","permalink":"https://easyremember.cn/2020/08/15/笔记/EggJS学习笔记/","excerpt":"","text":"EggJS学习笔记开始介绍Egg.js 为企业级框架和应用而生，Express框架本身缺少约定，标准的 MVC 模型会有各种千奇百怪的写法。Egg 按照约定进行开发，奉行『约定优于配置』，团队协作成本低。 Egg特性 提供基于Egg定制上层框架的能力 高度可拓展的插件机制 内置多进程管理 基于Koa开发，性能优异 框架稳定，测试覆盖率高 渐进式开发 安装$ npm init egg --type=ts $ npm i 本篇主要使用ts，类型可以不填，会让你手动选择， 启动$ npm run dev $ open http://localhost:7001 目录结构egg-project ├── package.json -- 框架配置，依赖 ├── app --源码目录 | ├── router.ts -- 用于配置 URL 路由规则 | ├── model -- 用于放置领域模型 │ | └── user.ts │ ├── controller -- 用于解析用户的输入，处理后返回相应的结果 │ | └── home.ts │ ├── service (可选) -- 用于编写业务逻辑层 │ | └── user.ts │ ├── middleware (可选) -- 用于编写中间件 │ ├── schedule (可选) -- 用于定时任务 │ ├── public (可选) -- 用于放置静态资源 │ ├── view (可选) -- 用于放置模板文件 │ └── extend (可选) -- 用于框架的扩展 ├── config -- 配置文件 | ├── plugin.ts -- 用于配置需要加载的插件 | ├── config.default.ts -- 用于编写配置文件(下同) │ ├── config.prod.ts | ├── config.test.ts (可选) | ├── config.local.ts (可选) | └── config.unittest.js (可选) ├── logs -- 日志文件 └── test/app -- 用于单元测试 └── controller -- 用于controller层的单元测试 └── home.test.js 路由路由文件代码如下 import { Application } from &#39;egg&#39;; export default (app: Application) =&gt; { const { controller, router } = app; router.get(&#39;/&#39;, controller.home.index); router.get(&#39;/login&#39;, controller.admin.login); }; 代码简单明了，一眼就能看懂是如何配置的，为了防止看不懂，我们来说一下 配置方法明白了再来说一下路由文件整体的结构 首先从egg中解构出Application，这是一个接口，对传入的参数做出约束（启动文件在egg包中，使用过程基本不用动）；从传入的app中再解构出controller和router，router就是路由对象 可以看到源码中router对象中有很多HTTP方法 这个是最常用的get方法参数，路径和中间件，中间件这里就是要执行的操作，示例中用到controller中的方法 POST请求直接用相同的方法配置POST请求会抛出错误 因为这样不符合Egg的安全机制，常见的安全问题 XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作。 CSRF 攻击：伪造用户请求向网站发起恶意请求。 钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。 HTTP参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。 远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。 解决办法1在访问页面时向页面发送签名数据csrf public async index() { const { ctx } = this; // ctx.body = await ctx.service.test.sayHi(&#39;egg&#39;); await ctx.render(&#39;login.ejs&#39;, { csrf: ctx.csrf, }); } 然后在页面发送请求的时候带上这个csrf &lt;form action=&quot;/login?_csrf=&lt;%= csrf %&gt; &quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; 解决办法2使用中间件发送csrf import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { // 设置全局变量 ctx.state.csrf = ctx.csrf; await next(); }; } 这样就不用每次在方法里面发送csrf了 如果觉得url带着一长串csrf不好看，可以在表单域设置csrf &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;&lt;%= csrf %&gt;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; controller已经获取到了表单数据 resources自动配置RESTful风格API，只需要一行代码router.resources(&#39;posts&#39;, &#39;/api/posts&#39;, controller.posts);，就可以自动生成下面一套API Method Path Route Name Controller.Action GET /api/posts posts app.controllers.posts.index GET /api/posts/new new_post app.controllers.posts.new GET /api/posts/:id post app.controllers.posts.show GET /api/posts/:id/edit edit_post app.controllers.posts.edit POST /api/posts posts app.controllers.posts.create PUT /api/posts/:id post app.controllers.posts.update DELETE /api/posts/:id post app.controllers.posts.destroy 只需要在Controller中实现Action即可 控制器Controller看完路由再来看一下controller，代码如下 import { Controller } from &#39;egg&#39;; export default class AdminController extends Controller { public async login() { const { ctx } = this; ctx.body = await ctx.service.login.welcome(&#39;egg&#39;); } } 新建一个类继承egg中的Controller，编写方法login 这里注意，egg基于Koa，Koa是ctx.xxx，在egg中ctx被封装在this里面，使用解构赋值解析出来，如果不使用解构就要使用this.ctx.xxx 获取传值get类型通过ctx.query获取参数，比如 export default class AdminController extends Controller { public async index() { const { ctx } = this; const userName: string = ctx.query.name; ctx.body = await ctx.service.login.welcome(userName); } } 可以看到已经从url中获取了name参数 动态路由从url中获取数据，但不是使用query的形式，而是使用http://127.0.0.1:7001/user/123这种形式 在配置路由时添加参数，例如 router.get(&#39;/user/:id&#39;, controller.admin.user); 然后在Controller中使用ctx.params获取参数，如 public async user() { const { ctx } = this; const id: string = ctx.params.id; ctx.body = await ctx.service.login.userCenter(id); } 服务ServiceService 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，好处： 保持 Controller 中的逻辑更加简洁。 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。 将逻辑和展现分离，更容易编写测试用例 使用场景： 复杂数据的处理，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。或者计算完成后，更新到数据库。 第三方服务的调用 定义服务代码示例 import { Service } from &#39;egg&#39;; /** * Login Service */ export default class Login extends Service { /** * userCenter for you * @param id - your id */ public async userCenter(id: string) { return `ID：${id}`; } } 属性 配置项config在config.default.ts中添加配置项，可以直接在controller或者service中调用配置项。比如在config中定义一个字符串，然后在service中调用，代码如下 //config.default.ts // 自定义配置项 config.str = &#39;this is a config string&#39;; // Login.ts public async userCenter(id: string) { console.log(this.config.str); return `ID：${id}`; } 日志loggerlogger有四种级别，下面给出示例 this.logger.debug(&#39;this is degug&#39;); this.logger.info(&#39;this is info&#39;); this.logger.warn(&#39;this is warn&#39;); this.logger.error(&#39;this is error&#39;); 上下文ctx this.ctx.curl 发起网络调用。 this.ctx.service.otherService 调用其他 Service。 this.ctx.db 发起数据库调用等， db 可能是其他插件提前挂载到 app 上的模块。 注意 模板引擎安装模板引擎使用ejs做案例，首先安装ejs包，npm文档 $ npm i egg-view-ejs --save 然后将下面这段代码放到对应的配置文件里面 // {app_root}/config/plugin.js exports.ejs = { enable: true, package: &#39;egg-view-ejs&#39;, }; // {app_root}/config/config.default.js exports.view = { mapping: { &#39;.ejs&#39;: &#39;ejs&#39;, }, }; // ejs config exports.ejs = {}; 注意ts的配置方式不同，如下图 编写模板代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2 style=&quot;color: #409eff;&quot;&gt;&lt;%= data %&gt;&lt;/h2&gt; &lt;ul&gt; &lt;% for(let i = 0; i &lt; list.length; i++) { %&gt; &lt;li&gt;&lt;%= list[i] %&gt;&lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;img src=&quot;/public/images/egg.jpg&quot; alt=&quot;&quot; width=&quot;100px&quot; height=&quot;60px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 模板文件一定要放在app下的view目录下ejs语法： &lt;% ‘脚本’ 标签，用于流程控制，无输出。 &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 _%&gt; 将结束标签后面的空格符删除 controller返回模板并传值public async user() { const { ctx } = this; const id: string = ctx.params.id; const udata: string = await ctx.service.login.userCenter(id); const arr: number[] = [ 111, 222, 333 ]; await ctx.render(&#39;user.ejs&#39;, { data: udata, list: arr, }); } 这里注意两个点 ctx.render是异步方法，需要使用await修饰 render的第一个参数是模板名称，这里需要加上后缀名，否则会报错 效果如图 实战：小爬虫地址：http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1 Serviceimport { Service } from &#39;egg&#39;; /** * News Service */ export default class Login extends Service { /** * getNewsList */ public async getNewsList() { const url = this.config.api + &#39;appapi.php?a=getPortalList&amp;catid=20&amp;page=1&#39;; const res = await this.ctx.curl(url); const response = JSON.parse(res.data); return response.result; } /** * getContent * @param aid 文章aid */ public async getContent(aid: string) { const url = this.config.api + &#39;appapi.php?a=getPortalArticle&amp;aid=&#39; + aid; const res = await this.ctx.curl(url); const response = JSON.parse(res.data); console.log(response.result); return response.result; } } Controllerimport { Controller } from &#39;egg&#39;; export default class AdminController extends Controller { public async index() { const { ctx } = this; const data = await ctx.service.news.getNewsList(); await ctx.render(&#39;news.ejs&#39;, { data, }); } public async newsContent() { const { ctx } = this; const aid = ctx.query.aid; const data = await ctx.service.news.getContent(aid); await ctx.render(&#39;newscontent.ejs&#39;, { data: data[0], }); } } ejsnews.ejs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;News&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;新闻列表&lt;/h2&gt; &lt;ul&gt; &lt;% for( let i = 0; i &lt; data.length; i++ ) { %&gt; &lt;li&gt;&lt;a href=&quot;/newscontent?aid=&lt;%= data[i].aid %&gt;&quot; &gt;&lt;%= data[i].title %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; newscontent.ejs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;详情&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%- data.content %&gt; &lt;script&gt; document.title = &#39;&lt;%= data.title %&gt;&#39; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 最终效果 框架拓展extend有多种拓展自身的功能 Application Context Request Response Helper Applicationapp 对象指的是 Koa 的全局应用对象，全局只有一个，在应用启动时被创建 拓展方式框架会把 app/extend/application.ts 中定义的对象与 Koa Application 的 prototype 对象进行合并，直接创建文件进行编码即可，例如 import { Application } from &#39;egg&#39;; export default { func(this: Application) { return &#39;app extend&#39;; }, }; 在app对象中直接调用方法即可 其他对象拓展方式跟Application同样注意：request和response是在ctx里面使用的 中间件middleware配置中间件 Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。 一个中间件是一个放置在 app/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数： options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来。 app: 当前应用 Application 的实例。 来看一下代码示例，这个中间件的作用是在每次请求的时候打印出时间 import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { ctx.logger.info(new Date()); await next(); }; } 中间件写完之后要在config中进行配置，在middlewware数组中添加文件名 然后每次请求时就会看到打印出了日志 中间件传值中间件传值在配置文件中bizConfig中增加中间件同名对象，就可以在中间件中通过options来访问变量 const bizConfig = { // 中间件传值 printdate: { configStr: &#39;this is value from config&#39;, }, }; 这时中间件需要配置参数 import { Context, Application, EggAppConfig } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(options: EggAppConfig[&#39;printdate&#39;], app: Application): any { app.logger.warn(options.configStr); return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { ctx.logger.info(new Date()); await next(); }; } 服务启动时就会在控制台看到打印出来的日志 实用中间件csrf中间件import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function auth(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { // 设置全局变量 ctx.state.csrf = ctx.csrf; await next(); }; } 然后在config中添加中间件config.middleware = [ &#39;auth&#39; ];，就可以在任意页面上获取csrf了 CookieCookie是存储在访问者计算机中的变量，可以让同一个浏览器访问同一个域名的时候共享数据 Egg中Cookie的设置和获取设置ctx.cookies.set(key, value, options) public async add() { const { ctx } = this; ctx.cookies.set(&#39;username&#39;, ctx.request.body.username); ctx.body = ctx.request.body; } 在浏览器的开发者工具中查看Cookie 获取ctx.cookies.get(key, options) 设置 {Number} maxAge: 设置这个键值对在浏览器的最长保存时间。是一个从服务器当前时刻开始的毫秒数。 {Date} expires: 设置这个键值对的失效时间，如果设置了 maxAge，expires 将会被覆盖。如果 maxAge 和 expires 都没设置，Cookie 将会在浏览器的会话失效（一般是关闭浏览器时）的时候失效。 {String} path: 设置键值对生效的 URL 路径，默认设置在根路径上（/），也就是当前域名下的所有 URL 都可以访问这个 Cookie。 {String} domain: 设置键值对生效的域名，默认没有配置，可以配置成只在指定域名才能访问。 {Boolean} httpOnly: 设置键值对是否可以被 js 访问，默认为 true，不允许被 js 访问。 {Boolean} secure: 设置键值对只在 HTTPS 连接上传输，框架会帮我们判断当前是否在 HTTPS 连接上自动设置 secure 的值。 除了这些属性之外，框架另外扩展了 3 个参数的支持： {Boolean} overwrite：设置 key 相同的键值对如何处理，如果设置为 true，则后设置的值会覆盖前面设置的，否则将会发送两个 set-cookie 响应头。 {Boolean} signed：设置是否对 Cookie 进行签名，如果设置为 true，则设置键值对的时候会同时对这个键值对的值进行签名，后面取的时候做校验，可以防止前端对这个值进行篡改。默认为 true。 {Boolean} encrypt：设置是否对 Cookie 进行加密，如果设置为 true，则在发送 Cookie 前会对这个键值对的值进行加密，客户端无法读取到 Cookie 的明文值。默认为 false。 Session Cookie 在 Web 应用中经常承担标识请求方身份的功能，所以 Web 应用在 Cookie 的基础上封装了 Session 的概念，专门用做用户身份识别 Session保存在服务器上 Egg中使用Session 可以在config中配置session信息 exports.session = { key: &#39;EGG_SESS&#39;, maxAge: 24 * 3600 * 1000, // 1 天 httpOnly: true, encrypt: true, }; 代码代码已上传码云，传送门","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://easyremember.cn/tags/Node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"VS Code 实用插件","slug":"资源/VSCode使用插件集合","date":"2020-08-13T06:25:25.881Z","updated":"2020-09-05T09:40:22.694Z","comments":true,"path":"2020/08/13/资源/VSCode使用插件集合/","link":"","permalink":"https://easyremember.cn/2020/08/13/资源/VSCode使用插件集合/","excerpt":"","text":"VSCode使用插件集合any-rule一款正则表达式生成插件，安装之后使用Ctrl+Shift+P调出命令面板，输入zz就可以看到常用的正则表达式，回车即可插入代码中 Auto Rename Tag可以自动修改闭合的标签，修改前半部分标签，后半部分自动跟随修改，再也不会乱了 Bracket Pair Colorizer彩色括号插件，当代码中括号过多的时候很容易混乱，有了这款插件之后，配对的标签会渲染为同一种颜色，括号配对关系相当清楚 Easy LESS可以自动将less文件编译为css文件 essjs可以自动添加很多Egg框架的代码片段，比如controller、service之类，大大提高编码效率 Git History插件提供可视化查看git信息，提交记录等 htmltagwrap这款插件可以对选中的代码进行标签嵌套，选中代码之后使用组合快捷键Alt+W触发，嵌套标签时不用再剪来剪去了 Indenticator可以在高亮显示鼠标选中的代码块所在的层级 JavaScript (ES6) code snippets可以通过简写快速插入ES6语法的js代码片段，详细见简写使用文档 Live Server这也是一款很强大的插件，通过服务器展示html，在html文件中右键选择open with live server就可以在浏览器中查看网页效果 Path Autocomplete自动补全路径的插件，快速的填写路径，可以通过./、C:(磁盘路径)等触发 RegExp Preview and Editor一款正则表达式验证插件，可以展示正则式匹配的全过程，安装插件之后可以选中正则式右键来查看匹配过程 还有一个正则编辑器，通过Ctrl+Shift+P调出命令面板，搜索regexp editor命令来触发，可以一边写一边展示匹配过程 REST Client直接在VSCode中进行接口数据测试的一款插件，在文件区域新建一个.http后缀的文件，然后编写接口测试，比如GET方法，url是127.0.0.1:7001，编写出来就是 GET http://127.0.0.1:7001 不同的接口之间使用三个#进行分割，编写好接口之后会在url上面出现一个Send Request，点击就可以使用了 Vue VSCode Snippets可以快速插入Vue代码片段，非常方便，更多快捷命令见文档说明 ESLint代码规则检查插件，当代码中出现不符合ESlint语法规范时会有报错","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"高级组件provide/inject","slug":"技术/高级组件provide-inject","date":"2020-08-12T06:56:52.036Z","updated":"2020-09-05T09:34:58.314Z","comments":true,"path":"2020/08/12/技术/高级组件provide-inject/","link":"","permalink":"https://easyremember.cn/2020/08/12/技术/高级组件provide-inject/","excerpt":"","text":"高级组件provide / inject官方文档介绍 类型 provide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是： 一个字符串数组，或 一个对象，对象的 key 是本地的绑定名，value 是： 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或 一个对象，该对象的： from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol) default 属性是降级情况下使用的 value 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 人话开始简单的来说就是在父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量。 示例父组件中使用provide定义一个变量 provide: { father: &quot;demo&quot;, }, 子组件使用inject引入变量 inject: [ &quot;father&quot; ], 再来看一下浏览器效果 可以看到浏览器的控制台成功的打印出了这个变量的值 上面提到，这种方式绑定的变量不是响应式的，我们来尝试一下 首先给父组件添加按钮绑定事件修改provide的值 provideHandle() { this.father = &quot;new demo&quot;; console.log(this.father); }, 然后来看效果 可以看到当点击按钮时，父组件的值已经改变，但是子组件中显示的依旧是原来的‘demo’ 响应方法：将父组件this对象作为返回值传递给子组件 废话少说，看效果 可以看到，子组件中的数据相应的发生了变化 更多示例","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Express中使用Sequelize实现ORM","slug":"技术/Express中使用Sequelize实现ORM","date":"2020-08-10T06:33:37.962Z","updated":"2020-09-05T09:37:31.675Z","comments":true,"path":"2020/08/10/技术/Express中使用Sequelize实现ORM/","link":"","permalink":"https://easyremember.cn/2020/08/10/技术/Express中使用Sequelize实现ORM/","excerpt":"","text":"Express中使用Sequelize实现ORM起步第一步当然是环境，首先使用Express生成器安装express环境 express myapp // myapp，你自己的项目名称（需要全局安装express） npm install 然后安装sequelize npm install --save sequelize npm install --save mysql2 // 驱动，这里主要说mysql，其他的类型见官网文档 连接连接到数据库必须有sequelize实例，实例化方法如下 const connect = new DB(&#39;dbname&#39;, &#39;username&#39;, &#39;password&#39;, { host: &#39;localhost&#39;, dialect: &#39;mysql&#39; }) 配置好实例之后可以使用.authenticate()来测试连接 connect.authenticate().then(() =&gt; { console.log(&#39;连接成功&#39;) }).catch(error =&gt; { console.error(&#39;连接失败:&#39;, error); }) 关闭连接 默认情况下，Sequelize将使连接保持打开状态，并对所有查询使用相同的连接。如果需要关闭连接，请调用sequelize.close()（它是异步的并返回Promise） 模型基础定义模型 模型是Sequelize的本质。模型是代表数据库中表的抽象。在Sequelize中，它是扩展Model的类 使用sequelize.define方法来定义模型，sequelize会根据定义的模型名称的复数自动建表 const Book = connect.define(&#39;Book&#39;, { bookName: DB.STRING, // 属性名： 数据类型 bookCounts: DB.INTEGER, detail: DB.STRING, }, { timestamps: false // 自动生成createAt和updateAt }) 此外也可以直接提供表名 sequelize.define(&#39;Book&#39;, { // ... attributes }, { tableName: &#39;literature&#39; }); 更多数据类型： // CHAR Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.TEXT(&#39;tiny&#39;) // TINYTEXT // NUMBER Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 10) // FLOAT(11,10) Sequelize.DOUBLE // DOUBLE Sequelize.DOUBLE(11) // DOUBLE(11) Sequelize.DOUBLE(11, 10) // DOUBLE(11,10) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) // TIME Sequelize.DATE // mysql / sqlite 为 DATETIME, postgres 为带时区的 TIMESTAMP Sequelize.DATE(6) // DATETIME(6) 适用 mysql 5.6.4+. 小数秒支持最多6位精度 Sequelize.DATEONLY // DATE 不带时间. // BOOLEAN Sequelize.BOOLEAN // TINYINT(1) //ENUM Sequelize.ENUM(&#39;value 1&#39;, &#39;value 2&#39;) // 一个允许值为&#39;value 1&#39;和&#39;value 2&#39;的ENUM // blob Sequelize.BLOB // BLOB (PostgreSQL 为 bytea) Sequelize.BLOB(&#39;tiny&#39;) // TINYBLOB (PostgreSQL 为 bytea. 其余参数是 medium 和 long) // GEOMETRY Sequelize.GEOMETRY // Spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. Sequelize.GEOMETRY(&#39;POINT&#39;) // 带有 geometry 类型的 spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. Sequelize.GEOMETRY(&#39;POINT&#39;, 4326) // 具有 geometry 类型和 SRID 的 spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. // unsigned 和 zerofill 属性 Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL 数据类型来源，掘金，云影sky的详细易用的 Sequelize 解读 模型同步使用model.async()方法来将模型与数据库同步 User.sync() -如果不存在则创建表（如果已经存在则不执行任何操作） User.sync({ force: true }) -这将创建表，如果该表已经存在，则将其首先删除 User.sync({ alter: true }) -这将检查数据库中表的当前状态（它具有哪些列，它们的数据类型等），然后在表中进行必要的更改以使其与模型匹配 创建模型实例使用model.build方法来创建模型实例 const jsBook = Book.build({ bookName: &#39;你不知道的JS&#39;, bookCounts: 3, detail: &#39;JS 进阶系列&#39;, }) 上面的创建实例之后使用jsBook.save();方法来保存到数据库 模型查询INSERT查询上面的模型保存还有一种简便方法，直接使用model.create方法，直接保存到数据库 Book.create({ bookName: &#39;你不知道的JS&#39;, bookCounts: 3, detail: &#39;JS 进阶系列&#39;, }) 可以看到数据库中已经生成了这条记录 控制台可以看到sql语句 SELECT查询find查询使用findAll方法查询整个表 Book.findAll() 效果图 可以使用attributes选项来进行列查询，数组中列出要查询的字段名 Book.findAll({ attributes: [&#39;id&#39;, &#39;bookName&#39;], }) 效果图 使用exclude删除一些选定的属性 Book.findAll({ attributes: { exclude: [&#39;bookCounts&#39;] }, }) 效果图 其他find查询 findByPk：使用提供的主键仅从表中获得一个条目 findOne：获取它找到的第一个条目（如果提供的话，它满足可选的查询选项） findOrCreate：查询不到实例就创建一个，返回值是实例（查到的或者创建的）和一个布尔值（创建为true） findAndCountAll：查询并计数，有两个返回值，一个是查询到的记录另一个是count where子句使用where选项可以进行where查询 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, id: 1 } }) // SELECT * FROM books WHERE bookName = &#39;你不知道的JS&#39; AND id = 1; 效果如图 有了AND就有OR，使用Op.or来进行or操作 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, id: { [Op.or]: [1, 2] } } }) // SELECT * FROM books WHERE bookName = &#39;你不知道的JS&#39; AND (id = 1 OR id = 2); 效果图 AND也可以使用Op.and来操作，但是易读性不强（不常用） Book.findAll({ where: { [Op.and]: [ { bookName: &#39;你不知道的JS&#39; }, { id: { [Op.or]: [1, 2] } } ] } }) sequelize提供了更多运算 const { Op } = require(&quot;sequelize&quot;); Post.findAll({ where: { [Op.and]: [{ a: 5 }, { b: 6 }], // (a = 5) AND (b = 6) [Op.or]: [{ a: 5 }, { b: 6 }], // (a = 5) OR (b = 6) someAttribute: { // Basics [Op.eq]: 3, // = 3 [Op.ne]: 20, // != 20 [Op.is]: null, // IS NULL [Op.not]: true, // IS NOT TRUE [Op.or]: [5, 6], // (someAttribute = 5) OR (someAttribute = 6) // Using dialect specific column identifiers (PG in the following example): [Op.col]: &#39;user.organization_id&#39;, // = &quot;user&quot;.&quot;organization_id&quot; // Number comparisons [Op.gt]: 6, // &gt; 6 [Op.gte]: 6, // &gt;= 6 [Op.lt]: 10, // &lt; 10 [Op.lte]: 10, // &lt;= 10 [Op.between]: [6, 10], // BETWEEN 6 AND 10 [Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15 // Other operators [Op.all]: sequelize.literal(&#39;SELECT 1&#39;), // &gt; ALL (SELECT 1) [Op.in]: [1, 2], // IN [1, 2] [Op.notIn]: [1, 2], // NOT IN [1, 2] [Op.like]: &#39;%hat&#39;, // LIKE &#39;%hat&#39; [Op.notLike]: &#39;%hat&#39;, // NOT LIKE &#39;%hat&#39; [Op.startsWith]: &#39;hat&#39;, // LIKE &#39;hat%&#39; [Op.endsWith]: &#39;hat&#39;, // LIKE &#39;%hat&#39; [Op.substring]: &#39;hat&#39;, // LIKE &#39;%hat%&#39; [Op.iLike]: &#39;%hat&#39;, // ILIKE &#39;%hat&#39; (case insensitive) (PG only) [Op.notILike]: &#39;%hat&#39;, // NOT ILIKE &#39;%hat&#39; (PG only) [Op.regexp]: &#39;^[h|a|t]&#39;, // REGEXP/~ &#39;^[h|a|t]&#39; (MySQL/PG only) [Op.notRegexp]: &#39;^[h|a|t]&#39;, // NOT REGEXP/!~ &#39;^[h|a|t]&#39; (MySQL/PG only) [Op.iRegexp]: &#39;^[h|a|t]&#39;, // ~* &#39;^[h|a|t]&#39; (PG only) [Op.notIRegexp]: &#39;^[h|a|t]&#39;, // !~* &#39;^[h|a|t]&#39; (PG only) [Op.any]: [2, 3], // ANY ARRAY[2, 3]::INTEGER (PG only) // In Postgres, Op.like/Op.iLike/Op.notLike can be combined to Op.any: [Op.like]: { [Op.any]: [&#39;cat&#39;, &#39;hat&#39;] } // LIKE ANY ARRAY[&#39;cat&#39;, &#39;hat&#39;] // There are more postgres-only range operators, see below } } }); UPDATE查询使用model.update方法来进行数据更新 Book.update({ bookCounts: 5 }, { where: { id: 2 } }) // UPDATE books SET bookCounts =5 WHERE id = 2; 修改后的数据如下 DELETE查询使用model.destory方法进行删除操作 Book.destory({ where: { id: 2 } }) 限制和分页使用limit和offset选项进行限制/分页 limit：每一页的记录数量限制 offset：第几页，从0开始 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, }， offset: parseInt(req.query.page) ? parseInt(req.query.page) : 0, limit: 1 }) 实用方法 进阶用法getter&amp;setter 事务","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://easyremember.cn/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"TypeScript学习笔记","slug":"笔记/TypeScript学习笔记","date":"2020-08-06T15:25:45.926Z","updated":"2020-09-09T23:42:30.538Z","comments":true,"path":"2020/08/06/笔记/TypeScript学习笔记/","link":"","permalink":"https://easyremember.cn/2020/08/06/笔记/TypeScript学习笔记/","excerpt":"","text":"TypeScript学习笔记1 简介TypeScript是由微软推出的编程语言，是javascript的超集，遵循ES5、ES6规范，拓展了js的语法 TypeScript更像是java等后端语言，可以开发大型企业项目，最新的前端框架基本都是使用了TS 2 安装npm install -g typescript cnpm以及yarn安装方式一样 3 编译及配置3.1 编译浏览器不识别ts代码，需要将ts代码编译为ES5的代码 新建index.ts脚本，编写代码 console.log(&quot;hello TS&quot;); 使用 tsc index.ts 命令进行编译 编译完成之后会生成index.js脚本，内容是 这一段代码看不出差别，来一段ts语法的代码 let str:String = &#39;feng&#39;; console.log(str); 再来看看编译出来的js脚本 3.2 在vscode中配置自动编译每次写完代码手动保存很不方便，可以使用配置文件自动生成js 在根目录下运行命令 tsc --init生成配置文件tsconfig.json 将outDir一行的注释打开，目录修改为要输出到的目录，不修改也可 点击选项卡终端-&gt;运行任务-&gt;typescript-&gt;tsc监视，然后再编写ts代码保存时就可以自动生成js了 4 数据类型ts为了使编写代码更规范增加了类型校验，ts主要提供了以下几种类型的数据 布尔类型（boolean） 数字类型（number） 字符串类型（string） 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 4.1 布尔类型在变量标识符之后声明变量类型为boolean，那么这个变量只能接受布尔类型的赋值，如果赋值为其他类型的数据，在编译时会报错，例如 let isReal: boolean = 123; 定义布尔类型的变量isReal，然后为其赋值数字123，在编译时会抛出下面错误 意思是’123’不能赋值给boolean类型的变量 4.2 数值类型规则同布尔类型，声明的标识符是number 整形和浮点型都可以用number声明 4.3 字符串类型声明的标识符是string 4.4 数组类型声明方式有两种： 使用中括号 let arr:number[] = [1,2,3] // 数字类型的数组不能出现其它数据类型 使用泛型声明 let arr: Array&lt;number&gt; = [1, 2, 3] 4.5 元组类型let tuple:[string, number, boolean] = [&#39;feng&#39;, 11, true] 元组也是一种数组，可以指定数组的每一项的数据类型 4.6 枚举类型枚举类型用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。 枚举类型可以手动设置值 enum Flag { success = 1, error = -1 } let f: Flag = Flag.success console.log(f);// 1 // 另外一种手动设置的方式，只定义第一项，后面的依次递增 enum Animal { cat = 2, dog, snake } var a: Animal = Animal.snake; console.log(a); // 4 // 自定义值可以在任意位置，上面的代码汇中如果只定义dog=2，那么snake就是3 也可以使用默认值，默认值就是索引值 enum Color { blue, red, green } const c: Color = Color.blue; console.log(c); // 0 4.7 任意类型在上面的基本类型中，一旦定义了类型就不能再赋值其他类型的数据，否则就会报错 那如果想给一个变量赋值多种类型的数据就需要用到any来声明变量了 在ts文件中写入以下代码 var node = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 保存时会抛出以下错误 编译之后代码是可以运行的，但是存在问题 意思是node是一个Object类型，这时再给node声明Object类型 var node:Object = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 这时还会报错，因为进本数据类型中没有Object，这时就可以使用any类型了 var node: any = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 4.8 null和undefinednull和undefined是其他数据类型的子类 undefined声明变量是undefined类型之后，变量undefined不会报错，例如 但如果定义了undefined类型就不会报错 undefined一般用于联合类型 var num: number | undefined; num = 123; console.log(num); num可以是number类型，也可以是undefined null变量声明null之后只能为空值，如果为变量赋值就会报错 等于空值时不会报错 4.9 void类型用于定义没有返回值的方法 ((): void =&gt; { console.log(&#39;void&#39;); })() lambda表达式的写法 4.10 never类型其他类型，表示从不会出现（包括null和undefined的子类型），被never声明的变量只能被never类型的数据赋值 5 函数5.1 声明函数5.1.1 命名函数在TypeScript中声明函数时，要声明参数类型以及函数返回值类型 没有返回值使用void进行声明 function run(): string { return &#39;string&#39; } 在声明函数返回值类型之后，返回值的类型必须是声明的类型，否则报错 5.1.2 匿名函数在TypeScript中定义匿名函数也需要声明返回值类型 var func2 = function (): number { return 123; } 同样，返回值需要符合声明的返回值类型，不一致则会报错 5.2 传参定义一个方法，接收一个firstname和一个lastname，返回一个fullname function getName(firstname: string, lastname: string): string { return `${firstname}--${lastname}` } console.log(getName(&#39;Chan&#39;, &#39;Jack&#39;)); // Chan--Jack 匿名函数同样的在参数后声明类型 5.2.1 可选参数在func3中，有两个参数，现在调用func3，只传一个参数 function func3(name: string, age: number): void { console.log(name + &quot;--&quot; + age); } func3(&#39;zhangsan&#39;); 编译时会报错，原因是少了一个参数 在可选参数后添加?，表示参数可以有也可以没有 可选参数必须放到参数的最后面 5.2.2 默认参数在ES5中不可以设置默认参数，在ES6和TS中可以设置默认参数 function func3(name: string, age: number=20): void { console.log(name + &quot;--&quot; + age); } func3(&#39;zhangsan&#39;); // zahngsan--20 当默认参数在最后时，设置默认参数之后可以不传参数，使用默认的值，当默认参数在前面时必须传参数 5.2.3 剩余参数当不确定参数的数量时，可以使用ES6的扩展运算符（...） function getSum(...args: number[]): void { var result: number = 0; args.forEach(element =&gt; { result += element }); console.log(result); } getSum(1, 2, 3, 4) // 10 getSum(1, 2, 3, 4, 5) // 15 也可以固定前几个参数，然后后面的用扩展运算符接收 function getSum2(a: number, ...args: number[]): void { var result: number = a; args.forEach(element =&gt; { result += element }); console.log(result); } getSum2(1, 2, 3, 4) // 10 5.3 函数重载 java中的重载：两个或两个以上同名函数，但是他们接收的参数不一样，这时会出现函数重载 TypeScript中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的 function getInfo(name: string): string; function getInfo(age: number): string; function getInfo(str: any): any { if (typeof str === &#39;string&#39;) { return &#39;我叫&#39; + str } else { return &#39;我的年龄是&#39; + str } } console.log(getInfo(&#39;zahngsan&#39;)); console.log(getInfo(12)); 来看下结果 显然，ts在通过这种方式为一个函数实现了两种功能，但是，传参的类型必须在重载的函数参数之内，如果匹配不到就会报错 6 类6.1 对比ES56.1.1 定义类在ES5中使用构造函数创建对象，直接在function内部添加属性和方法 function Person() { this.name = &#39;zhangsan&#39; this.getInfo = function () { console.log(this.name); } } var p = new Person(); p.getInfo(); // zhangsan 还可以通过原型链的方式给对象添加属性和方法 Person.prototype.age = 20; Person.prototype.getAge = function () { console.log(this.age); } var p = new Person(); p.getAge(); // 20 但是，使用原型链添加的引用类型属性会被所有实例共享，意思就是当某一实例的该属性变化时，其他实例的属性都会改变 Person.prototype.friends = [&#39;f1&#39;, &#39;f2&#39;]; Person.prototype.getFriends = function () { console.log(this.friends); } var p = new Person(); p.getFriends(); var p2 = new Person(); p2.friends.push(&#39;f3&#39;); p.getFriends(); p2.getFriends(); 可以看到，改变一个实例的引用类型的属性，另一个实例也变了；基本数据类型不存在这种问题 6.1.2 静态方法ES5中给对象添加静态方法非常简单 Person.static = function () { console.log(&#39;静态方法&#39;); } Person.static(); // 静态方法 静态方法不需要实例化就可以调用，并且，对象实例不可以调用静态方法 6.1.2 继承ES5中通过对象冒充来实现继承 function People() { Person.call(this); } var peo = new People(); peo.getInfo(); // zhangsan 此外也可以通过原型的方法来实现继承 function People() { } People.prototype = new Person(); var peo = new People(); peo.getInfo(); 但是在实例化子类时无法给父类传参 function Person(name) { this.name = name; this.getInfo = function () { console.log(this.name); } } function People() { } People.prototype = new Person(); var peo = new People(&#39;zhangsan&#39;); peo.getInfo(); // undefined 然后就有了原型链+构造函数的组合继承模式——寄生组合继承 function People(name) { Person.call(this, name) } People.prototype = Person.prototype; var peo = new People(&#39;zhangsan&#39;); peo.getInfo(); // zhangsan 6.2 TypeScript中的类6.2.1 定义类在TS中，使用class关键字来定义类，类需要实例化时需要添加构造器 class Person { name: string; // 属性 constructor(n: string) { // 构造函数，实例化时触发 this.name = n; } getName(): string { return this.name; } setName(name: string): void { this.name = name } } var p: Person = new Person(&#39;李四&#39;); console.log(p.getName()); // 李四 p.setName(&#39;张三&#39;); console.log(p.getName()); // 张三 拓展——params方式实例化class Article { title: string | undefined; desc: string | undefined; status: number | undefined constructor(params: { title: string | undefined, desc: string | undefined, status?: number | undefined }) { this.title = params.title; this.desc = params.desc; this.status = params.status; } } var newArticle: Article = new Article({ title: &#39;大事件&#39;, desc: &#39;都是小事&#39; }) console.log(newArticle); 通过向构造器传入json对象，然后使用索引值来实例化对象 6.2.2 继承TS中继承有专门的关键字extends，需要配合super初始化父类构造函数来实现继承 class People extends Person { constructor(name: string) { super(name); } } var peo = new People(&#39;王五&#39;); console.log(peo.getName()); // 王五 6.2.3 修饰符 public：公有，在类里面、子类、外部都可以访问 protected：保护，在类里面，子类中可以访问 private：私有，只有类里面可以访问 属性不加修饰符默认是public 6.2.4 静态属性&amp;静态方法使用static修饰符声明静态方法，但是静态方法无法直接获取类中的属性，只能获取静态属性（同样用static修饰） class Person { name: string; static age: number = 20; constructor(n: string) { // 构造函数，实例化时触发 this.name = n; } getName(): string { return this.name; } setName(name: string): void { this.name = name } static log(): void { console.log(`年龄是${this.age}`); } } Person.log(); // 年龄是20 6.2.5 多态父类定义一个方法不去实现，让继承他的子类去实现，每一个子类有不同的表现 class Animals { name: string; constructor(name: string) { this.name = name; } getInfo(): void { } } class Dog extends Animals { constructor(name: string) { super(name); } getInfo(): void { console.log(this.name + &#39;是一只狗&#39;); } } class Cat extends Animals { constructor(name: string) { super(name); } getInfo(): void { console.log(this.name + &#39;是一只猫&#39;); } } var cat: Cat = new Cat(&#39;kitty&#39;); cat.getInfo(); // kitty是一只猫 var dog: Dog = new Dog(&#39;Tony&#39;); dog.getInfo(); // Tony是一只狗 这段代码中有一个父类Animals，两个子类Dog和Cat分别继承Animals，Animals定义了一个getInfo方法，两个子类中分别重写了这个方法，实现了不同的功能 6.2.6 抽象类 提供其他类继承的基类，不能被实例化；用absort关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现；抽象方法只能放在抽象类中 abstract class AbstractAnimals{ abstract func1(): void; abstract func2(): string; } class Mouse extends AbstractAnimals{ func1(): void { console.log(&#39;function 1&#39;); } func2(): string { return &#39;function 2&#39; } } 7 接口 在面向对象程序设计中，接口是一种规范的定义，它规定了行为和动作的规范，起到了限制和规范的作用。接口定义了某一批类需要遵守的规范，不关心这些类内部的状态数据，也不关心方法实现细节，只规定类需要提供哪些方法。类似于java中的类，更加灵活。 定义接口关键字：interface 7.1 属性接口属性接口就是对json格式的限制 interface FullName { firstName: string; lastName: string; } function getFullName(name: FullName) { return `${name.firstName}----${name.lastName}` } console.log(getFullName({ firstName: &#39;zhang&#39;, lastName: &#39;san&#39; })); // zhang----san 在这段代码中，定义了一个FullName接口，方法getFullName参数name要满足这个接口，如果不满足接口定义的规则就会报错 并且，参数必须且只能有接口定义的数据项，如参数使用对象name，该对象必须包含接口定义的项并且符合数据类型限制 可以使用 ? 定义可选属性，用法同可选参数 7.2 函数类型接口对方法传入的参数以及返回值进行约束 interface FuncRule { (key: string, value: string): string; } var funcIn: FuncRule = function (key: string, value: string): string { return `${key}---${value}` } console.log(funcIn(&#39;name&#39;, &#39;张三&#39;)); 接口中规定了两个参数和他们的类型以及返回值的类型，实现这个接口的函数就必须有这两个参数和返回值。参数类型不符合规定就会报错 7.3 可索引接口对数组、对象的约束 7.3.1 对数组的约束interface UserArr{ [index:number]:string; } var arr:UserArr=[&#39;aa&#39;, &#39;bb&#39;] console.log(arr[0]) 接口规定了索引值是number类型，value是string类型（开始这里没看懂，数组的索引还能不是number？？？继续往下看） 7.3.2 对对象的约束interface UserObj{ [index:string]:string } var arr:UserObj = { name: &#39;alex&#39; } 这里明白了，对数组的约束和对对象的约束不是具体的分类，索引值是number就限定了数组，索引值是string就限定了对象 7.4 类类型接口类类型约束和抽象有些类似，这里最接近于java中的接口类 // 接口 interface AnimalsInterface { name: string; eat(food: string): void; } // 实现类 class Tigger implements AnimalsInterface { name: string; constructor(name: string) { this.name = name; } eat(food: string): void { console.log(`${this.name}吃的是${food}。`); } } // 实例化 var t: Tigger = new Tigger(&#39;泰哥&#39;); t.eat(&#39;猪肉&#39;); // 泰哥吃的是猪肉。 在实现接口方法的时候，参数可以没有 7.5 接口扩展（接口继承）interface Animals { eat(): void; } interface People extends Animals { name: string; work(): void; } class Chinese implements People { name: string; constructor(name: string) { this.name = name; } work(): void { console.log(this.name + &#39;可以工作&#39;); } eat(): void { console.log(this.name + &#39;吃大餐&#39;); } } var ming: Chinese = new Chinese(&#39;小明&#39;); ming.work(); 接口People继承了接口Animals，在实现People接口的时候，需要同时实现Animals中定义的内容，如果去掉了Animals中的方法就会报错 8 泛型 泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。将类型参数化以达到代码复用提高软件开发工作效率的一种数据类型。泛型类]是引用类型，是堆对象，主要是引入了类型参数这个概念。 ——百度百科《泛型》 8.1 泛型变量先来看个例子 function getValue&lt;T&gt;(value: T): string { return &#39;获得的值是&#39; + value; } console.log(getValue&lt;number&gt;(12345)); 定义方法时规定了泛型T，传参时使用泛型规定类型 8.2 泛型类java中的ArrayList就是这种东西 class ArrayList&lt;T&gt; { private list: T[] = []; add(item: T): void { this.list.push(item); } getList(): T[] { return this.list; } } var arr = new ArrayList&lt;number&gt;(); arr.add(1); arr.add(4); console.log(arr.getList()); 这里用number类型做了个例子，泛型可以是任意类型，类也可以 使用上文7.5中的Chinese类来示范 // 实例化对象 var ming: Chinese = new Chinese(&#39;小明&#39;); var hong: Chinese = new Chinese(&#39;小红&#39;); // 将对象添加进list var arr = new ArrayList&lt;Chinese&gt;(); arr.add(ming); arr.add(hong); console.log(arr.getList()); 8.3 泛型接口在定义接口时使用泛型，实现接口时相应的需要用泛型实现，调用方法时可以根据需要规定数据的类型 interface ConfigFn { &lt;T&gt;(value: T): T; // 最后一个T是返回值类型，可以是其他的 } var getData: ConfigFn = function &lt;T&gt;(name: T): T { return name; } console.log(getData&lt;string&gt;(&#39;张三&#39;)); 9 装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器装饰器的写法：普通装饰器（无法传参） 、 装饰器工厂（可传参） 装饰器是过去几年中js最大的成就之一，已是ES7的标准特性之一 9.1 类装饰器装饰器本身是一个函数，装饰器通过@符号来使用 function logClass(params: any) { params.prototype.name = &#39;装饰器&#39;; params.prototype.run = function () { console.log(&#39;这是一个装饰器&#39;); } } @logClass class Log { constructor() { } getData() { } } var log: any = new Log(); // 这里变量类型声明any log.run(); // 这是一个装饰器 9.1.1 装饰器工厂装饰器工厂可以传参，通过闭包的方式进行操作 function logClass(params?: any) { return function (target: any) { console.log(params); } } @logClass(&#39;get&#39;) class Log { constructor() { } } var log: any = new Log(); // get 这里调用装饰器的时候方法立即执行 function logClass(params?: any) { return function (target: any) { target.prototype.pro = params; } } @logClass(&#39;post&#39;) class Log { constructor() { } } var log: any = new Log(); console.log(log.pro); 上面这一段代码通过装饰器动态给类添加属性，在调用构造器的时候一定要加括号，参数可选时没有参数也要带括号 9.1.2 重载构造函数 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数； 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明； function logClass(target: any) { return class extends target { url = &#39;newValue&#39; getData() { console.log(&#39;getData:&#39;, this.url); } } } @logClass class HttpClient { public url: string | undefined; constructor() { this.url = &#39;value&#39; } getData() { console.log(this.url); } } var http = new HttpClient(); http.getData(); //getData: newValue 装饰器返回的就是HttpClient的子类，因此TS可以自动推导 http 的类型； 重载时必须将类里面的所有属性几方法重载 9.2 属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入两个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 成员的名字； function LogProperty(params: any) { return function (target: any, attr: any) { console.log(target); console.log(attr); } } class User { @LogProperty(&#39;zhangsan&#39;) name: string; constructor() { } } 从图中可以看到属性装饰器传入的两个参数 function LogProperty(params: any) { return function (target: any, attr: any) { target[attr] = params; } } class User { @LogProperty(&#39;zhangsan&#39;) name: string | undefined; constructor() { } getName(): void { console.log(this.name); } } var u = new User(); u.getName(); // zhangsan 9.3 方法装饰器方法装饰器被应用到方法的属性描述符上，可以用来监视、修改、替换方法的定义。方法装饰器会在运行时传入3个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 成员的名字； 成员的属性描述符； function get(params: any) { return function (target: any, methodName: any, desc: any) { console.log(target); console.log(methodName); console.log(desc); } } class HttpClient { url: string | undefined; constructor() { } @get(&#39;/user&#39;) getData() { console.log(&#39;getData: &#39;, this.url); } } 可以从打印结果看到方法装饰器的三个参数 function get(params:any) { return function(target:any, methodName:any, desc:any) { var oldMethod = desc.value; desc.value = function(...args:any[]) { let newArgs = args.map((item)=&gt;{ return String(item); }); oldMethod.apply(this, newArgs); } } } class HttpClient { constructor() { } @get(&#39;http://baidu.com&#39;) getData(...args:any[]) { console.log(&#39;getData: &#39;, args); } } var http = new HttpClient(); http.getData(1, 2, true); // getData: [&quot;1&quot;, &quot;2&quot;, &quot;true&quot;] 9.4 参数装饰器参数装饰器表达式会在运行时被调用，可以为类的原型增加一些元素数据，传入3个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 方法名称，如果装饰的是构造函数的参数，则值为undefined 参数在函数参数列表中的索引； function logParams(params:any) { return function(target:any, methodName:any, paramIndex:any) { console.log(target) // { constructor:f, getData:f } console.log(methodName) // getData console.log(paramIndex) // 0 } } class HttpClient { constructor() { } getData(@logParams(&#39;uuid&#39;) uuid:any) { console.log(uuid); } } 参数装饰器只能用来监视一个方法的参数是否被传入 9.5 装饰器执行顺序多个装饰器同时装饰到一个声明上，语法支持从左到右，或从上到下书写； 不同装饰器的执行顺序：属性装饰器 &gt; 方法装饰器 &gt; 参数装饰器 &gt; 类装饰器；","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"Vue组件通信","slug":"技术/Vue组件通信","date":"2020-08-04T13:44:18.572Z","updated":"2020-09-05T09:34:40.002Z","comments":true,"path":"2020/08/04/技术/Vue组件通信/","link":"","permalink":"https://easyremember.cn/2020/08/04/技术/Vue组件通信/","excerpt":"","text":"Vue组件间通信Vue中组件的通信方式大致有：父——子、子——父、兄弟之间的通信 父子传值父——子父组件向子组件传值的时候，使用v-bind绑定属性，携带要发送的数据，子组件通过props接收这个数据（要跟属性名相同） Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; &lt;Son :fromFather=&quot;fromFatherM&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFatherM: &quot;父组件的消息&quot;, }; }, }; &lt;/script&gt; 为了容易区分属性名和数据，数据后加了个M，子组件接收数据时要使用这里面的属性名 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, // 接收参数并指定类型 }, data() { return {}; }, }; &lt;/script&gt; 效果如图 子——父子组件向父组件发送数据要通过方法来完成，父组件引用子组件的时候向子组件传递一个方法，子组件通过触发事件向方法中传参来向父组件发行数据 Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; 接收：{{sonData}} &lt;Son :fromFather=&quot;fromFather&quot; @receive=&quot;receiveData&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFather: &quot;父组件的消息&quot;, sonData: &quot;&quot;, }; }, methods: { receiveData(d) { // 接收数据并赋值 this.sonData = d; }, }, }; &lt;/script&gt; 使用@receive绑定事件，子组件发出数据时需要向这个绑定事件提交 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;input type=&quot;text&quot; v-model=&quot;fromSon&quot; /&gt; &lt;button @click=&quot;sonHandle&quot;&gt;send&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, }, data() { return { fromSon: &quot;&quot;, }; }, methods: { sonHandle() { this.$emit(&quot;receive&quot;, this.fromSon); // 发送数据的事件 }, }, }; &lt;/script&gt; 效果如图 使用$parent和$children官方文档中还给出了一对API mounted() { console.log(this.$parent.id + &quot;$parent&quot;); }, mounted() { console.log(this.$children[0].id + &quot;$children&quot;); }, 这里一定要注意获取的数组 还可以通过$refs来获取，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 可以获取 上面三种方式的结果如图 兄弟组件兄弟组件传值可以借助一个空白组件，如果项目较大，可以使用Vue官方状态管理Vuex，之后会发Vuex的介绍","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"JS正则表达式","slug":"技术/JS正则表达式","date":"2020-08-03T16:26:08.012Z","updated":"2020-09-05T09:37:39.102Z","comments":true,"path":"2020/08/04/技术/JS正则表达式/","link":"","permalink":"https://easyremember.cn/2020/08/04/技术/JS正则表达式/","excerpt":"","text":"JS正则表达式创建正则的两种方式： 创建字面量正则表达式，使用//包裹 let reg = /\\w/ 创建正则表达式对象，使用new RegExp() let reg = new RegExp(/\\w/) 选择符 |“I” 左右两边匹配到一个就算是true let str = &#39;张三：010-1568413，李四：020-1586640&#39; let reg = /(010|020)\\-\\d{7,8}/ console.log(reg.test(str)); // true 转义在字符串中\\d和d是一样的 console.log(&#39;\\d&#39; === &#39;d&#39;) // true 在创建字面量的时候直接使用//创建，或者在字符串中转义 let str = &#39;123.abc&#39; let reg = &quot;\\\\d+\\\\.\\\\w+&quot; let reg2 = /\\d+\\.\\w+/ console.log(str.match(reg)); console.log(str.match(reg2)); 边界以^开始，以$结束，可用于检测网址开头和文件后缀 ^开始边界let str = &#39;http:www.easyremember.cn&#39; let reg = /^https?:www\\..+/ console.log(reg.test(str)); // true $结束边界let str = &#39;C://Users/All Users/abc.txt&#39; let str2 = &#39;C://Users/All Users/abc.log&#39; let reg = /\\.txt$/ console.log(reg.test(str)); // true console.log(reg.test(str2)); // false 元字符\\w：所有的字母、数字、下划线 \\W：所有的非数字、字母、下划线 \\d：所有的数字 \\D：所有的非数字 \\s：所有的空白字符，换行、空格等 \\S：所有的非空白字符 .：除换行以外的任意字符 模式修饰符 i：不区分大小写 g：全局匹配 y：从lastIndex开始匹配 u：处理UTF-16编码字符 m：多行处理 s：单行处理，忽略换行符 原子表 原子表 说明 [] 只匹配其中的一个原子 [^] 只匹配”除了”其中字符的任意一个原子 [0-9] 匹配0-9任何一个数字 [a-z] 匹配小写a-z任何一个字母 [A-Z] 匹配大写A-Z任何一个字母 Tips:\\d == [0-9] \\D == [^0-9] 原子组使用（）包裹 引用分组：引用之前原子组匹配到的内容，\\1\\2…… let str = &#39;abc123.c123&#39; let reg = /([a-z]\\d+)\\.\\1/g console.log(str.match(reg)); // [&quot;c123.123&quot;] 分组别名 为不同分组命名，使用?&lt;&gt;命名，使用$&lt;&gt;引用 let str = &#39;abc123.c123&#39; let reg = /(?&lt;init&gt;[a-z]\\d+)\\.\\1/g // console.log(str.match(reg)); console.log(str.replace(reg, `&lt;p&gt;$&lt;init&gt;&lt;/p&gt;`)); 重复+：重复一次或多次 *：重复零次或多次 ?：重复零次或一次 {n}：重复n次 {n,}：重复n次或更多次 {n,m}：重复n次到m次 let str = &#39;1234&#39; let reg = /\\d/ let reg2 = /\\d+/let reg3 = /^\\d{1,2}$/ console.log(str.match(reg)); console.log(str.match(reg2)); console.log(reg3.test(str)); 字符方法search返回要搜索内容的索引，没有返回-1 let str = &#39;abcdef&#39; console.log(str.search(&#39;ef&#39;));// 4 console.log(str.search(/\\w/)); // 0 console.log(str.search(&#39;efg&#39;)); // -1 match使用字符串或者正则表达式匹配，返回匹配的内容，匹配不到返回null let str = &#39;abcdef&#39;console.log(str.match(&#39;ef&#39;)); // ef console.log(str.match(/\\w+/)); // abcdef matchAll：返回一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` for (let s of str.matchAll(reg)) { console.log(s); } split：使用字符分割字符串 let str = &#39;abc/def/123&#39; console.log(str.split(&#39;/&#39;)); // [&quot;abc&quot;,&quot;def&quot;,&quot;123&quot;] replace替换字符为 let str = &#39;abc/def/123&#39; console.log(str.replace(/\\W/g, &#39;-&#39;)); // abc-def-123 正则方法test检测字符串是否符合要求，返回值是一个布尔值 exec不使用全局匹配与match相同，使用全局匹配会匹配完全部字符串，返回结果是一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` console.log(reg.exec(str)); console.log(reg.exec(str)); 断言?=exp相当于if，但是是后置的例如 &lt;main&gt; 中国努力建设有中国特色社会主义&lt;/main&gt; &lt;script type=&quot;text/javascript&quot;&gt; let reg = /中国(?=特色)/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) &lt;/script&gt; ?&lt;=exp前置断言 let reg = /(?&lt;=有)中国/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) 效果跟前面的?=效果是一样的 ?!exp后面不能出现exp匹配到的内容 ?&lt;!exp前面不能出现exp匹配到的内容","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"let、const和var的区别","slug":"技术/let、const和var","date":"2020-08-02T11:09:59.170Z","updated":"2020-09-05T09:37:43.284Z","comments":true,"path":"2020/08/02/技术/let、const和var/","link":"","permalink":"https://easyremember.cn/2020/08/02/技术/let、const和var/","excerpt":"","text":"let、const和var作用域var作用于全局，先来看一个例子 for (var i = 0; i &lt; 5; i++) { var a = 1; } console.log(a, i); // 1 5 跳出了for循环之外a依旧可以访问，用于控制循环的i也能够访问，i=5循环跳出，所以i是5 再来看一下把var改成const for (var i = 0; i &lt; 5; i++) { const a = 1; } console.log(a, i); // Uncaught ReferenceError: a is not defined 这时a是块级作用域，除了循环之后就访问不到了，再来看i，把i改成const声明 Uncaught TypeError: Assignment to constant variable. const属于常量，赋值之后不能改变，这里应该用let，let是变量 重复声明var b = 1; var b = 2; console.log(b); // 2 用var可以重复声明，再来试一下const const b = 1; const b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 可以看出const不可以重复声明，再来试一下let let b = 1; let b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 由此可以看出，const和let不可以重复声明 总结cosnt和let是ES6新出的块级作用域，不可以重复声明，此外 const b; b = 2; console.log(b); // Uncaught SyntaxError: Missing initializer in const declaration const不可以先声明后赋值，let可以 上面说到const不可以重新赋值，有一种情况例外 const b = { a: &#39;a&#39; }; b.a = &#39;b&#39;; console.log(b); 来看一下结果 可以看到值已经发生了改变","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Less预编译使用","slug":"笔记/Less预编译","date":"2020-08-02T06:11:51.895Z","updated":"2020-09-14T23:49:24.930Z","comments":true,"path":"2020/08/02/笔记/Less预编译/","link":"","permalink":"https://easyremember.cn/2020/08/02/笔记/Less预编译/","excerpt":"","text":"less预编译1 初见lessless是一门向后兼容的 CSS 扩展语言。 HTML标签不能直接识别less样式，需要引入less.js来编译 引入样式文件 &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt; 引入编译脚本 &lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 但是，这种方式是运行时编译，不是预编译，在VSCode插件商店中搜索less下载对应的编译插件 每次保存less文件时就可以自动编译出css文件 2 less语法2.1 注释less有两种注释 常规的css注释 /* 可见注释，会被编译到css文件中 */ 编译后不可见注释 // 不可见注释，不会被编译到css文件中 2.2 变量使用@符号声明变量，样式中可以引用，less的变量都是块级作用域，直接上代码，一目了然 less块级作用域：首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承 @width: 10px; @height: @width + 10px; .box { width: @width; height: @height; } 编译结果为 属性名和选择器也可以用变量，但是在引用的时候需要用 {}包裹起来，上代码 @width: 10px; @height: @width + 10px; @m: margin; @selector: #nav; .box { @{m}: 10px; width: @width; height: @height; } @{selector} { color: red; } 来看下编译后的，属性和选择器引用很少使用 变量延迟加载 .over { @var: 1; .three { @var: 2; three: @var; @var: 3; } one: @var; } one属性是在over作用域中的，跟brass无关，所以one的值是1；在brass作用域中，要等变量先加载完再引用，这就是延迟加载，所以three的值是3 2.3 嵌套前面的代码已经能够体现嵌套规则了，可以根据HTML的层级关系来嵌套css样式，伪类选择器也是可以嵌套的 .box { width: @width; height: @height; background-color: pink; :hover { background-color: deeppink; } } 编译结果是这样的 注意这里多了一个空格，这样是不生效的，那怎么样去掉这个空格呢，使用&amp;取消父子关系，让两个类挨在一起 .box { width: @width; height: @height; background-color: pink; &amp;:hover { background-color: deeppink; } } 再来看结果 空格没了 2.3.1 @嵌套和冒泡@ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变 例如 .component { width: 600px; @media (min-width: 768px) { width: 300px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } @media (min-width: 1280px) { width: 800px; } } 这段代码在component类中嵌套了三个媒体查询，编译之后media会编译到最外层 2.4 混合2.4.1 混合混合就是将一系列属性从一个规则集引用到另一个规则集的方式，简单来说已定义的类可以在另一个类中进行引用 .border { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 结果 引用混合的时候，混合没有参数时，括号可以加也可以不加；混合需要使用默认参数时，括号必须加 2.4.2 不编译的混合如果只想定义一个混合，在选择其后面加一个括号，那么这个混合不会被编译 .border() { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 编译结果只有.border-2这个类 2.4.3 带参数的混合类似于js定义方法一样接收参数，然后进行编译（但是，他不叫函数，叫混合） .bar(@w, @h, @color) { width: @w; height: @h; color: @color; } .nav-bar { .bar(100px, 200px, #409eff); } 在引用bar的时候将参数填入，然后进行编译 可以设置参数的默认值，可以传递命名参数 .bar(@w: 10px, @h:10px, @color:green) { width: @w; height: @h; color: @color; } .nav-bar { .bar(@color: #409eff); } 结果 当引用混合的时候不加任何参数就会全部使用默认值 2.4.4 匹配模式根据标识匹配混合，下面定义了4种样式，分别是上右下左边框 .border-style(@_, @w, @h, @c) { border-style: solid; } .border-style(T, @w, @h, @c) { width: @w; height: @h; border-color: @c transparent transparent transparent; } .border-style(R, @w, @h, @c) { width: @w; height: @h; border-color: transparent @c transparent transparent; } .border-style(B, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent @c transparent; } .border-style(L, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent transparent @c; } .border-3 { .border-style(B, 100px, 100px, #000); } 匹配效果如图 注意代码开始的地方 .border-style(@_, @w, @h, @c) { border-style: solid; } 这一段，@_用来匹配L、R、B、T标识，每次使用匹配模式时自动带上这段公共代码 2.4.5 @arguments@arguments包含传进来的所有参数 .border_arg(@w:30px,@c:red,@sty:solid){ border:@arguments; } .test_arguments{ .border_arg(); } 结果如图 2.5 运算 算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。计算的结果以最左侧操作数的单位类型为准。如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px 到 cm 或 rad 到 % 的转换 @color: #224488 / 2; //结果是 #112244 background-color: #112244 + #111; // 结果是 #223355,#111-&gt;#111111 2.6 转义当需要引入无效的CSS语法或Less不能识别的字符，就需要使用转义字符，在字符串前面加一个 ~，并将需要转义的字符串放在 “” 中 @min768: ~&quot;(min-width: 768px)&quot;; .element { @media @min768 { color: pink; } } // 结果 @media (min-width: 768px) { .element { color: pink; } } 在需要使用cacl()的时候less会自动编译括号里面的东西 使用转义来避免自动编译 .no { height: 100 +20px; width: ~&quot;cacl(200px + 20)&quot;; } 2.7 映射 Less 3.5 版本开始，可以将混合和规则集作为一组值的映射（map）使用 #colors() { primary: blue; secondary: green; } .button { color: #colors[primary]; border: 1px solid #colors[secondary]; } // 结果 .button { color: blue; border: 1px solid green; } 2.8 导入less文件导入可以省略后缀名 @import &quot;main&quot;; // mian.less @import &quot;style.css&quot;; 2.9 继承使用extend函数继承一个类 .middle { margin: 0 auto; } .footer:extend(.middle) { color: pink; } 编译之后的middle类将会变成两个类公共部分，用逗号连接","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"https://easyremember.cn/tags/css/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"动态控制输入框数量","slug":"随想/动态控制输入框","date":"2020-08-01T14:00:17.672Z","updated":"2020-09-05T09:35:01.008Z","comments":true,"path":"2020/08/01/随想/动态控制输入框/","link":"","permalink":"https://easyremember.cn/2020/08/01/随想/动态控制输入框/","excerpt":"","text":"动态控制输入框在开发中经常会遇到根据情况动态控制输入框的情况，以前都是使用UI框架提供的组件，这次自己动手完成了一个简易的动态输入框 先来上效果 正片开始 加减号使用fontawesome的图标不多做赘述 先来看一下标签 &lt;div id=&quot;upload-problem-outin&quot; v-for=&quot;(item, index) in problem.sample&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.inputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输入样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.outputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输出样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;/div&gt; problem.sample是problem对象中的样例相关部分，格式如下 sample: [{ inputSample: &#39;&#39;, outputSample: &#39;&#39; }], 通过v-for遍历sample数组来渲染样例组数，通过数据绑定，控制sample数组的内容来实现样例组数的渲染 再来看一下控制的方法 addSample() { this.problem.sample.push({ inputSample: &#39;&#39;, outputSample: &#39;&#39; }) }, subSample() { if(this.problem.sample.length &lt; 2) { alert(&#39;至少保留一组&#39;) return } this.problem.sample.pop() } 触发增加事件时向原数组追加一个sample对象，触发减少事件时丢掉最后一项，智力有一个判断，即样例数不能少于1 大功告成","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"Vue绑定不到组件","slug":"随想/Vue子路由常见的问题","date":"2020-08-01T10:38:09.001Z","updated":"2020-09-05T09:39:17.258Z","comments":true,"path":"2020/08/01/随想/Vue子路由常见的问题/","link":"","permalink":"https://easyremember.cn/2020/08/01/随想/Vue子路由常见的问题/","excerpt":"","text":"Vue子路由常见的问题之前在进行开发的时候遇到了一个很玄学的问题，有一个页面需要设置二级路由，在设置二级路由之后浏览器却出现了报错 路由设置如下 报错信息 在查阅了相关资料之后找到了一种解决办法，component改为conponents 虽然没搞明白原理，先试试再说，浏览器正常不报错，但是！！！ 组件也没加载出来，TnT，这啥啊，治标不治本 然后我发现了这个 由于vue-router版本升级的原因需要手动添加.default来加载组件 原因如下 还有种方法 { path: &#39;back&#39;, name: &#39;back&#39;, component: resolve =&gt; require([&#39;@/components/Admin/Back&#39;], resolve), } 我试了下，我试了下这种方式也没问题，resolve是require的回调 还找到了一种说法 require 是 CommonJS 的模块导入方式，而组件定义时写的 export default 是 ES6 方式，因此require 导入的结果其实是一个含 default 属性的对象，所以 vue 中 component 用这个会报错，而恰好 vue 的命名视图组件注册用 components ，而官方也说了“如果 router-view 没有设置名字，那么默认为 default”，所以这两个default 正好对应起来，于是像楼主所说加了s就不会报错了。而合理的用法应该是 require(‘xxx.vue’).default 或是用 import","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"Vue刷新页面","slug":"随想/Vue页面刷新方法","date":"2020-07-31T14:14:47.733Z","updated":"2020-09-17T02:37:27.184Z","comments":true,"path":"2020/07/31/随想/Vue页面刷新方法/","link":"","permalink":"https://easyremember.cn/2020/07/31/随想/Vue页面刷新方法/","excerpt":"","text":"Vue页面刷新方法在编写提交表单的时候，当表单提交上之后清空当前表单 开始的时候我想的是表单提交成功之后data中表单中有关表单内容的变量重新赋空值，但是这样太过麻烦 偶然间在一篇博客中发现可以通过路由跳转当前路由来清空页面 然后就想着搜集一下有没有其他方法，搜集之后总结在这里了 路由跳转this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.go(0) }) 通过this.$router.go(0)来刷新页面 location.reload()也可以实现刷新页面 但是这样或有一个空白的过程 通过空白组件刷新将上传成功之后的回调修改 this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.replace({ path: &#39;/admin/back&#39;, name: &#39;back&#39; }) }) 然后创建一个新的空白组件back.vue，script部分如下 // 用于刷新页面，没有实际意义 export default { name: &quot;Back&quot;, data() { this.$router.replace({ path: &#39;/admin/uploadProblem&#39;, name: &#39;UploadProblem&#39; }) return { } } } 效果如下，网上说会有路由的改变过程，我没有发现。。。 provide / inject 组合先修改一下app.vue，通过provide传递reload方法在router-view标签中添加v-if判断v-if=&quot;isRouterAlive&quot; export default { provide() { return { reload: this.reload } }, name: &quot;app&quot;, data() { return { isRouterAlive: true } }, methods: { reload() { this.isRouterAlive = false this.$nextTick(function() { this.isRouterAlive = true }) } } } 在需要重新加载的页面通过 inject: [&#39;reload&#39;],接收方法（网上叫它‘注入依赖’），然后就可以在方法中调用 this.reload()","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"Vue点击切换导航栏样式","slug":"随想/Vue点击切换导航栏样式","date":"2020-07-31T06:09:30.441Z","updated":"2020-09-05T09:39:17.031Z","comments":true,"path":"2020/07/31/随想/Vue点击切换导航栏样式/","link":"","permalink":"https://easyremember.cn/2020/07/31/随想/Vue点击切换导航栏样式/","excerpt":"","text":"Vue点击切换导航栏样式导航栏内容如下 &lt;div class=&quot;collapse&quot;&gt; &lt;div class=&quot;links&quot;&gt; &lt;router-link v-for=&quot;link in linkLists&quot; :to=&quot;link.links&quot; :key=&quot;link.id&quot; exact&gt;{{link.show}} &lt;/router-link&gt; &lt;/div&gt; 效果如图 感觉太过简单，就想着加一个激活效果，开始想了很多种方法，但是都存着一定的缺陷，偶然间发现了router-link-active这个东西 可以给激活的router-link添加样式，尝试了一下 在links里面添加样式（使用的less预编译） .links { display: flex; margin-right: auto; a { color: #777; margin: 0 10px; } a:hover { color: #409eff; } .router-link-active { color: #409eff; } } 开始我以为完事了，但是却发现无论怎么切换首页一直处于激活状态，我开始面向百度解决问题 然后我发现了exact exact 是一个单独的属性 正确用法是 &lt;router-link to=&quot;/home&quot; active-class=&quot;bianlan&quot; exact&gt;。 这样，只有当路径刚好是 /home 时才会添加 bianlan 类名，而当路径是 /home/something 时则不会（因为不 exact） 在router-link标签中添加exact属性之后效果完美","categories":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://easyremember.cn/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://easyremember.cn/categories/随想/"}]},{"title":"JS递归、闭包、作用域链","slug":"技术/JS递归、闭包、作用域链","date":"2020-07-31T04:14:58.555Z","updated":"2020-09-05T09:37:36.669Z","comments":true,"path":"2020/07/31/技术/JS递归、闭包、作用域链/","link":"","permalink":"https://easyremember.cn/2020/07/31/技术/JS递归、闭包、作用域链/","excerpt":"","text":"JS递归、闭包、作用域链递归常规的递归函数function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } } console.log(func(4)); // 24 这是一个非常常见的递归函数，但是有一种情况会使得此方法出现错误。 var func2 = func; func = null; console.log(func2(4)); 将递归函数赋值给一个变量，然后把原函数赋值为null，这时候再调用就会报错 这是因为function属于引用类型，赋值时通过指针指向原函数，原函数发生改变，调用时就会出错 使用callee在上面的情况下，使用arguments.callee就可以解决，arguments.callee是一个指向正在执行函数的指针，将经典递归做以下改动 function func(number) { if (number &lt;= 1) { return 1; } else { return number * arguments.callee(number - 1); } } console.log(func(4)); //24 使用指针进行递归，无论怎么调用函数都不会出错，但是，在严格模式下使用arguments.callee会报错 命名函数表达式以上两种方法都存在这不同程度的缺陷，使用命名函数表达式可以达到指针的效果，亦可以同时运行在严格模式和非严格模式下 var func2 = (function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } }); var func3 = func2; func2 = null; console.log(func3(4)); 这时依旧可以正常显示结果 闭包 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 上面的递归最后一种方法就可以理解为一个闭包 闭包与变量经典的示例 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function () { return i; } } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } // 10,10,10,10,10,10,10,10,10,10 乍一看好像是for循环中每次循环将0-9赋值给数组的每一项，其实并不是，因为当前的newArray()正在执行，每个函数作用域链都保存着newArray()的活动对象，所以for循环中每次都是引用的同一个变量i，for循环结束之后，i是10，所以每个函数内部的i都是10。 再将返回i的函数包在一个匿名函数中，就可以达到互不影响的效果 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function (num: number) { return function () { return num; }; }(i) } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } 结果如下 在for循环中,自调用函数立即执行,获取实时地i赋值给num. 循环结束之后,返回result，在自调用函数执行之后，他的作用域就被销毁了，不会再被其他操作影响 this对象// 非严格模式 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return function () { return this.arg; }; } }; console.log(object.getArg()()); //window 为什么结果会是window呢，来看一下最后一行 // object.getArg()()相当于 var val = object.getArg(); val(); 把getArg返回的方法赋值给了val变量，然后执行函数。因为val在全局中，所以获得的arg是全局中的arg还有一种情况会出现问题 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return this.arg; } }; object.getArg() // object object.getArg() // object (object.getArg = object.getArg)() // window 第一种方法简单的调用了object的方法；第二种方法引用了object的方法，this对象能够维持；但是第三种是一个赋值语句，赋值语句是有返回值的，也就是等号右边，所以这里引用了方法，但不是object内部而是指向window 从这张图就可以看出赋值语句其实是有返回值的 解决方法 1 传递this指向var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { var _this = this; return function () { return _this.arg; }; } }; console.log(object.getArg()()); 将object的this传递到getArg之内，然后使用这个引用值获取arg 2 箭头函数也就是lambda表达式 var arg: string = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return () =&gt; { return this.arg } } } console.log(object.getArg()()); 箭头函数的一大特点就是不改变this的指向 内存泄漏闭包的缺陷在于会造成内存泄露，当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，比如通过node结点给html元素添加点击事件的时候，当事件添加完之后，存储node结点的变量会一直占用内存，造成内存泄漏 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; 存储divNode的内存将会无法释放也无法使用，怎么解决呢 在添加完事件之后将divNode手动赋值为空 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; divNode = null; 作用域链作用域 作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。 全局作用域一般全局作用域有以下几种情况 最外层函数和最外层函数外面定义的变量拥有全局作用域 所有未直接定义的变量 所有window对象 函数作用域声明在函数内部的变量，函数作用域一般只有代码片段中可以访问，比如函数内部 例如 function func1(a) { var b = a * 2; function func2(c) { console.log(a, b, c); } func2(b * 2); } func1(2) 这段代码中存在3个作用域 全局作用域，标识符func1 作用域func1，标识符a，b，func2 作用域func2，标识符c 作用域链 由多级作用域连续引用形成的链式结果，掌管一切变量的使用顺序： 先在局部找，没有，就延作用域向父级作用域找。 可以向上搜索，但不可以向下搜索 这种一层一层的关系，就是 作用域链 。","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Express+MySQL实现增删查改","slug":"技术/Express+MySQL实现增删查改","date":"2020-07-28T13:56:38.115Z","updated":"2020-09-05T09:37:26.108Z","comments":true,"path":"2020/07/28/技术/Express+MySQL实现增删查改/","link":"","permalink":"https://easyremember.cn/2020/07/28/技术/Express+MySQL实现增删查改/","excerpt":"","text":"Express+MySQL实现增删查改现在Node后台开发在网上找到的资料基本都是用的MongoDB数据库，不太容易找到使用MySQL数据库的资料，所以我整理了一下这篇文章，将会讲解如何使用Express和MySQL来实现CRUD 环境搭建生成器可以直接使用Express生成器自动生成Express工程 $ npm install -g express-generator $ express --view=ejs myapp 手动搭建创建一个项目目录$ npm init 新建app.js入口文件 新建router.js路由文件 创建views文件夹，存放EJS模板文件（student.ejs, editStu.ejs） 新建public公共资源 views文件夹命名不可以是别的，会报错 安装第三方模块$ npm install express --save $ npm install mysql --save $ npm install ejs --save 编写代码编写入口文件实例化、模板引擎设置、静态资源、监听 const express = require(&#39;express&#39;); const app = express(); const stuRoute = require(&#39;/router&#39;) // 设置模板引擎 app.set(&quot;view engine&quot;, &quot;ejs&quot;); // 加载静态资源 app.use(express.static(&#39;public&#39;)); // 使用路由 app.use(stuRoute); // 监听 app.listen(3001, () =&gt; { console.log(&#39;启动成功&#39;); }) 编写路由文件const express = require(&#39;express&#39;); const route = express.Router(); const mysql = require(&#39;mysql&#39;); // 配置数据库,连接池模式 var pool = mysql.createPool({ connectionLimit: 10, // 连接数量 host: &#39;localhost&#39;, // 地址 user: &#39;liuhao&#39;, // 数据库用户名 password: &#39;123456&#39;, // 数据可密码 database: &#39;ssmbuild&#39; // 数据库名 }); route.get(&#39;/student&#39;, (req, res) =&gt; { console.log(&quot;/student:&quot;, req.query); const sql = &#39;select * from books where bookName = ?&#39;; let params = [&#39;java&#39;]; // 根据条件查询信息 pool.getConnection(function (err, connection) { if (err) throw err; // not connected! connection.query(sql, params, function (error, results, fields) { connection.release(); console.log(results); // 将数据传到ejs渲染 res.render(&#39;student&#39;, { res: [] }) if (error) throw error; }); }); }) module.exports = route; 效果展示查询结果 数据库数据 这里可以看到数据已经查询成功 本篇主要讲解mysql模块使用，对数据渲染不再赘述另外修改删除修改一下sql语句和params参数即可，开发时数据库部分一般会单独作为一个模块进行封装 现在大部分开发一般是返回json数据，后期会再进行记录","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"express","slug":"express","permalink":"https://easyremember.cn/tags/express/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"思途实训day5","slug":"生活/STDay 5","date":"2020-07-26T13:40:01.320Z","updated":"2020-09-05T09:36:44.780Z","comments":true,"path":"2020/07/26/生活/STDay 5/","link":"","permalink":"https://easyremember.cn/2020/07/26/生活/STDay 5/","excerpt":"","text":"Day 5引入js尽量放在body标签的最后，先加载静态标签，再加载js脚本 jQuery表达式必须有分号 jQuery改变元素样式(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); })() click事件$(function () { $(&#39;button&#39;).click(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); }); }); 导航栏颜色修改 &lt;ul id=&quot;nav-ul&quot; onclick=&quot;navHandle()&quot;&gt; &lt;li id=&quot;li1&quot;&gt;首页&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;所有宝贝&lt;/li&gt; &lt;li id=&quot;li3&quot;&gt;每周一上新&lt;/li&gt; &lt;li id=&quot;li4&quot;&gt;生活馆&lt;/li&gt; &lt;li id=&quot;li5&quot;&gt;特惠&lt;/li&gt; &lt;li id=&quot;li6&quot;&gt;礼品区&lt;/li&gt; &lt;/ul&gt; function navHandle() { var nodeId = window.event.target.id; // console.log(node); $(&#39;#&#39; + nodeId).css({ &#39;color&#39;: &#39;#d62cc0&#39; }).siblings().css({ &#39;color&#39;: &#39;#ffffff&#39; }); } siblings()方法返回被选中元素的同级元素 鼠标经过和移出$(function() { $(&#39;#mouse&#39;).mouseenter(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;red&#39; }); }); }); $(function() { $(&#39;#mouse&#39;).mouseleave(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;#409eff&#39; }); }); }); 淡入淡出效果$(function() { $(&#39;.b-f-1&#39;).mouseenter(() =&gt; { $(&#39;#black1&#39;).fadeOut(500); }); }); $(function() { $(&#39;.b-f-1&#39;).mouseleave(() =&gt; { $(&#39;#black1&#39;).fadeIn(300); }); }); 滑动效果slideDown、slideUp $(function() { $(&#39;div&#39;).mouseenter(() =&gt; { $(&#39;div&#39;).slideDown(1000); }); }); $(function() { $(&#39;div&#39;).mouseleave(() =&gt; { $(&#39;div&#39;).slideUp(1000); }); }); 总结今天大概复习了一下jQuery，很多东西都忘了，需要再看一下","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"思途实训day4","slug":"生活/STDay 4","date":"2020-07-24T11:29:57.687Z","updated":"2020-09-05T09:36:44.729Z","comments":true,"path":"2020/07/24/生活/STDay 4/","link":"","permalink":"https://easyremember.cn/2020/07/24/生活/STDay 4/","excerpt":"","text":"Day4旋转+透明度div { width: 150px; height: 150px; border-radius: 50%; overflow: hidden; border: solid 3px #409eff; transition: 0.5s; opacity: 0.5; } div:hover { transform: rotate(200deg); opacity: 1; } 今日收获。。。就是个透明opacity 成果","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"思途实训day3","slug":"生活/STDay 3","date":"2020-07-24T01:17:51.174Z","updated":"2020-09-05T09:36:44.676Z","comments":true,"path":"2020/07/24/生活/STDay 3/","link":"","permalink":"https://easyremember.cn/2020/07/24/生活/STDay 3/","excerpt":"","text":"Day 3HTML标签。。。从0开始的那种。。。 css样式通配符选择器* { margin: 0; list-style: none; /* 去掉list圆点 */ text-decoration: none; /* 去掉下划线 */ } 列表右浮动只给父级不给子级背景图片引入背景图片必须设置高度，否则不显示 .binner { /* no-repeat不平铺 */ background: url(../img/TB183NQapLM8KJjSZFBSutJHVXa.jpg) no-repeat; height: 568px; background-size: 100% auto; /* 图片自适应 */ } 行高等于div高度时自动居中.nav-f { width: 660px; height: 120px; position: absolute; left: 168px; line-height: 120px; } 精灵图使用Photoshop信息面板配合精灵图设置图片 比如这张精灵图 .shopping { width: 30px; height: 30px; background: url(../img/icon.png); background-position: -16px -133px; } 引入图片之后将鼠标移至图标左上角，看到位置是X：16，Y：133，将图片位置设置为-16px,-133px，将图片沿着X轴Y轴移动之后，浏览器会自动根据设置的宽高从起点位置裁切","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"JS异步轮询","slug":"技术/异步轮询","date":"2020-07-23T05:50:43.924Z","updated":"2020-12-06T10:35:39.054Z","comments":true,"path":"2020/07/23/技术/异步轮询/","link":"","permalink":"https://easyremember.cn/2020/07/23/技术/异步轮询/","excerpt":"","text":"异步轮询异步先来看一个例子 console.log(&#39;start&#39;) setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;) }, 4000) console.log(&#39;end&#39;) 这段代码的执行顺序是什么，你可能想到的结果是 start setTimeout end 但是，js是单线程的，不会因为一个任务而被阻塞，异步操作将会被放到队列中，等主线程执行完第一轮任务，然后再执行队列中的任务 这里稍微扯一下栈和队列 栈（stack） 栈是一种先进后出的数据结构，可以理解为一个桶，先放进的东西在最低下，后放的东西在最外面，外面的取完了之后才能拿出最先放进去的东西； 队列（queue） 队列是一种先进先出的数据结构，可以看做一个管道，先进的先出，后进的后出 回到正题，上面的例子中setTimeout是一个异步操作，被放到了队列中，当主线程执行完成之后再来执行队列中的任务，所以答案应该是 在js的队列中有两种划分，一种是宏任务（macrotask queue），一种是微任务（microtask queue），每一个事件循环（Event Loop）都有一个微任务，会有一个或多个宏任务，每一次事件循环都会首先执行微任务执行完后从宏任务取出一个加入到微任务然后执行，直至队列中所有的任务执行结束 宏任务 script(整体代码) setTimeout setInterval I/O UI交互事件 postMessage MessageChannel setImmediate(Node.js 环境) 微任务 Promise.then Object.observe MutaionObserver process.nextTick(Node.js 环境) Promise异步原理看完了，下面开始Promise let promise = new Promise((resolve, reject) =&gt; { // resolve(&quot;成功&quot;) // reject(&quot;失败&quot;) }) console.log(promise) 先来看一下Promise对象的结构 当没有任何操作的时候，Promise对象的状态时pending，值是undefinded 当在Promise中调用resolve之后，状态变为fulfilled，意思是成功 当调用reject的时候，状态变为rejected，意思是失败 Promise的状态是不可逆的，resolve和reject同时出现，先执行的决定状态，后执行的不生效 下面这三种方法可以触发Promise.then的错误方法 throw new Error(‘fail’) reject(‘fail’) 错误操作（默认，类似try/catch） 链式调用console.log(&#39;start&#39;) let promise = new Promise((resolve, reject) =&gt; { console.log(&#39;promise&#39;) resolve(&quot;success&quot;) // reject(&quot;faild&quot;) }).then(value =&gt; { console.log(value+1) return value }, reason =&gt; { console.log(reason) }).then(value =&gt; { console.log(value+2) }, reason =&gt; { console.log(reason) }) console.log(&#39;end&#39;) 打印结果为 Promise会将返回值作为.then()的参数传递下去，而且两个.then是在主线程执行完成之后才执行的，这里被放到了微任务（不是并列的，当执行第一个.then的时候第二个.then才会被放到微任务），如果不调用resolve或者reject，微任务是不创建的 每一个Promise.then也是一个Promise 状态中转let promiseErr = new Promise((resolve, reject) =&gt; { reject(&#39;faild&#39;) }) let promise = new Promise((resolve, reject) =&gt; { resolve(promiseErr) }).then(value =&gt; { console.log(&#39;value:&#39;+value) }, reason =&gt; { console.log(&#39;err:&#39;+reason); }) 这里promise虽然调用了resolve，但是返回的状态却是promiseErr的，所以他的结果是 .then是对它前一个Promise对象的操作 错误捕获这样每一个then都有两个方法，过于繁琐，可以在then中只写成功方法，在最后使用catch方法捕获错误 let promise = new Promise((resolve, reject) =&gt; { resolve() }).then(v =&gt; { console.log(&#39;p1&#39;) throw new Error(&#39;fail&#39;) }).then(v =&gt; { console.log(&#39;p2&#39;) }).catch(err =&gt; { console.log(err) }).then(v =&gt; { console.log(&#39;p3&#39;) }).then(v =&gt; { console.log(&#39;p4&#39;) }) 结果为 有结果可以看出，发生错误的地方到catch之间的代码不会执行，catch返回值也是一个Promise对象 async/await了解了Promise之后，async/await就很容易了，它其实就是Promise的语法糖 async function asyncFunc() { return &quot;asunc&quot; } let result = asyncFunc() console.log(result); 从结果看出，async方法返回的也是一个Promise对象 来看看下面这个例子 function p() { console.log(&#39;p&#39;) } async function func() { await p(); console.log(&#39;OK&#39;) } console.log(&#39;start&#39;) func() console.log(&#39;end&#39;) // start // p // end // OK 用知乎上看到过一个例子来解释，可以将 async function func() { await p(); console.log(&#39;OK&#39;) } 理解为 function func() { return Promise.resolve(p()).then(() =&gt; { console.log(&#39;OK&#39;) }) } console.log(‘OK’)被分配到微任务中等待下一轮轮询 来看一个综合案例 async function async1() { console.log(&#39;async1 start&#39;) await async2() console.log(&#39;async1 end&#39;) } async function async2() { console.log(&#39;async2&#39;) } console.log(&#39;script start&#39;) setTimeout(function () { console.log(&#39;settimeout&#39;) }) async1() new Promise(function (resolve) { console.log(&#39;promise1&#39;) resolve() }).then(function () { console.log(&#39;promise2&#39;) }) console.log(&#39;script end&#39;) 输出结果是 script start async1 start async2 promise1 script end async1 end promise2 settimeout 你做对了么(๑´ㅂ`๑)","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"JS中的闭包","slug":"技术/闭包","date":"2020-07-23T05:28:46.515Z","updated":"2020-09-05T09:34:48.925Z","comments":true,"path":"2020/07/23/技术/闭包/","link":"","permalink":"https://easyremember.cn/2020/07/23/技术/闭包/","excerpt":"","text":"​ 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 相信你看了这段鬼话，80%会感到懵逼，看完下面的内容再回来看这句话，相信你就可以理解了。 函数的作用域 在全局环境中定义了title变量和show方法，当执行show方法时，开辟出一块内存，如果在show方法内部调用context是可以正常执行的，当show执行完的时候，show中定义的context变量不被保留，这时外部调用context就会 not defined。 数据的作用默认就是在函数体内 数据向下流动，只会向子级传递，不会向父级传递 当show方法执行完之后，内存被释放，执行多个show方法相当于多次开辟了内存 如果在show方法中再定义一个head方法，再执行，此时的内存结构如图所示，head方法时show方法内部的，show执行时为head开辟一块内存；那多次调用show方法会一直调用那一个head方法么？不是的！！！多次调用show方法会开辟多块内存，他们之间是没有关系的。 这个例子更能清楚的说明，按照常理，第一次调用++n之后变成了2，但是这里第二次调用结果还是2，这就说明了两次调用创建了两次 那么怎么让n一直被使用呢，这时你应该想起来开头有一句话 但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 当数据一直被使用时就会保留下来，那么怎么让他一直被使用呢？ 将sum方法作为返回值赋值给a，这时候，feng中的数据就会一直被使用，直到a销毁，这时候多次调用a方法，n就会累加 如果再赋值给b，这就又开辟了一块内存，与a无关n又重新开始计算，结果如下： 这时候你又想起了开头还有一句话： 每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址 如果在sum中在添加一个function，这样再执行两次a结果是什么呢？ 你没有看错，其实很简单，这跟之前一样，相当于在a中开辟了两块不相关的内存，那么怎么让m累加呢？也很简单，再把show返回出去 这时再创建b，打印结果依旧是2 3 2 3 利用闭包选择数组区间 由于过滤函数一直在调用between的子函数，所以a，b也被保留了下来 闭包会造成内存泄漏 这段代码的意思是点击div会触发打印descript属性，因为事件处理函数是一直存在的，所以每个item在使用完成之后都会保存，而且都是不同的内存区域，对于复杂对象来说是非常浪费内存的 那么怎么解决闭包带来的内存泄漏呢 在使用完之后给item项赋空值 这样就可以解决不必要的内存浪费","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"思途实训day2","slug":"生活/STDay 2","date":"2020-07-22T08:57:04.870Z","updated":"2020-09-05T09:36:44.564Z","comments":true,"path":"2020/07/22/生活/STDay 2/","link":"","permalink":"https://easyremember.cn/2020/07/22/生活/STDay 2/","excerpt":"","text":"Day 2字体选择： 中文：微软雅黑， 宋体，黑体 英文：arial 字体大小： 网页最小字号：12px， 不重要信息 一般用的最小字号：14px 精确抠图解锁原背景，新建图层填充鲜艳的颜色，例如绿色 用魔棒工具选择背景色，调整容差值，右键选择【调整边缘】 调整参数 菱形方格 制作一个这样的菱形方格 用矩形工具选择一个矩形框填充一个颜色，【ctrl】+【T】自由变换，按住shift旋90度 在图层调节描边，内阴影和投影 就可以看到效果图中的样式 图层蒙版将要贴入的图片拖拽至目标图层上方 注意在图层区域要将两图层放在一起 左上角有自动选择，点一下就可以定位图层 在两图层之间按住【alt】+鼠标左键 图层区会变成 显示的样式就会变成 图标绘制 锚点工具使用 首先利用椭圆工具绘制黄色圆形，然后复制两份 利用圆角矩形工具绘制蓝色矩形，绘制完成之后按【A】键选中元素出现锚点，按住【ctrl】用鼠标拖拽锚点成为一个梯形 在梯形内绘制三个圆角矩形，填充背景色构造成镂空的感觉 绘制底座，使用圆角矩形，使用锚点工具选择右上角两个点，【delete】，然后将描边改为白色 使用钢笔工具绘制上面的把手，钢笔工具点击一个点，再点第二个点不要松手，调整弧度至合理，使用上面底座相同的配置即可 钢笔工具在使用的时候如果出现角度很别扭的时候，可以在上一个点调好之后不松手，按住【alt】鼠标移动调节手柄 切图将所有的背景色全部隐藏，用切片工具画出切片区域，存储为web格式","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"思途实训day1","slug":"生活/STDay 1","date":"2020-07-22T07:27:01.446Z","updated":"2020-09-05T09:36:44.408Z","comments":true,"path":"2020/07/22/生活/STDay 1/","link":"","permalink":"https://easyremember.cn/2020/07/22/生活/STDay 1/","excerpt":"","text":"Day 1PhotoShop操作快捷键 图层复制：【Ctrl】+【J】 自由变换：【Ctrl】+【T】 画笔工具：【B】，画笔调节：粗——右中括号，细——左中括号 放大：【ctrl】+【space】，缩小：【ctrl】+【alt】+【space】，抓手：【space】 盖印：【ctrl】+【alt】+【shift】+【e】 首选项：【ctrl】+【k】 填充前景色：【alt】+【delete】，填充背景色：【ctrl】+【delete】 移动工具：【v】 编组：【ctrl】+【g】 制作大头像调节图层素材图片 1 复制一个图层（可使用ctrl+j，也可以拖拽图层到下方的新建图层图标） 2 ctrl+t自由变换图层，缩放到合适的比例（按住shift等比缩放） 3 调节新图层透明度，50%-60%合适 4 将两图层下巴对齐 5 在小图层上新建蒙版 6 用黑色画笔将大图层头部涂黑，涂完之后将不透明度调至100%，如果有多余部分使用白色画笔涂回去（硬度调为0） 7 使用裁切工具只保留需要的部分，盖印生成图层 成果图如下 图层修饰 滤镜中点开液化 使用膨胀工具在两眼位置分别点击两下将眼部放大 使用褶皱工具将鼻子和嘴缩小 使用左推工具将脸收一下 如果拖坏了可以使用重建工具将要恢复的地方涂一下 GIF制作窗口打开时间轴，新建帧动画 在图层中控制要显示的帧然后添加关键帧 调节每一帧的时间 导出：存储为web格式，调节为GIF格式 网页设计项目立项——分析市场环境——解决用户痛点 仿照图 自己做的设计图： 渐变色：在选区内添加渐变图层，否则会使整个背景全部渐变 选择多个图层：选中第一个图层，按住shift选中最后一个图层 要选中某一图层的某一部分：先用多边形框选工具选出大致部分，然后ctrl+alt+shift+点击要选中部分的图层","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://easyremember.cn/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]},{"title":"Typora图片自动上传到图床","slug":"资源/Typora图片自动上传到图床","date":"2020-07-15T11:50:22.787Z","updated":"2020-09-05T09:40:22.479Z","comments":true,"path":"2020/07/15/资源/Typora图片自动上传到图床/","link":"","permalink":"https://easyremember.cn/2020/07/15/资源/Typora图片自动上传到图床/","excerpt":"","text":"Typora图片自动上传到图床你是否还在为找不到可靠的图床而烦恼 是否害怕图床网站关闭资源丢失 是否担心资源不能管理而发愁 今天他来了 1 下载安装picGo地址在这里，根据需要的版本进行下载 下载完成后进行安装 安装完之后在桌面右下角图标打开picGo详细界面 2 配置picGo图床+giteepicGo支持多个图床 这里主要说一下gitee新建一个公开的仓库，私有的在相册和Typora无法显示 搜索插件gitee（需要安装Node环境） 据说是两个都可以，我只试过了gitee，安装好之后在上面的图床列表里就会出现gitee图床 这里是配置信息 owner：gitee用户名 repo：gitee仓库名 path：路径，存放到根目录可以不用写 token：gitee个人令牌 message：可以不写 关于gitee个人令牌的获取 点开gitee的设置，在左侧栏找到私人令牌，然后点击生成新令牌 描述可以随便写一下，然后点击确认会生成一个token 将token复制到picGo中就可以了 3 配置Typora+picGo在Typora的偏好设置中将插入图片改为上传图片，上传服务修改为picGo App，并选择到安装目录 点击验证 如果出现false情况，看一下连接中的端口号，然后到picGo的设置中找到Server服务 将端口号修改一致 然后保存，再试一下验证","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"ES6笔记","slug":"笔记/ES6笔记","date":"2020-07-15T07:24:55.780Z","updated":"2020-09-05T09:36:10.203Z","comments":true,"path":"2020/07/15/笔记/ES6笔记/","link":"","permalink":"https://easyremember.cn/2020/07/15/笔记/ES6笔记/","excerpt":"","text":"ES6笔记变量let和constvar存在的问题 可以重复声明 无法限制修改 没有块级作用域 ES6新的定义变量 let 不能重复声明 变量，可以修改 块级作用域 const 不能重复声明 常量，不能修改 块级作用域 最大的区别：const一经定义值不能再变 函数箭头函数let show = function(n1,n2) { return n1-n2; } ----------等价-------------- let show = (n1, n2) =&gt; { return n1-n2; } 如果只有一个参数，()可以省略 let show = (n) =&gt; { return n; } --------省略-------- let show = n =&gt; { return n; } 如果只有一个return，{}可以省略 let show = n =&gt; { return 2*n; } -------省略-------- let show = n =&gt; 2*n; 箭头函数的this不会变：this指向的是当前对象，传统的function需要定义一个const that= this才能在里面的函数访问到最外层的this，箭头函数不会改变this指向，也就是说，无需定义that就可以用this访问原来的对象 箭头函数的优势和劣势 参数...args接收参数 命名随意，但必须放到参数最后，用于收集剩余参数 let show = function (a, b, ...args) { alert(a); alert(b); alert(args); } show(14,2,3,4,5); 多余的参数将会由args接收 展开数组 展开后效果跟直接把数组放在那一样 let arr = [1,2,3,4]; show(...arr);// == show(1,2,3,4) ------------------- let arr1=[1,2,3]; let arr2=[4,5,6]; let arr=[...arr1,...arr2]; // == let arr=[1,2,3,4,5,6]; 默认参数let show = function (a, b=5, c=10) { XXX } show(12); 当传的参数只有一个的时候，b默认是5，c默认是10； 当传参数大于一位时，会依次顶替默认参数 解构赋值左右两边结构必须一样 let [a, b, c] = [1,2,3] let {a,b,c} = {a:1,b:2,c:3} 右边必须合法 声明和赋值不能分开 let [a, b] = [5, 12];// 合法 ------------------------ let [a, b]; [a, b] = [5, 12];// 报错，解构赋值声明和赋值不能分开 数组map映射————一个对一个 let arr = [1, 2, 3, 4]; let result = arr.map(item =&gt; item * 2); // result 2,4,6,8 reduce汇总————一堆出来一个 let arr= [12, 8, 9, 16]; let result = arr.reduce( function (tmp, item, index) { return tmp + item; }) function中的三个参数分别是存储的和的中间数、要计算的数、索引 filter过滤器————保留一部分 let arr = [10,3,16,15,21,20]; let result = arr.filter(item =&gt; { if(item % 3 == 0) { return true; } return false; }); alert(result); -------------------------------- // json类型 let arr = [ {name: &#39;tom&#39;, price: 75}, {name: &#39;jerry&#39;, price: 60} ]; let result = arr.filter(item =&gt; { return item.price&gt;65; }); console.log(result); 当filter中的方法返回true的时候数据保留，返回false数据删除 forEach循环（迭代）————每一项进行操作 吧数组中的每一项都放到方法中执行 字符串两个新方法startsWith 匹配前面的字符串，相同返回true，不相同返回false endWith 匹配末尾的字符串，相同返回true，不相同返回false 应用：检测文件后缀 字符串模板字符串拼接 let a = &#39;AScri&#39;; let str = `ECM${a}pt6`; alert(str); // str=ECMAScript6 注意：插入字符串的字符串要用反单引号（数字键盘1左边的那个） 应用，拼接字符串 let html = `&lt;div&gt; &lt;h1&gt;${title}&lt;/h1&gt; &lt;p&gt;${content}&lt;/p&gt; &lt;/div&gt;`; 优势：直接把字符串插到字符串中；可以折行 面向对象语法class User { constructor(name, age) { this.name = name; this.age = age; } showName() { alert(this.name); } showAge() { alert(this.age); } } var user = new User(&#39;Tom&#39;, 18); user.showName(); user.showAge(); 对象创建关键字class，相当于java的类 构造器关键字constructor，相当java的构造函数 方法直接写在class里面，不需要加function 继承class VipUser extends User { constructor(name, age, level) { super(name, age); this.level = level; } showLevel() { alert(this.level); } } var vip = new VipUser(&#39;Tom&#39;, 18, 3); vip.showName(); vip.showAge(); vip.showLevel(); 继承关键字extens，相当于java的继承 构造函数中使用super关键字，调用父类的构造函数 添加新的属性和新的方法 JSON标准写法 只能用双引号 所有名字都必须用引号括起来 { &quot;a&quot;: &quot;abx&quot;, &quot;b&quot;: 12, &quot;c&quot;: true } 格式化为字符串let json = {a: 11, b: 12}; alert(JSON.stringify(json)); JSON.stringify()得到的结果是一个字符串 格式化为JSONlet str = &#39;{&quot;a&quot;: 11, &quot;b&quot;: 12}&#39;; console.log(JSON.parse(str)); JSON.parse()得到的结果是一个json对象，但是，字符串的内容必须符合json格式标准，另外，双引号的外面是单引号 简写属性名简写 let a = 12; let b = 5; let json = {a, b, c: 15}; console.log(json); 当已经存在的值和json属性名一样的时候，可以只写值，不一样的可以按照json格式添加 这里的json指的是json字面量 方法简写 let json = { a: 12, show() { console.log(this.a); } } json.show(); 方法可以只写方法名，省略 function Promise作用：消除异步操作，用同步的方式来写异步代码 异步：操作之间没啥关系，同时进行多个操作；代码复杂 同步：同时只能做一件事，前面的事没干完后面的事不能开始；代码简单 封装ajax（基于jquery） let ajax = new Promise(function (resolve, reject) { $.ajax({ url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); ajax.then(result =&gt; { alert(result); }, err =&gt; { console.log(err); }) Promise.all()当有两个Promise对象时，可以使用Promisr.all()处理两个Promise对象 Promise.all([ ajax1, ajax2 ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 这里注意，当使用.all处理多个Promise对象时，有一个出错就会报错，全部成功才会执行成功的回调函数 有多个ajax请求不同地址的时候可以，再次封装 function createPromise(url) { return new Promise(function(resolve, reject) { $.ajax({ url, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); } Promise.all([ createPromise(&#39;js/arr.txt&#39;), createPromise(&#39;js/arr2.txt&#39;) ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 以上只是示例，jquery的作者当然想到了这一点，$.ajax()是有返回值的（高版本，低版本可能没有） let p = $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}); 可以将 $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}) 放到Promise.all()里面，代替上面的createPromise方法 Promise.race()同时处理多个Promise对象，有一个先完成的就停止 应用场景，同时向多个负载发送请求 Promise链式调用let test = new Promise((resolve, reject) =&gt; { let random = Math.random() if (random &gt; 0.5) { resolve(&#39;大于0.5&#39;) } else { reject(&#39;小于等于0.5&#39;) } }) let p = test.then((result) =&gt; { console.log(result) return result }).catch((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(&#39;last&#39;, result) }) console.log(p) ------------------------- Promise { &lt;pending&gt; } // p 大于0.5 // 或者小于，下同 大于0.5 last 大于0.5 promise 的 then 方法里面可以继续返回一个新的 promise 对象 下一个 then 方法的参数是上一个 promise 对象的 resolve 参数 catch 方法的参数是其之前某个 promise 对象的 rejecte 参数 一旦某个 then 方法里面的 promise 状态改变为了 rejected，则promise 方法连会跳过后面的 then 直接执行 catch；如果状态一直为fulfilled，catch里面的的代码不执行 catch 方法里面依旧可以返回一个新的 promise 对象 promies的三种状态是未决的pending（进行中），和已决的fulfilled（成功）/rejected（失败），reslove和reject是成功和失败的参数，在promies里调用参数之后then方法才会执行 参考资料： 深入理解Promise三种状态与链式调用 Promise对象then方法链式调用 生成器函数generator 普通函数：一直执行到最后 generator函数：中间可以暂停 function *show() { alert(&#39;1&#39;); yield; alert(&#39;2&#39;); } let obj = show(); obj.next(); obj.next(); 直接运行show()并不会有任何反应，用show来创建一个对象，用next方法可以执行，遇到yield停下，再执行next可以继续运行之后的部分 原理是把一个大函数的代码切分成多个小函数，每next一次执行一次 一个生成器中可以存在多个yield；注意函数命名方式 function *show(){}，带有星号 yield可以传参 第一个next无法传参，可以理解为generator的启动器，第二个next开始向第一个yield传参 function *show() { alert(&#39;1&#39;); let a = yield; alert(a); } let obj = show(); obj.next(); obj.next(10); -------------------------- // 打印结果 a=10 有返回值 function *show() { alert(&#39;1&#39;); let a = yield &#39;axc&#39; + &#39;ac&#39;; alert(a); // 10 // 如果这里return 55，那么下边b1的value就是55 } let obj = show(); let a1 = obj.next(); console.log(a1); // {value: &quot;axcac&quot;, done: false} let b1 = obj.next(10); console.log(b1); // {value: undifind, done: true} 一个yield相当于一个被分解成小函数的return 总结：第一个yield返回的值给了第一个next，第二个next的参数给了第一个yield 附：ES7 async awaitasync function doSome() { try { let data1 = await function(data); let data2 = await function(data1); let data3 = await function(data2); } catch(err) { console.log(&quot;Error:&quot; + err); } } 用同步的方式实现异步 await的返回值是promise；await后面可以用Promise.all()执行多个Promise操作 awat 外面必须包裹着async， 把await和成功后的操作放到try里，失败的放在catch 参考资料： async和await","categories":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://easyremember.cn/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://easyremember.cn/categories/笔记/"}]},{"title":"VS Code 快捷键","slug":"资源/VS Code 快捷键","date":"2020-07-14T07:29:20.384Z","updated":"2020-09-05T09:40:22.620Z","comments":true,"path":"2020/07/14/资源/VS Code 快捷键/","link":"","permalink":"https://easyremember.cn/2020/07/14/资源/VS Code 快捷键/","excerpt":"","text":"VS Code 快捷键打开一个新窗口 Ctrl+Shift+N 关闭窗口 Ctrl+Shift+W 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 复制或剪切当前行/当前选中内容 Ctrl+C 、 Ctrl+V 代码格式化： Shift+Alt+F 上下移动一行 Alt+Up 或 Alt+Down 向上向下复制一行 Shift+Alt+Up 或 Shift+Alt+Down 在当前行下方插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 移动到行首 Home 移动到行尾 End 移动到文件结尾 Ctrl+End 移动到文件开头 Ctrl+Home 移动到定义处 F12 定义处缩略图 只看一眼而不跳转过去 Alt+F12 找到所有的引用 Shift+F12 同时修改本文件中所有匹配的 Ctrl+F12 重命名 比如要修改一个方法名，可以选中后按 F2，输入新名字，回车，则所有该方法的引用也都同步更新了 跳转到下一个 Error 或 Warning 当有多个错误时可以按 F8 逐个跳转 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F","categories":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://easyremember.cn/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://easyremember.cn/categories/技术/"}]},{"title":"Hello World","slug":"生活/hello-world","date":"2020-07-14T07:29:20.383Z","updated":"2020-09-05T09:36:29.977Z","comments":true,"path":"2020/07/14/生活/hello-world/","link":"","permalink":"https://easyremember.cn/2020/07/14/生活/hello-world/","excerpt":"","text":"2020-07-13 博客诞生","categories":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://easyremember.cn/tags/hello/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://easyremember.cn/categories/生活/"}]}]}