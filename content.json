{"meta":{"title":"前端小枫","subtitle":"","description":"","author":"小枫","url":"https://fengjing95.github.io"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"bangumi/index.html","permalink":"https://fengjing95.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-07-13T12:13:10.594Z","comments":true,"path":"comment/index.html","permalink":"https://fengjing95.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"about/index.html","permalink":"https://fengjing95.github.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"client/index.html","permalink":"https://fengjing95.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"donate/index.html","permalink":"https://fengjing95.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-07-13T12:13:10.595Z","comments":false,"path":"lab/index.html","permalink":"https://fengjing95.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-07-13T12:13:10.595Z","comments":true,"path":"links/index.html","permalink":"https://fengjing95.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-13T12:13:10.596Z","comments":false,"path":"music/index.html","permalink":"https://fengjing95.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"rss/index.html","permalink":"https://fengjing95.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"tags/index.html","permalink":"https://fengjing95.github.io/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"video/index.html","permalink":"https://fengjing95.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://fengjing95.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"Promise学习笔记","slug":"Promise","date":"2020-08-20T09:41:38.591Z","updated":"2020-08-20T09:55:12.820Z","comments":true,"path":"2020/08/20/Promise/","link":"","permalink":"https://fengjing95.github.io/2020/08/20/Promise/","excerpt":"","text":"Promise学习笔记参考视频教程 知识铺垫函数对象和实例对象 函数对象：将函数作为对象使用 实例对象：new 函数产生的对象(执行构造函数) 只有在new出实例对象之后，函数才能叫做构造函数 function Person() { } var p = new Person(); console.log(Person.prototype) 在这段代码中p是实例对象，Person是构造函数，打印Person原型时，Person是函数对象 回调函数 同步回调：立即执行，完全执行完了才结束，不会放入回调队列 异步回调：不会立即执行，放入回调队列中将来执行 const arr = [1, 2, 3]; arr.forEach(item =&gt; { console.log(item); }); console.log(&#39;foreach之后&#39;); setTimeout(() =&gt; { console.log(&#39;callback&#39;); }, 0); console.log(&#39;setTime之后&#39;); 上面一段是同步回调，按照顺序执行；下面一段是异步函数，放到队列中执行，主线程执行完毕之后才执行 错误处理 错误的类型 Error: 所有错误的父类型 ReferenceError: 引用的变量不存在 TypeError: 数据类型不正确的错误 RangeError: 数据值不在其所允许的范围内 SyntaxError: 语法错误 错误处理 捕获错误: try … catch 抛出错误: throw error 错误对象 message属性: 错误相关信息 stack属性: 函数调用栈记录信息 Promise理解和使用什么是Promise 抽象表达: Promise是JS中进行异步编程的新的解决方案(旧的是谁？纯回调callback) 具体表达: 从语法上来说: Promise是一个构造函数 从功能上来说: promise对象用来封装一个异步操作并可以获取其结果 promise的状态改变(只有2种结果,，只能改变一次) pending变为resolved pending变为rejected 无论成功还是失败都会有一个 结果，成功的称为value，失败的称为reason promise的基本流程(pending，图里面写错了) 为什么使用Promise 指定回调函数的方式更加灵活：可以在请求发出甚至结束后指定回调函数 支持链式调用，可以解决回调地狱问题 怎么使用Promise简单的示例 const p = new Promise((resolve, reject) =&gt; { const d = Date.now(); if (d % 2 === 1) { resolve(&#39;success&#39;) } else { reject(&#39;faild&#39;) } }) p.then(value =&gt; console.log(value), reason =&gt; console.log(reason)) .then()接收两个函数，第一个是成功的回调（onResolved），第二个是失败的回调（onRejected） 主要API Promise构造函数: Promise (excutor) {} Promise.prototype.then方法: (onResolved, onRejected) =&gt; {} Promise.prototype.catch方法: (onRejected) =&gt; {}，拦截失败操作，返回promise对象，如果catch之前有reject，直接跳到reject，中间所有的.then都不执行 Promise.resolve方法: (value) =&gt; {}，修改状态为成功 Promise.reject方法: (reason) =&gt; {}，修改状态为失败 Promise.all方法: (promises) =&gt; {}，参数为一个可迭代对象，等所有的promise对象都完成之后状态变为resolved，返回结果可迭代对象；如果过有失败结果，状态变为rejected，失败原因是第一个失败的promise对象的结果 Promise.race方法: (promises) =&gt; {}，参数为一个可迭代对象，如果有任何一个promise解决或者拒绝，返回的promise就会解决或者拒绝 存在的问题 改变状态不一定是resolve和reject，也可以发生错误或者抛出异常 同一个promise对象添加对个.then都会执行 改变promise状态和指定回调函数谁先谁后 正常情况下是先指定回调函数再改变状态 先改变状态再指定回调：①在执行器中直接调用resolve()/reject()②延迟更长时间才调用then() 什么时候得到数据 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据 不论成功失败，回调函数永远是异步执行 .then返回promise的状态——由指定的回调函数执行的结果决定 抛出异常，新的promise变为rejected，reason为跑出的异常 返回的是非promise任意值，状态改为resolved，value是返回值 返回值是一个新的promise，这个promise的结果就会成为新的promise的结果 自定义Promise整体结构由于ES6和CommenJS都需要编译才能使用，所以自定义Promise需要使用ES5模块语法（自调用函数） (function (window) { /* Promise：构造函数 excutor: 执行器 */ function Promise(excutor) { } /* Promise 原型对象.then 指定成功和失败的回调函数 返回一个新的Promise */ Promise.prototype.then = function (onResolved, onRejected) { } /* Promise 原型对象.catch 指定失败的回调函数 返回一个新的Promise */ Promise.prototype.catch = function (onRejected) { } /* Promise 原型对象.resolve 返回一个指定value的Promise */ Promise.resolve = function (value) { } /* Promise 原型对象.reject 返回一个指定reason的Promise */ Promise.reject = function (reason) { } /* Promise 原型对象.all 返回一个Promise，所有promise都成功才成功，一个失败就失败 */ Promise.all = function (promises) { } /* Promise 原型对象.race 返回一个Promise，由第一个完成的promise决定 */ Promise.race = function (promises) { } // 暴露Promise window.Promise = Promise; })(window) 构造函数/* Promise：构造函数 excutor: 执行器 */ function Promise(excutor) { this.status = &#39;pending&#39;; // 状态 this.data = undefined; // 数据 this.callbacks = []; // 保存回调函数，结构：{onResolved() {}, onReject() {}} function resolve(value) { // 当前状态不是pending结束 if (this.status !== &#39;pending&#39;) { return } // 修改状态 this.status = &#39;resolved&#39;; // 保存数据 this.data = value; // 立即执行callback if (this.callbacks.length &gt; 0) { this.callbacks.forEach(callbacksObj =&gt; { setTimeout(() =&gt; { // 异步执行回调 callbacksObj.onResolved(value) }, 0) }); } } function reject(reason) { // 当前状态不是pending结束 if (this.status !== &#39;pending&#39;) { return } // 修改状态 this.status = &#39;rejected&#39;; // 保存数据 this.data = value; // 立即执行callback if (this.callbacks.length &gt; 0) { this.callbacks.forEach(callbacksObj =&gt; { setTimeout(() =&gt; { // 异步执行回调 callbacksObj.onRejected(reason) }, 0) }); } } // 立即执行excutor try { excutor(resolve, reject); } catch (error) { // 抛出异常变为rejected reject(error); } } Promise.then()/.catch()先来看一下这个例子，将fn赋值给f，两种方法，第二种比第一种简介，在.then内部返回数据时会用到 function fn() { } var f = function fn() { } var f = fn; 正片开始 /* Promise 原型对象.then 指定成功和失败的回调函数 返回一个新的Promise */ Promise.prototype.then = function (onResolved, onRejected) { onResolved = typeof onResolved === &#39;function&#39; ? onResolved : value =&gt; value onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; {throw reason} const _this = this; // 返回一个新的promise return new Promise((resolve, reject) =&gt; { // 指定调用回调函数 function handle(callback) { try { const result = callback(_this.data); if (result instanceof Promise) { // 类型为promise，结果是这个promise的结果 // result.then( // value =&gt; resolve(value), // reason =&gt; reject(reason) // ) result.then(resolve, reject); } else { resolve(result); // 非promise返回结果 } } catch (error) { // 抛出异常，失败 reject(error); } } if (_this.status === PENDING) { _this.callbacks.push({ onResolved(value) { handle(onResolved) }, onRejected(reason) { handle(onRejected) } }) } else if (_this.status === RESOLVED) { setTimeout(() =&gt; { handle(onResolved) }) } else { setTimeout(() =&gt; { handle(onRejected) }) } }) } /* Promise 原型对象.catch 指定失败的回调函数 返回一个新的Promise */ Promise.prototype.catch = function (onRejected) { return this.then(undefined, onRejected) } Promise.resolve()/reject() /* Promise 原型对象.resolve 返回一个指定value的Promise */ Promise.resolve = function (value) { // 返回一个成功/失败的promise return new Promise((resolve, reject) =&gt; { if (value instanceof Promise) { value.then(resolve, reject) } else { resolve(value) } }) } /* Promise 原型对象.reject 返回一个指定reason的Promise */ Promise.reject = function (reason) { // 返回一个失败的promise return new Promise((resolve, reject) =&gt; { reject(reason); }) } Promise.all()/race() /* Promise 原型对象.all 返回一个Promise，所有promise都成功才成功，一个失败就失败 */ Promise.all = function (promises) { const values = new Array(promises.length); // 保存所有成功的value let resolveCount = 0; // 计数器，计算成功的数量 return new Promise((resolve, reject) =&gt; { // 获取每个promise的结果 promises.forEach((p, index) =&gt; { p.then( value =&gt; { resolveCount++; values[index] = value; if (resolveCount === promises.length) { // 所有都完成才会resolve resolve(values) } }, reason =&gt; { reject(reason) } ) }) }) } /* Promise 原型对象.race 返回一个Promise，由第一个完成的promise决定 */ Promise.race = function (promises) { return new Promise((resolve, reject) =&gt; { promises.forEach((p) =&gt; { p.then( value =&gt; { resolve(value) }, reason =&gt; { reject(reason) } ) }) }) } 代码代码已经上传码云","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"原型和原型链","slug":"原型和原型链","date":"2020-08-19T00:53:18.162Z","updated":"2020-08-19T00:54:16.493Z","comments":true,"path":"2020/08/19/原型和原型链/","link":"","permalink":"https://fengjing95.github.io/2020/08/19/原型和原型链/","excerpt":"","text":"原型和原型链 javascript是动态的，并且本身不提供一个 class 实现。（在 ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的）。 每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性 __proto__就是指向对象原型的属性 例如有一个Person对象，实例化一个实例对象之后它的__proto__指向Object 每个函数都会自带一个prototype属性，指向对象原型 function Person(name) { this.name = name; } Person.prototype.age = 12; var zhangsan = new Person(&#39;zhangsan&#39;); console.log(zhangsan); 可以看到实例的原型中已经有了age属性 实例对象.__proto__ === 构造函数.prototype 上面的例子中 zhangsan.__proto__ === Person.prototype Person.prototype.__proto__ === Object.prototype zhangsan——Person——Object这种原型与原型层层相链接的过程即为原型链 当读取实例属性时，如果找不到就会从原型链一层一层地往上找，一直到最顶层为止 所有对象的原型最终都指向Object，而Object.prototype.__proto__ === null","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"vuex入门","slug":"vuex入门","date":"2020-08-18T11:03:09.232Z","updated":"2020-08-18T11:03:43.497Z","comments":true,"path":"2020/08/18/vuex入门/","link":"","permalink":"https://fengjing95.github.io/2020/08/18/vuex入门/","excerpt":"","text":"vuex入门优势 集中管理数据，易于后期开发和维护 高效的实现组件之间的数据共享，提高开发效率 vuex中数据都是响应式的，实时保持页面同步 哪些数据适合存储到Vuex中只有组件之间需要共享的数据，才有必要存储到Vuex中 Vuex核心概念State提供唯一的公共数据源 const store = new Vuex.store({ state: { count: 0 } }) 组件中访问State数据 第一种方式：this.$store.state.全局数据名 第二种方式：按需导入import {mapState} from &#39;vuex&#39;，通过mapState函数，将当前组件需要的全局数据映射为当前组件的computed计算属性 computed: { ...mapState([&#39;count&#39;]) } Mutation用于变更store中的数据 只能通过mutation变更Store数据，不可以直接操作Store中的数据 可以集中监控所有数据变化 在vuex中定义方法 const store = new Vuex.store({ mutations: { add(state) { state.count++ } } }) 方法一：通过this.$store.commit方法触发vuex中的方法 methods: { btnHandle1() { this.$store.commit(&#39;add&#39;) } } 可以在触发mutation的时候传递参数 const store = new Vuex.store({ mutations: { addN(state, step) { state.count += step } } }) ······ btnHandle2() { this.$store.commit(&#39;add&#39;, 3) } 方法二：从Vuex中按需导入mapMutations函数，将需要的mapMutations函数映射为当前组建的methods方法 import {mapMutations} from &#39;vuex&#39; ··· methods: { ...mapMutations([&#39;sub&#39;]), Handle() { this.sub() } } 带参数 methods: { ...mapMutations([&#39;subN&#39;]), Handle2() { this.subN(3) } } mutation函数中不可以执行异步操作 Action用于处理异步任务，Action 提交的是 mutation，而不是直接变更状态 const store = new Vuex.Store({ state: { count: 0 }, mutations: { add (state) { state.count++ } }, actions: { addAsync(context, step) { setTimeout(() =&gt; { context.commit(&#39;add&#39;, step) },1000) } } }) 方法一：通过 $store.dispatch()触发Action btnHandle3() { this.$store.dispatch(&#39;addAsync&#39;) } 携带参数 addAsyncN(context, step) { setTimeout(() =&gt; { context.commit(&#39;addN&#39;, step) },1000) } ······ btnHandle4() { this.$store.dispatch(&#39;addAsyncN&#39;, 3) } 方法二：从vuex中按需导入mapActions函数，将需要的actions函数映射为组建的methods import {mapActions} from &#39;vuex&#39; ······ methods: { ...mapActions([&#39;subAsync&#39;]), Handle3() { this.subAsync() } } 携带参数 methods: { ...mapActions([&#39;subAsyncN&#39;]), Handle4() { this.subAsyncN(3) } } Getter用于对Store中的数据进行加工处理形成新的数据，不会修改原有数据 对Store中的数据进行加工处理形成新的数据，类似于Vue中的计算属性 Store中的数据发生变化，Getter的数据也会跟着改变 定义getter getters: { showNum(state) { return &#39;当前最新数量是【&#39; + state.count + &#39;】&#39; } } 获取getter 方法一：通过this.$store.getters.getter的方法名 this.$store.getters.showNum 方法二：按需导入mapGetters函数，通过mapGetters函数，将当前组件需要的全局数据映射为当前组件的computed计算属性 import {mapGetters} from &#39;vuex&#39; ······ computed: { ...mapGetters([&#39;showNum&#39;]) }, Vuex模块化管理随着功能和数据不断增加，store会越来越臃肿，把不同的功能单独拆分处理，可以方便管理 └── store └── index.js # 总的store └── modules └── modulesA.js # 模块A └── modulesB.js # 模块B · # 其他模块 规模较小的可以将不同的核心放在一个模块js中，分多了反而不方便 user.js const state = {} const actions = {} _______________ export defult { namespaced: true, state, actions, } index.js import moduleA from &#39;./modules/modulesA&#39; ___________ modules: { moduleA } Vuex模块化管理调用不同功能划分模块之后引入数据的方式略有改变 state方法一： this.$store.state.moduleA.key2，在原来直接引入数据的基础上，添加了模块名 方法二： computed: { ...mapState({ key: state =&gt; state.moduleA.key1 }) ------------------- ...mapState(&#39;moduleA&#39;, { key: &quot;key1&quot; }), }, 将模块中的key1赋值给计算属性key,两种方法结果是一样的 mutations方法一： this.$store.commit(&#39;moduleA/changeValue&#39;)，在原来直接调用方法名的基础之上添加模块名 方法二： methods: { ...mapMutations(&#39;moduleA&#39;,[&#39;changeValue&#39;]), handle() { this.changeValue() } } 在引入方法之前添加模块名 actions同mutataions 方法一： this.$store.dispatch(&#39;moduleA/changeAsync&#39;) 方法二： methods: { ...mapActions(&#39;moduleA&#39;, [&#39;changeAsync&#39;]), handle() { this.changeAsync() } } getters方法一 computed: { ...mapGetters(&#39;moduleA&#39;,{ dKey: &quot;detailValue&quot; }) }, 方法二 this.$store.getters[&#39;moduleA/getMethods&#39;] Vuex状态管理 组件通过调用actions触发mutations来修改state，state经过getters包装之后显示到组件； 组件不能直接修改state，只让mutation修改state","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"原生JS实现AJAX","slug":"原生JS实现AJAX","date":"2020-08-18T08:14:27.923Z","updated":"2020-08-19T23:49:28.275Z","comments":true,"path":"2020/08/18/原生JS实现AJAX/","link":"","permalink":"https://fengjing95.github.io/2020/08/18/原生JS实现AJAX/","excerpt":"","text":"原生JS实现AJAX什么是AjaxAJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），不是新的编程语言，而是一种使用现有标准的新方法，不重新加载整个页面的情况下更新部分页面 Ajax工作原理 XHR(XMLHttpRequiest)创建XHR对象新版本的浏览器都支持XHR对象，直接实例化即可var xhr = new XMLHttpRequest(); XHR请求如果要将数据发送到服务器，使用XMLHttpRequest 对象的 open() 和 send() 方法 open(method, url, async) method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) string：仅用于 POST 请求发送数据 GET请求function load() { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { document.getElementById(&quot;box&quot;).innerHTML = xhr.responseText; } } xhr.open(&#39;GET&#39;, &#39;/promise.js&#39;, true); xhr.send(); } 声明一个函数，函数中实例化一个XHR实例对象，当xhr的状态改变成相应的状态时，将请求到的文本插入HTML文档中 POST请求过程相同，只是在send中加入要发送的数据 封装每次请求都要写这一堆东西太过繁琐，将代码抽离出来作为单独的模块 var Ajax = { get: function (url,callback) { var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { callback(xhr.responseText); } } }, post: function (url, data, callback) { var xhr = new XMLHttpRequest(); xhr.open(&#39;POSt&#39;, url, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { callback(xhr.responseText); } } xhr.send(data); } } function load() { Ajax.get(&#39;/promise.js&#39;, (res) =&gt; { document.getElementById(&quot;box&quot;).innerHTML = res; }); } get请求传入url和callback，ststus变为200时触发callback readystate status 反馈内容 基于Promise封装var Ajax = { get: function (url) { return new Promise((resolve, reject) =&gt; { var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url, true); xhr.send(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status === 0)) { resolve(xhr.responseText); } } }) }, post: function (url, data) { return new Promise((resolve, reject) =&gt; { var xhr = new XMLHttpRequest(); xhr.open(&#39;POSt&#39;, url, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 0) { resolve(xhr.responseText); } } xhr.send(data); }) } } function load() { const p = Ajax.get(&#39;/promise.js&#39;).then(value =&gt; { console.log(value); }).catch(reason =&gt; { console.log(reason); }) } 把异步操作封装到Promise，调用起来相当方便，这样可以请求到数据，但判断状态如果加上else就会走else分支，目前没有找到原因","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"ES6和CommonJS的模块化","slug":"ES6&CommonJS","date":"2020-08-18T01:10:06.072Z","updated":"2020-08-18T01:15:02.556Z","comments":true,"path":"2020/08/18/ES6&CommonJS/","link":"","permalink":"https://fengjing95.github.io/2020/08/18/ES6&CommonJS/","excerpt":"","text":"ES6和CommonJS的模块化 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 导出导入对比ES6ES6采用import/export来进行导出导入操作，还有一种导出方式export default，一般使用了export default的不允许同时使用export CommonJScjs采用require/module.exports来进行导入导出操作 ES6是引用，CommonJS是拷贝ES6导入的是模块的引用，当模块内部的值发生改变时，引用的值也会改变 print.js代码如下 export let num = 9; export function logNum() { num++; } 引用如下 可以看到每在浏览器点击一次button都会打印出num的值+1 CommonJS模块输出的是值的拷贝，模块内部的变化不会影响到输出值 print.js代码修改为如下 let num = 9; function logNum() { num++; } module.exports = { num, logNum } 然后再点击button会看到控制台打印出的数值一直不变 此外，export default导出的效果也跟CommenJS相同 let num = 9; function logNum() { num++; } export default { num, logNum } 引入时接收为一个对象 打印结果同样不变 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 运行时加载: CommonJS 模块就是对象（即module.exports属性）；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载” 此外 CommonJs是动态语法可以写在判断里，ES6 Module静态语法只能写在顶层","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Egg实用中间件","slug":"Egg常用的包","date":"2020-08-17T08:17:39.921Z","updated":"2020-08-21T05:34:29.718Z","comments":true,"path":"2020/08/17/Egg常用的包/","link":"","permalink":"https://fengjing95.github.io/2020/08/17/Egg常用的包/","excerpt":"","text":"Egg常用的插件egg-mysql安装与配置首先安装egg-mysql的包 $ npm i --save egg-mysql 然后在plugin.ts开启插件 mysql: { enable: true, package: &#39;egg-mysql&#39;, }, 再然后在config中配置数据库信息 单数据库// mysql数据库 config.mysql = { client: { // 单数据库信息配置 host: &#39;localhost&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;liuhao&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;ssmbuild&#39;, // 数据库名 }, app: true, // 是否加载到 app 上，默认开启 agent: false, // 是否加载到 agent 上，默认关闭 }; 使用方法 await app.mysql.query(sql, values); 多数据库// mysql数据库 config.mysql = { clients: { // 多据库信息配置 db1: { host: &#39;localhost&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;liuhao&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;ssmbuild&#39;, // 数据库名 }, db2: { host: &#39;mysql.com&#39;, // host port: &#39;3306&#39;, // 端口号 user: &#39;root&#39;, // 用户名 password: &#39;123456&#39;, // 密码 database: &#39;test&#39;, // 数据库名 } }, app: true, // 是否加载到 app 上，默认开启 agent: false, // 是否加载到 agent 上，默认关闭 }; 使用方法 const client1 = app.mysql.get(&#39;db1&#39;);await client1.query(sql, values); const client2 = app.mysql.get(&#39;db2&#39;);await client2.query(sql, values); 注意egg-mysql没有index.d.ts，所以编译不过，在typings/index.d.ts中添加配置 import &#39;egg&#39;; declare module &#39;egg&#39; { interface mysql { get(tableName: String, find: {}): Promise&lt;Any&gt; insert(tableName: String, find: {}): Promise&lt;Any&gt; update(tableName: String, find: {}): Promise&lt;Any&gt; delete(tableName: String, find: {}): Promise&lt;Any&gt; query(sql: String, values: Any[]): Promise&lt;Any&gt; } interface Application { mysql: mysql; } } 详见寒风傲天博文 CRUDCreate使用insert方法插入一条记录，插入成功判定 result.affectedRows === 1 // controller public async insert() { const { ctx } = this; const book = { bookName: &#39;js&#39;, bookCounts: 2, detail: &#39;test&#39;, }; const result = await ctx.service.book.create(book); if (result.affectedRows === 1) { ctx.body = &#39;插入成功&#39;; } else { ctx.body = &#39;插入失败&#39;; } } // service public async create(book) { const { app } = this; const result = await app.mysql.insert(&#39;books&#39;, book); return result; } 结果如图 Read使用 get 方法或 select 方法获取一条或多条记录。select 方法支持条件查询与结果的定制。 // controller public async index() { const { ctx } = this; const result = await ctx.service.book.select(); await ctx.render(&#39;book.ejs&#39;, { result, }); } // service public async select(options?: object) { const { app } = this; const result = await app.mysql.select(&#39;books&#39;, options); return result; } 来看下效果 定制查询 Update&amp;Delete使用 update 方法更新数据库记录 const result = await app.mysql.update(&#39;posts&#39;, row, options); // 参数: 表名，更新的数据，查询参数 const updateSuccess = result.affectedRows === 1; // 插入成功判定 使用 delete 方法删除数据库记录 const result = await app.mysql.delete(&#39;posts&#39;, options); 直接执行sql查询使用 query 执行sql 语句 const id = 1; cosnt count = 4; const results = await app.mysql.query(&#39;select * from books where id = ? and bookCounts &gt; ?&#39;, [id, count]); 事务 代码代码已上传码云#2部分 egg-sequelize安装与配置安装egg-sequelize和mysql2 $ npm install --save egg-sequelize mysql2 在plugin中开启插件 sequelize: { enable: true, package: &#39;egg-sequelize&#39;, }, 在config中配置sequelize // 配置sequellize config.sequelize = { dialect: &#39;mysql&#39;, // 数据库类型 database: &#39;ssmbuild&#39;, // 数据库名称 host: &#39;127.0.0.1&#39;, // 数据库ip地址 port: 3306, // 数据库端口 username: &#39;liuhao&#39;, // 数据库用户名 password: &#39;123456&#39;, // 数据库密码 }; 经测试这种方式可以进行操作，但是，不能自动生成表，需要手动建表 配置sequelize-cli安装 $ npm install --save-dev sequelize-cli 在项目根目录下新建一个 .sequelizerc 配置文件 &#39;use strict&#39;; const path = require(&#39;path&#39;); module.exports = { config: path.join(__dirname, &#39;database/config.json&#39;), &#39;migrations-path&#39;: path.join(__dirname, &#39;database/migrations&#39;), &#39;seeders-path&#39;: path.join(__dirname, &#39;database/seeders&#39;), &#39;models-path&#39;: path.join(__dirname, &#39;app/model&#39;), }; 然后运行命令初始化配置文件和目录 $ npx sequelize init:config $ npx sequelize init:migrations 根目录下会生成数据库相关文件夹 将config.js中的数据库配置改为自己的配置 然后运行命令生成表，以user为例 $ npx sequelize migration:generate --name=users 可以看到多了一个users.js文件，开始配置user模型 module.exports = { // 在执行数据库升级时调用的函数，创建 users 表 up: async (queryInterface, Sequelize) =&gt; { /** * Add altering commands here. * * Example: * await queryInterface.createTable(&#39;users&#39;, { id: Sequelize.INTEGER }); */ const { INTEGER, STRING } = Sequelize; await queryInterface.createTable(&#39;users&#39;, { id: { type: INTEGER, // INTEGER就是mysql中的int primaryKey: true, autoIncrement: true, // 自动增长 }, name: STRING(20), url: STRING(100), country: STRING(10), }, { // timestamps: false, // 去除createAt updateAt createdAt: false, // 表示不启用created_at updatedAt: false, // 表示不启用updated_at freezeTableName: true, // 使用自定义表名 // 使用自定义表名之后上面写的users就直接就是你的表名，如果不加的话，你就可以写user，但是自己的表名为users，程序会自动将s加上 tableName: &#39;users&#39;, // 自定义的表名，也可以不写，直接用define后面的也可以 // 只要你使用了freezeTableName，程序就不会自动给你加上s了 }); }, // 在执行数据库降级时调用的函数，删除 users 表 down: async queryInterface =&gt; { /** * Add reverting commands here. * * Example: * await queryInterface.dropTable(&#39;users&#39;); */ await queryInterface.dropTable(&#39;users&#39;); }, }; 然后变更数据库 # 升级数据库 $ npx sequelize db:migrate # 如果有问题需要回滚，可以通过 `db:migrate:undo` 回退一个变更 # npx sequelize db:migrate:undo # 可以通过 `db:migrate:undo:all` 回退到初始状态 # npx sequelize db:migrate:undo:all 可以看到数据库中已经有了users表 编码OK，配置已经完成，现在开始进行愉快的编码 首先在app目录下新建一个model文件夹，将user模型添加到model下面，然后就可以通过app.model.User 或者 ctx.model.User 访问了，以insert为例 // controller public async add() { const { ctx } = this; const result = await ctx.service.user.createUser({ name: &#39;zhangsan&#39;, url: &#39;http://zhangsan.com&#39;, country: &#39;CN&#39;, }); ctx.body = result; } // service public async createUser(user: object) { const res = await this.ctx.model.User.create(user); return res; } 然后就可以看到已经插入数据成功 更多sequelize使用方法不多赘述，见之前的博文，传送门 代码代码已上传码云#3部分 egg-passport这里用微博的第三登录做为示范 安装及配置首先运行命令安装passport支持 $ npm i --save egg-passport $ npm i --save egg-passport-weibo 然后开启插件 passport: { enable: true, package: &#39;egg-passport&#39;, }, passportWeibo: { enable: true, package: &#39;egg-passport-weibo&#39;, }, 然后在config.default中配置申请到的身份码 // weibo登录 config.passportWeibo = { key: &#39;your key&#39;, secret: &#39;your secret&#39;, }; 编码首先在router中挂载路由，这里使用的是插件提供的语法糖（这里挂载的时候可能会报错，因为没有index.d.ts文件，这个问题解决办法上面说过，这里不再赘述） export default (app: Application) =&gt; { const { controller, router } = app; router.get(&#39;/&#39;, controller.home.index); app.passport.mount(&#39;weibo&#39;); // 相当于 // const github = app.passport.authenticate(&#39;github&#39;, {}); // router.get(&#39;/passport/github&#39;, github); // router.get(&#39;/passport/github/callback&#39;, github); }; 然后在controller中编写登录操作 public async index() { // const { ctx } = this; // // ctx.body = await ctx.service.test.sayHi(&#39;egg&#39;); // await ctx.render(&#39;login.ejs&#39;); const { ctx } = this; if (ctx.isAuthenticated()) { ctx.body = `&lt;div&gt; &lt;h2&gt;${ctx.path}&lt;/h2&gt; &lt;hr&gt; Logined user: &lt;img src=&quot;${ctx.user.photo}&quot;&gt; ${ctx.user.displayName} / ${ctx.user.id} | &lt;a href=&quot;/logout&quot;&gt;Logout&lt;/a&gt; &lt;pre&gt;&lt;code&gt;${JSON.stringify(ctx.user, null, 2)}&lt;/code&gt;&lt;/pre&gt; &lt;hr&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/user&quot;&gt;User&lt;/a&gt; &lt;/div&gt;`; } else { ctx.session.returnTo = ctx.path; ctx.body = ` &lt;div&gt; &lt;h2&gt;${ctx.path}&lt;/h2&gt; &lt;hr&gt; Login with &lt;a href=&quot;/passport/weibo&quot;&gt;Weibo&lt;/a&gt; &lt;hr&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/user&quot;&gt;User&lt;/a&gt; &lt;/div&gt; `; } } 由于我的服务器已经过期，没有可用的网站来审核，所以申请到的oauth码不能使用，如果通过审核，这就可以使用了 此外 API ctx.user - 获取当前已登录的用户信息 ctx.isAuthenticated() - 检查该请求是否已授权 ctx.login(user, [options]) - 为用户启动一个登录的 session ctx.logout() - 退出，将用户信息从 session 中清除 ctx.session.returnTo= - 在跳转验证前设置，可以指定成功后的 redirect 地址 还提供了 API： app.passport.verify(async (ctx, user) =&gt; {}) - 校验用户 app.passport.serializeUser(async (ctx, user) =&gt; {}) - 序列化用户信息后存储进 session app.passport.deserializeUser(async (ctx, user) =&gt; {}) - 反序列化后取出用户信息 app.passport.authenticate(strategy, options) - 生成指定的鉴权中间件 options.successRedirect - 指定鉴权成功后的 redirect 地址 options.loginURL - 跳转登录地址，默认为 /passport/${strategy} options.callbackURL - 授权后回调地址，默认为 /passport/${strategy}/callback app.passport.mount(strategy, options) - 语法糖，方便开发者配置路由 代码代码已上传码云#4部分 egg-jwtjwt（jsonwebtoken）是我认为潜力最大的一种用户状态验证方式 JWT原理三部分组成，用.分割 header: 一个json对象，描述JWT的元数据 payload: 一个 JSON 对象，用来存放实际需要传递的数据 signature: 对header和payload两部分的签名，防止数据被篡改 安装与配置运行命令安装 $ npm i egg-jwt --save 开启插件 jwt: { enable: true, package: &#39;egg-jwt&#39;, } 在config.default中配置秘钥 // JWT秘钥 config.jwt = { secret: &#39;xiaofeng&#39;, }; 编码登录页使用post方法提交表单不再列出，主要给出生成token的操作（同样jwt没有index.d.ts，需要手动配置，见前文） public async add() { const { ctx, app } = this; ctx.cookies.set(&#39;username&#39;, ctx.request.body.username); const token = app.jwt.sign({ username: ctx.request.body.username, }, app.config.jwt.secret); ctx.set({ authorization: token }); //设置headers ctx.body = token; } 效果如图 代码代码已上传码云#5部分 egg-validateegg-validate用于对参数进行检验，比如检验一个用户名是不是字符串ctx.validate({ userName: &#39;string&#39; }); 安装及配置运行命令 $ npm i egg-validate --save plugin中开启插件 validate: { enable: true, package: &#39;egg-validate&#39;, }, config中配置 // validate, 参数校验器 config.validate = { convert: true, // 对参数可以使用convertType规则进行类型转换 // validateRoot: false, // 限制被验证值必须是一个对象。 }; 编码编写一个post请求，接收一个对象作为参数 （validator需要手动挂载，使用什么方法添加什么规则） import { Controller } from &#39;egg&#39;; // 规则 const createRule = { name: &#39;string&#39;, age: { type: &#39;number&#39;, min: 0, max: 100, }, sex: [ &#39;man&#39;, &#39;woman&#39; ], }; export default class PostsController extends Controller { public async index() { const { ctx } = this; ctx.body = &#39;posts index&#39;; } public async create() { const { ctx, app } = this; // ctx.validate(createRule, ctx.request.body); // 自动处理错误，422 const error = app.validator.validate(createRule, ctx.request.body); // 返回错误信息，开发者处理 console.log(error); ctx.status = 201; } } 效果如图，当出现错误时返回错误，没有错误error为空，created是自动加的 更多规则 自定义规则使用app.validator.addRule添加更多自定义规则（需要手动挂载） 例如： app.validator.addRule(&#39;newRule&#39;, (rule, value)=&gt;{ if (value.length &lt; 3 || value.length &gt; 10) { console.log(&quot;用户名的长度应该在3-10之间&quot;); } }); 自定义规则需要单独在一个文件中添加 代码代码已上传码云#6部分 egg-cors 请求跨域是我们在日常开发中经常碰到的问题 egg解决跨域也是非常的简单，只要开启egg-cors就行了 安装及配置运行命令 $ npm i egg-cors --save plugin中开启插件 cors: { enable: true, package: &#39;egg-cors&#39;, }, config中配置 // 关闭csrf config.security = { csrf: { enable: false, // 关闭csrf }, domainWhiteList: [ &#39;*&#39; ], // 白名单 }; // CORS config.cors = { origin: &#39;*&#39;, allowMethods: &#39;GET,HEAD,PUT,POST,DELETE,PATCH&#39;, }; 然后就可以了 代码代码已上传码云#7部分","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://fengjing95.github.io/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"EggJS学习笔记","slug":"EggJS学习笔记","date":"2020-08-15T15:14:19.584Z","updated":"2020-08-21T05:07:58.026Z","comments":true,"path":"2020/08/15/EggJS学习笔记/","link":"","permalink":"https://fengjing95.github.io/2020/08/15/EggJS学习笔记/","excerpt":"","text":"EggJS学习笔记开始介绍Egg.js 为企业级框架和应用而生，Express框架本身缺少约定，标准的 MVC 模型会有各种千奇百怪的写法。Egg 按照约定进行开发，奉行『约定优于配置』，团队协作成本低。 Egg特性 提供基于Egg定制上层框架的能力 高度可拓展的插件机制 内置多进程管理 基于Koa开发，性能优异 框架稳定，测试覆盖率高 渐进式开发 安装$ npm init egg --type=ts $ npm i 本篇主要使用ts，类型可以不填，会让你手动选择， 启动$ npm run dev $ open http://localhost:7001 目录结构egg-project ├── package.json -- 框架配置，依赖 ├── app --源码目录 | ├── router.ts -- 用于配置 URL 路由规则 | ├── model -- 用于放置领域模型 │ | └── user.ts │ ├── controller -- 用于解析用户的输入，处理后返回相应的结果 │ | └── home.ts │ ├── service (可选) -- 用于编写业务逻辑层 │ | └── user.ts │ ├── middleware (可选) -- 用于编写中间件 │ ├── schedule (可选) -- 用于定时任务 │ ├── public (可选) -- 用于放置静态资源 │ ├── view (可选) -- 用于放置模板文件 │ └── extend (可选) -- 用于框架的扩展 ├── config -- 配置文件 | ├── plugin.ts -- 用于配置需要加载的插件 | ├── config.default.ts -- 用于编写配置文件(下同) │ ├── config.prod.ts | ├── config.test.ts (可选) | ├── config.local.ts (可选) | └── config.unittest.js (可选) ├── logs -- 日志文件 └── test/app -- 用于单元测试 └── controller -- 用于controller层的单元测试 └── home.test.js 路由路由文件代码如下 import { Application } from &#39;egg&#39;; export default (app: Application) =&gt; { const { controller, router } = app; router.get(&#39;/&#39;, controller.home.index); router.get(&#39;/login&#39;, controller.admin.login); }; 代码简单明了，一眼就能看懂是如何配置的，为了防止看不懂，我们来说一下 配置方法明白了再来说一下路由文件整体的结构 首先从egg中解构出Application，这是一个接口，对传入的参数做出约束（启动文件在egg包中，使用过程基本不用动）；从传入的app中再解构出controller和router，router就是路由对象 可以看到源码中router对象中有很多HTTP方法 这个是最常用的get方法参数，路径和中间件，中间件这里就是要执行的操作，示例中用到controller中的方法 POST请求直接用相同的方法配置POST请求会抛出错误 因为这样不符合Egg的安全机制，常见的安全问题 XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作。 CSRF 攻击：伪造用户请求向网站发起恶意请求。 钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。 HTTP参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。 远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。 解决办法1在访问页面时向页面发送签名数据csrf public async index() { const { ctx } = this; // ctx.body = await ctx.service.test.sayHi(&#39;egg&#39;); await ctx.render(&#39;login.ejs&#39;, { csrf: ctx.csrf, }); } 然后在页面发送请求的时候带上这个csrf &lt;form action=&quot;/login?_csrf=&lt;%= csrf %&gt; &quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; 解决办法2使用中间件发送csrf import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { // 设置全局变量 ctx.state.csrf = ctx.csrf; await next(); }; } 这样就不用每次在方法里面发送csrf了 如果觉得url带着一长串csrf不好看，可以在表单域设置csrf &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;&lt;%= csrf %&gt;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; controller已经获取到了表单数据 resources自动配置RESTful风格API，只需要一行代码router.resources(&#39;posts&#39;, &#39;/api/posts&#39;, controller.posts);，就可以自动生成下面一套API Method Path Route Name Controller.Action GET /api/posts posts app.controllers.posts.index GET /api/posts/new new_post app.controllers.posts.new GET /api/posts/:id post app.controllers.posts.show GET /api/posts/:id/edit edit_post app.controllers.posts.edit POST /api/posts posts app.controllers.posts.create PUT /api/posts/:id post app.controllers.posts.update DELETE /api/posts/:id post app.controllers.posts.destroy 只需要在Controller中实现Action即可 控制器Controller看完路由再来看一下controller，代码如下 import { Controller } from &#39;egg&#39;; export default class AdminController extends Controller { public async login() { const { ctx } = this; ctx.body = await ctx.service.login.welcome(&#39;egg&#39;); } } 新建一个类继承egg中的Controller，编写方法login 这里注意，egg基于Koa，Koa是ctx.xxx，在egg中ctx被封装在this里面，使用解构赋值解析出来，如果不使用解构就要使用this.ctx.xxx 获取传值get类型通过ctx.query获取参数，比如 export default class AdminController extends Controller { public async index() { const { ctx } = this; const userName: string = ctx.query.name; ctx.body = await ctx.service.login.welcome(userName); } } 可以看到已经从url中获取了name参数 动态路由从url中获取数据，但不是使用query的形式，而是使用http://127.0.0.1:7001/user/123这种形式 在配置路由时添加参数，例如 router.get(&#39;/user/:id&#39;, controller.admin.user); 然后在Controller中使用ctx.params获取参数，如 public async user() { const { ctx } = this; const id: string = ctx.params.id; ctx.body = await ctx.service.login.userCenter(id); } 服务ServiceService 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，好处： 保持 Controller 中的逻辑更加简洁。 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。 将逻辑和展现分离，更容易编写测试用例 使用场景： 复杂数据的处理，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。或者计算完成后，更新到数据库。 第三方服务的调用 定义服务代码示例 import { Service } from &#39;egg&#39;; /** * Login Service */ export default class Login extends Service { /** * userCenter for you * @param id - your id */ public async userCenter(id: string) { return `ID：${id}`; } } 属性 配置项config在config.default.ts中添加配置项，可以直接在controller或者service中调用配置项。比如在config中定义一个字符串，然后在service中调用，代码如下 //config.default.ts // 自定义配置项 config.str = &#39;this is a config string&#39;; // Login.ts public async userCenter(id: string) { console.log(this.config.str); return `ID：${id}`; } 日志loggerlogger有四种级别，下面给出示例 this.logger.debug(&#39;this is degug&#39;); this.logger.info(&#39;this is info&#39;); this.logger.warn(&#39;this is warn&#39;); this.logger.error(&#39;this is error&#39;); 上下文ctx this.ctx.curl 发起网络调用。 this.ctx.service.otherService 调用其他 Service。 this.ctx.db 发起数据库调用等， db 可能是其他插件提前挂载到 app 上的模块。 注意 模板引擎安装模板引擎使用ejs做案例，首先安装ejs包，npm文档 $ npm i egg-view-ejs --save 然后将下面这段代码放到对应的配置文件里面 // {app_root}/config/plugin.js exports.ejs = { enable: true, package: &#39;egg-view-ejs&#39;, }; // {app_root}/config/config.default.js exports.view = { mapping: { &#39;.ejs&#39;: &#39;ejs&#39;, }, }; // ejs config exports.ejs = {}; 注意ts的配置方式不同，如下图 编写模板代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2 style=&quot;color: #409eff;&quot;&gt;&lt;%= data %&gt;&lt;/h2&gt; &lt;ul&gt; &lt;% for(let i = 0; i &lt; list.length; i++) { %&gt; &lt;li&gt;&lt;%= list[i] %&gt;&lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;img src=&quot;/public/images/egg.jpg&quot; alt=&quot;&quot; width=&quot;100px&quot; height=&quot;60px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 模板文件一定要放在app下的view目录下ejs语法： &lt;% ‘脚本’ 标签，用于流程控制，无输出。 &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 _%&gt; 将结束标签后面的空格符删除 controller返回模板并传值public async user() { const { ctx } = this; const id: string = ctx.params.id; const udata: string = await ctx.service.login.userCenter(id); const arr: number[] = [ 111, 222, 333 ]; await ctx.render(&#39;user.ejs&#39;, { data: udata, list: arr, }); } 这里注意两个点 ctx.render是异步方法，需要使用await修饰 render的第一个参数是模板名称，这里需要加上后缀名，否则会报错 效果如图 实战：小爬虫地址：http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1 Serviceimport { Service } from &#39;egg&#39;; /** * News Service */ export default class Login extends Service { /** * getNewsList */ public async getNewsList() { const url = this.config.api + &#39;appapi.php?a=getPortalList&amp;catid=20&amp;page=1&#39;; const res = await this.ctx.curl(url); const response = JSON.parse(res.data); return response.result; } /** * getContent * @param aid 文章aid */ public async getContent(aid: string) { const url = this.config.api + &#39;appapi.php?a=getPortalArticle&amp;aid=&#39; + aid; const res = await this.ctx.curl(url); const response = JSON.parse(res.data); console.log(response.result); return response.result; } } Controllerimport { Controller } from &#39;egg&#39;; export default class AdminController extends Controller { public async index() { const { ctx } = this; const data = await ctx.service.news.getNewsList(); await ctx.render(&#39;news.ejs&#39;, { data, }); } public async newsContent() { const { ctx } = this; const aid = ctx.query.aid; const data = await ctx.service.news.getContent(aid); await ctx.render(&#39;newscontent.ejs&#39;, { data: data[0], }); } } ejsnews.ejs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;News&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;新闻列表&lt;/h2&gt; &lt;ul&gt; &lt;% for( let i = 0; i &lt; data.length; i++ ) { %&gt; &lt;li&gt;&lt;a href=&quot;/newscontent?aid=&lt;%= data[i].aid %&gt;&quot; &gt;&lt;%= data[i].title %&gt;&lt;/a&gt; &lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; newscontent.ejs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;详情&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%- data.content %&gt; &lt;script&gt; document.title = &#39;&lt;%= data.title %&gt;&#39; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 最终效果 框架拓展extend有多种拓展自身的功能 Application Context Request Response Helper Applicationapp 对象指的是 Koa 的全局应用对象，全局只有一个，在应用启动时被创建 拓展方式框架会把 app/extend/application.ts 中定义的对象与 Koa Application 的 prototype 对象进行合并，直接创建文件进行编码即可，例如 import { Application } from &#39;egg&#39;; export default { func(this: Application) { return &#39;app extend&#39;; }, }; 在app对象中直接调用方法即可 其他对象拓展方式跟Application同样注意：request和response是在ctx里面使用的 中间件middleware配置中间件 Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。 一个中间件是一个放置在 app/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数： options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来。 app: 当前应用 Application 的实例。 来看一下代码示例，这个中间件的作用是在每次请求的时候打印出时间 import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { ctx.logger.info(new Date()); await next(); }; } 中间件写完之后要在config中进行配置，在middlewware数组中添加文件名 然后每次请求时就会看到打印出了日志 中间件传值中间件传值在配置文件中bizConfig中增加中间件同名对象，就可以在中间件中通过options来访问变量 const bizConfig = { // 中间件传值 printdate: { configStr: &#39;this is value from config&#39;, }, }; 这时中间件需要配置参数 import { Context, Application, EggAppConfig } from &#39;egg&#39;; // 自定义的中间件 export default function printDate(options: EggAppConfig[&#39;printdate&#39;], app: Application): any { app.logger.warn(options.configStr); return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { ctx.logger.info(new Date()); await next(); }; } 服务启动时就会在控制台看到打印出来的日志 实用中间件csrf中间件import { Context } from &#39;egg&#39;; // 自定义的中间件 export default function auth(): any { return async (ctx: Context, next: () =&gt; Promise&lt;any&gt;) =&gt; { // 设置全局变量 ctx.state.csrf = ctx.csrf; await next(); }; } 然后在config中添加中间件config.middleware = [ &#39;auth&#39; ];，就可以在任意页面上获取csrf了 CookieCookie是存储在访问者计算机中的变量，可以让同一个浏览器访问同一个域名的时候共享数据 Egg中Cookie的设置和获取设置ctx.cookies.set(key, value, options) public async add() { const { ctx } = this; ctx.cookies.set(&#39;username&#39;, ctx.request.body.username); ctx.body = ctx.request.body; } 在浏览器的开发者工具中查看Cookie 获取ctx.cookies.get(key, options) 设置 {Number} maxAge: 设置这个键值对在浏览器的最长保存时间。是一个从服务器当前时刻开始的毫秒数。 {Date} expires: 设置这个键值对的失效时间，如果设置了 maxAge，expires 将会被覆盖。如果 maxAge 和 expires 都没设置，Cookie 将会在浏览器的会话失效（一般是关闭浏览器时）的时候失效。 {String} path: 设置键值对生效的 URL 路径，默认设置在根路径上（/），也就是当前域名下的所有 URL 都可以访问这个 Cookie。 {String} domain: 设置键值对生效的域名，默认没有配置，可以配置成只在指定域名才能访问。 {Boolean} httpOnly: 设置键值对是否可以被 js 访问，默认为 true，不允许被 js 访问。 {Boolean} secure: 设置键值对只在 HTTPS 连接上传输，框架会帮我们判断当前是否在 HTTPS 连接上自动设置 secure 的值。 除了这些属性之外，框架另外扩展了 3 个参数的支持： {Boolean} overwrite：设置 key 相同的键值对如何处理，如果设置为 true，则后设置的值会覆盖前面设置的，否则将会发送两个 set-cookie 响应头。 {Boolean} signed：设置是否对 Cookie 进行签名，如果设置为 true，则设置键值对的时候会同时对这个键值对的值进行签名，后面取的时候做校验，可以防止前端对这个值进行篡改。默认为 true。 {Boolean} encrypt：设置是否对 Cookie 进行加密，如果设置为 true，则在发送 Cookie 前会对这个键值对的值进行加密，客户端无法读取到 Cookie 的明文值。默认为 false。 Session Cookie 在 Web 应用中经常承担标识请求方身份的功能，所以 Web 应用在 Cookie 的基础上封装了 Session 的概念，专门用做用户身份识别 Session保存在服务器上 Egg中使用Session 可以在config中配置session信息 exports.session = { key: &#39;EGG_SESS&#39;, maxAge: 24 * 3600 * 1000, // 1 天 httpOnly: true, encrypt: true, }; 代码代码已上传码云，传送门","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://fengjing95.github.io/tags/Node/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"VS Code 实用插件","slug":"VSCode使用插件集合","date":"2020-08-13T06:25:25.881Z","updated":"2020-08-13T06:32:56.930Z","comments":true,"path":"2020/08/13/VSCode使用插件集合/","link":"","permalink":"https://fengjing95.github.io/2020/08/13/VSCode使用插件集合/","excerpt":"","text":"VSCode使用插件集合any-rule一款正则表达式生成插件，安装之后使用Ctrl+Shift+P调出命令面板，输入zz就可以看到常用的正则表达式，回车即可插入代码中 Auto Rename Tag可以自动修改闭合的标签，修改前半部分标签，后半部分自动跟随修改，再也不会乱了 Bracket Pair Colorizer彩色括号插件，当代码中括号过多的时候很容易混乱，有了这款插件之后，配对的标签会渲染为同一种颜色，括号配对关系相当清楚 Easy LESS可以自动将less文件编译为css文件 essjs可以自动添加很多Egg框架的代码片段，比如controller、service之类，大大提高编码效率 Git History插件提供可视化查看git信息，提交记录等 htmltagwrap这款插件可以对选中的代码进行标签嵌套，选中代码之后使用组合快捷键Alt+W触发，嵌套标签时不用再剪来剪去了 Indenticator可以在高亮显示鼠标选中的代码块所在的层级 JavaScript (ES6) code snippets可以通过简写快速插入ES6语法的js代码片段，详细见简写使用文档 Live Server这也是一款很强大的插件，通过服务器展示html，在html文件中右键选择open with live server就可以在浏览器中查看网页效果 Path Autocomplete自动补全路径的插件，快速的填写路径，可以通过./、C:(磁盘路径)等触发 RegExp Preview and Editor一款正则表达式验证插件，可以展示正则式匹配的全过程，安装插件之后可以选中正则式右键来查看匹配过程 还有一个正则编辑器，通过Ctrl+Shift+P调出命令面板，搜索regexp editor命令来触发，可以一边写一边展示匹配过程 REST Client直接在VSCode中进行接口数据测试的一款插件，在文件区域新建一个.http后缀的文件，然后编写接口测试，比如GET方法，url是127.0.0.1:7001，编写出来就是 GET http://127.0.0.1:7001 不同的接口之间使用三个#进行分割，编写好接口之后会在url上面出现一个Send Request，点击就可以使用了 Vue VSCode Snippets可以快速插入Vue代码片段，非常方便，更多快捷命令见文档说明 ESLint代码规则检查插件，当代码中出现不符合ESlint语法规范时会有报错","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"高级组件provide/inject","slug":"高级组件provide-inject","date":"2020-08-12T06:56:52.036Z","updated":"2020-08-12T06:58:28.180Z","comments":true,"path":"2020/08/12/高级组件provide-inject/","link":"","permalink":"https://fengjing95.github.io/2020/08/12/高级组件provide-inject/","excerpt":"","text":"高级组件provide / inject官方文档介绍 类型 provide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } 详细 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是： 一个字符串数组，或 一个对象，对象的 key 是本地的绑定名，value 是： 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或 一个对象，该对象的： from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol) default 属性是降级情况下使用的 value 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 人话开始简单的来说就是在父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量。 示例父组件中使用provide定义一个变量 provide: { father: &quot;demo&quot;, }, 子组件使用inject引入变量 inject: [ &quot;father&quot; ], 再来看一下浏览器效果 可以看到浏览器的控制台成功的打印出了这个变量的值 上面提到，这种方式绑定的变量不是响应式的，我们来尝试一下 首先给父组件添加按钮绑定事件修改provide的值 provideHandle() { this.father = &quot;new demo&quot;; console.log(this.father); }, 然后来看效果 可以看到当点击按钮时，父组件的值已经改变，但是子组件中显示的依旧是原来的‘demo’ 响应方法：将父组件this对象作为返回值传递给子组件 废话少说，看效果 可以看到，子组件中的数据相应的发生了变化 更多示例","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Express中使用Sequelize实现ORM","slug":"Express中使用Sequelize实现ORM","date":"2020-08-10T06:33:37.962Z","updated":"2020-08-12T07:00:47.431Z","comments":true,"path":"2020/08/10/Express中使用Sequelize实现ORM/","link":"","permalink":"https://fengjing95.github.io/2020/08/10/Express中使用Sequelize实现ORM/","excerpt":"","text":"Express中使用Sequelize实现ORM起步第一步当然是环境，首先使用Express生成器安装express环境 express myapp // myapp，你自己的项目名称（需要全局安装express） npm install 然后安装sequelize npm install --save sequelize npm install --save mysql2 // 驱动，这里主要说mysql，其他的类型见官网文档 连接连接到数据库必须有sequelize实例，实例化方法如下 const connect = new DB(&#39;dbname&#39;, &#39;username&#39;, &#39;password&#39;, { host: &#39;localhost&#39;, dialect: &#39;mysql&#39; }) 配置好实例之后可以使用.authenticate()来测试连接 connect.authenticate().then(() =&gt; { console.log(&#39;连接成功&#39;) }).catch(error =&gt; { console.error(&#39;连接失败:&#39;, error); }) 关闭连接 默认情况下，Sequelize将使连接保持打开状态，并对所有查询使用相同的连接。如果需要关闭连接，请调用sequelize.close()（它是异步的并返回Promise） 模型基础定义模型 模型是Sequelize的本质。模型是代表数据库中表的抽象。在Sequelize中，它是扩展Model的类 使用sequelize.define方法来定义模型，sequelize会根据定义的模型名称的复数自动建表 const Book = connect.define(&#39;Book&#39;, { bookName: DB.STRING, // 属性名： 数据类型 bookCounts: DB.INTEGER, detail: DB.STRING, }, { timestamps: false // 自动生成createAt和updateAt }) 此外也可以直接提供表名 sequelize.define(&#39;Book&#39;, { // ... attributes }, { tableName: &#39;literature&#39; }); 更多数据类型： // CHAR Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.TEXT(&#39;tiny&#39;) // TINYTEXT // NUMBER Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 10) // FLOAT(11,10) Sequelize.DOUBLE // DOUBLE Sequelize.DOUBLE(11) // DOUBLE(11) Sequelize.DOUBLE(11, 10) // DOUBLE(11,10) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) // TIME Sequelize.DATE // mysql / sqlite 为 DATETIME, postgres 为带时区的 TIMESTAMP Sequelize.DATE(6) // DATETIME(6) 适用 mysql 5.6.4+. 小数秒支持最多6位精度 Sequelize.DATEONLY // DATE 不带时间. // BOOLEAN Sequelize.BOOLEAN // TINYINT(1) //ENUM Sequelize.ENUM(&#39;value 1&#39;, &#39;value 2&#39;) // 一个允许值为&#39;value 1&#39;和&#39;value 2&#39;的ENUM // blob Sequelize.BLOB // BLOB (PostgreSQL 为 bytea) Sequelize.BLOB(&#39;tiny&#39;) // TINYBLOB (PostgreSQL 为 bytea. 其余参数是 medium 和 long) // GEOMETRY Sequelize.GEOMETRY // Spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. Sequelize.GEOMETRY(&#39;POINT&#39;) // 带有 geometry 类型的 spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. Sequelize.GEOMETRY(&#39;POINT&#39;, 4326) // 具有 geometry 类型和 SRID 的 spatial 列. 仅 PostgreSQL (带有 PostGIS) 或 MySQL. // unsigned 和 zerofill 属性 Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL 数据类型来源，掘金，云影sky的详细易用的 Sequelize 解读 模型同步使用model.async()方法来将模型与数据库同步 User.sync() -如果不存在则创建表（如果已经存在则不执行任何操作） User.sync({ force: true }) -这将创建表，如果该表已经存在，则将其首先删除 User.sync({ alter: true }) -这将检查数据库中表的当前状态（它具有哪些列，它们的数据类型等），然后在表中进行必要的更改以使其与模型匹配 创建模型实例使用model.build方法来创建模型实例 const jsBook = Book.build({ bookName: &#39;你不知道的JS&#39;, bookCounts: 3, detail: &#39;JS 进阶系列&#39;, }) 上面的创建实例之后使用jsBook.save();方法来保存到数据库 模型查询INSERT查询上面的模型保存还有一种简便方法，直接使用model.create方法，直接保存到数据库 Book.create({ bookName: &#39;你不知道的JS&#39;, bookCounts: 3, detail: &#39;JS 进阶系列&#39;, }) 可以看到数据库中已经生成了这条记录 控制台可以看到sql语句 SELECT查询find查询使用findAll方法查询整个表 Book.findAll() 效果图 可以使用attributes选项来进行列查询，数组中列出要查询的字段名 Book.findAll({ attributes: [&#39;id&#39;, &#39;bookName&#39;], }) 效果图 使用exclude删除一些选定的属性 Book.findAll({ attributes: { exclude: [&#39;bookCounts&#39;] }, }) 效果图 其他find查询 findByPk：使用提供的主键仅从表中获得一个条目 findOne：获取它找到的第一个条目（如果提供的话，它满足可选的查询选项） findOrCreate：查询不到实例就创建一个，返回值是实例（查到的或者创建的）和一个布尔值（创建为true） findAndCountAll：查询并计数，有两个返回值，一个是查询到的记录另一个是count where子句使用where选项可以进行where查询 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, id: 1 } }) // SELECT * FROM books WHERE bookName = &#39;你不知道的JS&#39; AND id = 1; 效果如图 有了AND就有OR，使用Op.or来进行or操作 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, id: { [Op.or]: [1, 2] } } }) // SELECT * FROM books WHERE bookName = &#39;你不知道的JS&#39; AND (id = 1 OR id = 2); 效果图 AND也可以使用Op.and来操作，但是易读性不强（不常用） Book.findAll({ where: { [Op.and]: [ { bookName: &#39;你不知道的JS&#39; }, { id: { [Op.or]: [1, 2] } } ] } }) sequelize提供了更多运算 const { Op } = require(&quot;sequelize&quot;); Post.findAll({ where: { [Op.and]: [{ a: 5 }, { b: 6 }], // (a = 5) AND (b = 6) [Op.or]: [{ a: 5 }, { b: 6 }], // (a = 5) OR (b = 6) someAttribute: { // Basics [Op.eq]: 3, // = 3 [Op.ne]: 20, // != 20 [Op.is]: null, // IS NULL [Op.not]: true, // IS NOT TRUE [Op.or]: [5, 6], // (someAttribute = 5) OR (someAttribute = 6) // Using dialect specific column identifiers (PG in the following example): [Op.col]: &#39;user.organization_id&#39;, // = &quot;user&quot;.&quot;organization_id&quot; // Number comparisons [Op.gt]: 6, // &gt; 6 [Op.gte]: 6, // &gt;= 6 [Op.lt]: 10, // &lt; 10 [Op.lte]: 10, // &lt;= 10 [Op.between]: [6, 10], // BETWEEN 6 AND 10 [Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15 // Other operators [Op.all]: sequelize.literal(&#39;SELECT 1&#39;), // &gt; ALL (SELECT 1) [Op.in]: [1, 2], // IN [1, 2] [Op.notIn]: [1, 2], // NOT IN [1, 2] [Op.like]: &#39;%hat&#39;, // LIKE &#39;%hat&#39; [Op.notLike]: &#39;%hat&#39;, // NOT LIKE &#39;%hat&#39; [Op.startsWith]: &#39;hat&#39;, // LIKE &#39;hat%&#39; [Op.endsWith]: &#39;hat&#39;, // LIKE &#39;%hat&#39; [Op.substring]: &#39;hat&#39;, // LIKE &#39;%hat%&#39; [Op.iLike]: &#39;%hat&#39;, // ILIKE &#39;%hat&#39; (case insensitive) (PG only) [Op.notILike]: &#39;%hat&#39;, // NOT ILIKE &#39;%hat&#39; (PG only) [Op.regexp]: &#39;^[h|a|t]&#39;, // REGEXP/~ &#39;^[h|a|t]&#39; (MySQL/PG only) [Op.notRegexp]: &#39;^[h|a|t]&#39;, // NOT REGEXP/!~ &#39;^[h|a|t]&#39; (MySQL/PG only) [Op.iRegexp]: &#39;^[h|a|t]&#39;, // ~* &#39;^[h|a|t]&#39; (PG only) [Op.notIRegexp]: &#39;^[h|a|t]&#39;, // !~* &#39;^[h|a|t]&#39; (PG only) [Op.any]: [2, 3], // ANY ARRAY[2, 3]::INTEGER (PG only) // In Postgres, Op.like/Op.iLike/Op.notLike can be combined to Op.any: [Op.like]: { [Op.any]: [&#39;cat&#39;, &#39;hat&#39;] } // LIKE ANY ARRAY[&#39;cat&#39;, &#39;hat&#39;] // There are more postgres-only range operators, see below } } }); UPDATE查询使用model.update方法来进行数据更新 Book.update({ bookCounts: 5 }, { where: { id: 2 } }) // UPDATE books SET bookCounts =5 WHERE id = 2; 修改后的数据如下 DELETE查询使用model.destory方法进行删除操作 Book.destory({ where: { id: 2 } }) 限制和分页使用limit和offset选项进行限制/分页 limit：每一页的记录数量限制 offset：第几页，从0开始 Book.findAll({ where: { bookName: &#39;你不知道的JS&#39;, }， offset: parseInt(req.query.page) ? parseInt(req.query.page) : 0, limit: 1 }) 实用方法 进阶用法getter&amp;setter 事务","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://fengjing95.github.io/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"TypeScript学习笔记","slug":"TypeScript学习笔记","date":"2020-08-06T15:25:45.926Z","updated":"2020-08-06T15:28:43.822Z","comments":true,"path":"2020/08/06/TypeScript学习笔记/","link":"","permalink":"https://fengjing95.github.io/2020/08/06/TypeScript学习笔记/","excerpt":"","text":"TypeScript学习笔记1 简介TypeScript是由微软推出的编程语言，是javascript的超集，遵循ES5、ES6规范，拓展了js的语法 TypeScript更像是java等后端语言，可以开发大型企业项目，最新的前端框架基本都是使用了TS 2 安装npm install -g typescript cnpm以及yarn安装方式一样 3 编译及配置3.1 编译浏览器不识别ts代码，需要将ts代码编译为ES5的代码 新建index.ts脚本，编写代码 console.log(&quot;hello TS&quot;); 使用 tsc index.ts 命令进行编译 编译完成之后会生成index.js脚本，内容是 这一段代码看不出差别，来一段ts语法的代码 let str:String = &#39;feng&#39;; console.log(str); 再来看看编译出来的js脚本 3.2 在vscode中配置自动编译每次写完代码手动保存很不方便，可以使用配置文件自动生成js 在根目录下运行命令 tsc --init生成配置文件tsconfig.json 将outDir一行的注释打开，目录修改为要输出到的目录，不修改也可 点击选项卡终端-&gt;运行任务-&gt;typescript-&gt;tsc监视，然后再编写ts代码保存时就可以自动生成js了 4 数据类型ts为了使编写代码更规范增加了类型校验mts主要提供了以下几种类型的数据 布尔类型（boolean） 数字类型（number） 字符串类型（string） 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 4.1 布尔类型在变量标识符之后声明变量类型为boolean，那么这个变量只能接受布尔类型的赋值，如果赋值为其他类型的数据，在编译时会报错，例如 let isReal: boolean = 123; 定义布尔类型的变量isReal，然后为其赋值数字123，在编译时会抛出下面错误 意思是’123’不能赋值给boolean类型的变量 4.2 数值类型规则同布尔类型，声明的标识符是number 整形和浮点型都可以用number声明 4.3 字符串类型声明的标识符是string 4.4 数组类型声明方式有两种： 使用中括号 let arr:number[] = [1,2,3] // 数字类型的数组不能出现其它数据类型 使用泛型声明 let arr: Array&lt;number&gt; = [1, 2, 3] 4.5 元组类型let tuple:[string, number, boolean] = [&#39;feng&#39;, 11, true] 元组也是一种数组，可以指定数组的每一项的数据类型 4.6 枚举类型枚举类型用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。 枚举类型可以手动设置值 enum Flag { success = 1, error = -1 } let f: Flag = Flag.success console.log(f);// 1 // 另外一种手动设置的方式，只定义第一项，后面的依次递增 enum Animal { cat = 2, dog, snake } var a: Animal = Animal.snake; console.log(a); // 4 // 自定义值可以在任意位置，上面的代码汇中如果只定义dog=2，那么snake就是3 也可以使用默认值，默认值就是索引值 enum Color { blue, red, green } const c: Color = Color.blue; console.log(c); // 0 4.7 任意类型在上面的基本类型中，一旦定义了类型就不能再赋值其他类型的数据，否则就会报错 那如果想给一个变量赋值多种类型的数据就需要用到any来声明变量了 在ts文件中写入以下代码 var node = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 保存时会抛出以下错误 编译之后代码是可以运行的，但是存在问题 意思是node是一个Object类型，这时再给node声明Object类型 var node:Object = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 这时还会报错，因为进本数据类型中没有Object，这时就可以使用any类型了 var node: any = document.getElementById(&#39;box&#39;); node.style.color = &#39;red&#39;; 4.8 null和undefinednull和undefined是其他数据类型的子类 undefined声明变量是undefined类型之后，变量undefined不会报错，例如 但如果定义了undefined类型就不会报错 undefined一般用于联合类型 var num: number | undefined; num = 123; console.log(num); num可以是number类型，也可以是undefined null变量声明null之后只能为空值，如果为变量赋值就会报错 等于空值时不会报错 4.9 void类型用于定义没有返回值的方法 ((): void =&gt; { console.log(&#39;void&#39;); })() lambda表达式的写法 4.10 never类型其他类型，表示从不会出现（包括null和undefined的子类型），被never声明的变量只能被never类型的数据赋值 5 函数5.1 声明函数5.1.1 命名函数在TypeScript中声明函数时，要声明参数类型以及函数返回值类型 没有返回值使用void进行声明 function run(): string { return &#39;string&#39; } 在声明函数返回值类型之后，返回值的类型必须是声明的类型，否则报错 5.1.2 匿名函数在TypeScript中定义匿名函数也需要声明返回值类型 var func2 = function (): number { return 123; } 同样，返回值需要符合声明的返回值类型，不一致则会报错 5.2 传参定义一个方法，接收一个firstname和一个lastname，返回一个fullname function getName(firstname: string, lastname: string): string { return `${firstname}--${lastname}` } console.log(getName(&#39;Chan&#39;, &#39;Jack&#39;)); // Chan--Jack 匿名函数同样的在参数后声明类型 5.2.1 可选参数在func3中，有两个参数，现在调用func3，只传一个参数 function func3(name: string, age: number): void { console.log(name + &quot;--&quot; + age); } func3(&#39;zhangsan&#39;); 编译时会报错，原因是少了一个参数 在可选参数后添加?，表示参数可以有也可以没有 可选参数必须放到参数的最后面 5.2.2 默认参数在ES5中不可以设置默认参数，在ES6和TS中可以设置默认参数 function func3(name: string, age: number=20): void { console.log(name + &quot;--&quot; + age); } func3(&#39;zhangsan&#39;); // zahngsan--20 当默认参数在最后时，设置默认参数之后可以不传参数，使用默认的值，当默认参数在前面时必须传参数 5.2.3 剩余参数当不确定参数的数量时，可以使用ES6的扩展运算符（...） function getSum(...args: number[]): void { var result: number = 0; args.forEach(element =&gt; { result += element }); console.log(result); } getSum(1, 2, 3, 4) // 10 getSum(1, 2, 3, 4, 5) // 15 也可以固定前几个参数，然后后面的用扩展运算符接收 function getSum2(a: number, ...args: number[]): void { var result: number = a; args.forEach(element =&gt; { result += element }); console.log(result); } getSum2(1, 2, 3, 4) // 10 5.3 函数重载 java中的重载：两个或两个以上同名函数，但是他们接收的参数不一样，这时会出现函数重载 TypeScript中的重载：通过为同一个函数提供多个函数类型定义来实现多种功能的目的 function getInfo(name: string): string; function getInfo(age: number): string; function getInfo(str: any): any { if (typeof str === &#39;string&#39;) { return &#39;我叫&#39; + str } else { return &#39;我的年龄是&#39; + str } } console.log(getInfo(&#39;zahngsan&#39;)); console.log(getInfo(12)); 来看下结果 显然，ts在通过这种方式为一个函数实现了两种功能，但是，传参的类型必须在重载的函数参数之内，如果匹配不到就会报错 6 类6.1 对比ES56.1.1 定义类在ES5中使用构造函数创建对象，直接在function内部添加属性和方法 function Person() { this.name = &#39;zhangsan&#39; this.getInfo = function () { console.log(this.name); } } var p = new Person(); p.getInfo(); // zhangsan 还可以通过原型链的方式给对象添加属性和方法 Person.prototype.age = 20; Person.prototype.getAge = function () { console.log(this.age); } var p = new Person(); p.getAge(); // 20 但是，使用原型链添加的引用类型属性会被所有实例共享，意思就是当某一实例的该属性变化时，其他实例的属性都会改变 Person.prototype.friends = [&#39;f1&#39;, &#39;f2&#39;]; Person.prototype.getFriends = function () { console.log(this.friends); } var p = new Person(); p.getFriends(); var p2 = new Person(); p2.friends.push(&#39;f3&#39;); p.getFriends(); p2.getFriends(); 可以看到，改变一个实例的引用类型的属性，另一个实例也变了；基本数据类型不存在这种问题 6.1.2 静态方法ES5中给对象添加静态方法非常简单 Person.static = function () { console.log(&#39;静态方法&#39;); } Person.static(); // 静态方法 静态方法不需要实例化就可以调用，并且，对象实例不可以调用静态方法 6.1.2 继承ES5中通过对象冒充来实现继承 function People() { Person.call(this); } var peo = new People(); peo.getInfo(); // zhangsan 此外也可以通过原型的方法来实现继承 function People() { } People.prototype = new Person(); var peo = new People(); peo.getInfo(); 但是在实例化子类时无法给父类传参 function Person(name) { this.name = name; this.getInfo = function () { console.log(this.name); } } function People() { } People.prototype = new Person(); var peo = new People(&#39;zhangsan&#39;); peo.getInfo(); // undefined 然后就有了原型链+构造函数的组合继承模式——寄生组合继承 function People(name) { Person.call(this, name) } People.prototype = Person.prototype; var peo = new People(&#39;zhangsan&#39;); peo.getInfo(); // zhangsan 6.2 TypeScript中的类6.2.1 定义类在TS中，使用class关键字来定义类，类需要实例化时需要添加构造器 class Person { name: string; // 属性 constructor(n: string) { // 构造函数，实例化时触发 this.name = n; } getName(): string { return this.name; } setName(name: string): void { this.name = name } } var p: Person = new Person(&#39;李四&#39;); console.log(p.getName()); // 李四 p.setName(&#39;张三&#39;); console.log(p.getName()); // 张三 拓展——params方式实例化class Article { title: string | undefined; desc: string | undefined; status: number | undefined constructor(params: { title: string | undefined, desc: string | undefined, status?: number | undefined }) { this.title = params.title; this.desc = params.desc; this.status = params.status; } } var newArticle: Article = new Article({ title: &#39;大事件&#39;, desc: &#39;都是小事&#39; }) console.log(newArticle); 通过向构造器传入json对象，然后使用索引值来实例化对象 6.2.2 继承TS中继承有专门的关键字extends，需要配合super初始化父类构造函数来实现继承 class People extends Person { constructor(name: string) { super(name); } } var peo = new People(&#39;王五&#39;); console.log(peo.getName()); // 王五 6.2.3 修饰符 public：公有，在类里面、子类、外部都可以访问 protected：保护，在类里面，子类中可以访问 private：私有，只有类里面可以访问 属性不加修饰符默认是public 6.2.4 静态属性&amp;静态方法使用static修饰符声明静态方法，但是静态方法无法直接获取类中的属性，只能获取静态属性（同样用static修饰） class Person { name: string; static age: number = 20; constructor(n: string) { // 构造函数，实例化时触发 this.name = n; } getName(): string { return this.name; } setName(name: string): void { this.name = name } static log(): void { console.log(`年龄是${this.age}`); } } Person.log(); // 年龄是20 6.2.5 多态父类定义一个方法不去实现，让继承他的子类去实现，每一个子类有不同的表现 class Animals { name: string; constructor(name: string) { this.name = name; } getInfo(): void { } } class Dog extends Animals { constructor(name: string) { super(name); } getInfo(): void { console.log(this.name + &#39;是一只狗&#39;); } } class Cat extends Animals { constructor(name: string) { super(name); } getInfo(): void { console.log(this.name + &#39;是一只猫&#39;); } } var cat: Cat = new Cat(&#39;kitty&#39;); cat.getInfo(); // kitty是一只猫 var dog: Dog = new Dog(&#39;Tony&#39;); dog.getInfo(); // Tony是一只狗 这段代码中有一个父类Animals，两个子类Dog和Cat分别继承Animals，Animals定义了一个getInfo方法，两个子类中分别重写了这个方法，实现了不同的功能 6.2.6 抽象类 提供其他类继承的基类，不能被实例化；用absort关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现；抽象方法只能放在抽象类中 abstract class AbstractAnimals{ abstract func1(): void; abstract func2(): string; } class Mouse extends AbstractAnimals{ func1(): void { console.log(&#39;function 1&#39;); } func2(): string { return &#39;function 2&#39; } } 7 接口 在面向对象程序设计中，接口是一种规范的定义，它规定了行为和动作的规范，起到了限制和规范的作用。接口定义了某一批类需要遵守的规范，不关心这些类内部的状态数据，也不关心方法实现细节，只规定类需要提供哪些方法。类似于java中的类，更加灵活。 定义接口关键字：interface 7.1 属性接口属性接口就是对json格式的限制 interface FullName { firstName: string; lastName: string; } function getFullName(name: FullName) { return `${name.firstName}----${name.lastName}` } console.log(getFullName({ firstName: &#39;zhang&#39;, lastName: &#39;san&#39; })); // zhang----san 在这段代码中，定义了一个FullName接口，方法getFullName参数name要满足这个接口，如果不满足接口定义的规则就会报错 并且，参数必须且只能有接口定义的 数据项，如果参数一用对象，name该对象必须包含接口定义的项并且符合数据类型限制 可以使用 ? 定义可选属性，用法同可选参数 7.2 函数类型接口对方法传入的参数以及返回值进行约束 interface FuncRule { (key: string, value: string): string; } var funcIn: FuncRule = function (key: string, value: string): string { return `${key}---${value}` } console.log(funcIn(&#39;name&#39;, &#39;张三&#39;)); 接口中规定了两个参数和他们的类型以及返回值的类型，实现这个接口的函数就必须有这两个参数和返回值。参数类型不符合规定就会报错 7.3 可索引接口对数组、对象的约束 7.3.1 对数组的约束interface UserArr{ [index:number]:string; } var arr:UserArr=[&#39;aa&#39;, &#39;bb&#39;] console.log(arr[0]) 接口规定了索引值是number类型，value是string类型（开始这里没看懂，数组的索引还能不是number？？？继续往下看） 7.3.2 对对象的约束interface UserObj{ [index:string]:string } var arr:UserObj = { name: &#39;alex&#39; } 这里明白了，对数组的约束和对对象的约束不是具体的分类，索引值是number就限定了数组，索引值是string就限定了对象 7.4 类类型接口类类型约束和抽象有些类似，这里最接近于java中的接口类 // 接口 interface AnimalsInterface { name: string; eat(food: string): void; } // 实现类 class Tigger implements AnimalsInterface { name: string; constructor(name: string) { this.name = name; } eat(food: string): void { console.log(`${this.name}吃的是${food}。`); } } // 实例化 var t: Tigger = new Tigger(&#39;泰哥&#39;); t.eat(&#39;猪肉&#39;); // 泰哥吃的是猪肉。 在实现接口方法的时候，参数可以没有 7.5 接口扩展（接口继承）interface Animals { eat(): void; } interface People extends Animals { name: string; work(): void; } class Chinese implements People { name: string; constructor(name: string) { this.name = name; } work(): void { console.log(this.name + &#39;可以工作&#39;); } eat(): void { console.log(this.name + &#39;吃大餐&#39;); } } var ming: Chinese = new Chinese(&#39;小明&#39;); ming.work(); 接口People继承了接口Animals，在实现People接口的时候，需要同时实现Animals中定义的内容，如果去掉了Animals中的方法就会报错 8 泛型 泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。将类型参数化以达到代码复用提高软件开发工作效率的一种数据类型。泛型类]是引用类型，是堆对象，主要是引入了类型参数这个概念。 ——百度百科《泛型》 8.1 泛型变量先来看个例子 function getValue&lt;T&gt;(value: T): string { return &#39;获得的值是&#39; + value; } console.log(getValue&lt;number&gt;(12345)); 定义方法时规定了泛型T，传参时使用泛型规定类型 8.2 泛型类java中的ArrayList就是这种东西 class ArrayList&lt;T&gt; { private list: T[] = []; add(item: T): void { this.list.push(item); } getList(): T[] { return this.list; } } var arr = new ArrayList&lt;number&gt;(); arr.add(1); arr.add(4); console.log(arr.getList()); 这里用number类型做了个例子，泛型可以是任意类型，类也可以 使用上文7.5中的Chinese类来示范 // 实例化对象 var ming: Chinese = new Chinese(&#39;小明&#39;); var hong: Chinese = new Chinese(&#39;小红&#39;); // 将对象添加进list var arr = new ArrayList&lt;Chinese&gt;(); arr.add(ming); arr.add(hong); console.log(arr.getList()); 8.3 泛型接口在定义接口时使用泛型，实现接口时相应的需要用泛型实现，调用方法时可以根据需要规定数据的类型 interface ConfigFn { &lt;T&gt;(value: T): T; // 最后一个T是返回值类型，可以是其他的 } var getData: ConfigFn = function &lt;T&gt;(name: T): T { return name; } console.log(getData&lt;string&gt;(&#39;张三&#39;)); 9 装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器装饰器的写法：普通装饰器（无法传参） 、 装饰器工厂（可传参） 装饰器是过去几年中js最大的成就之一，已是ES7的标准特性之一 9.1 类装饰器装饰器本身是一个函数，装饰器通过@符号来使用 function logClass(params: any) { params.prototype.name = &#39;装饰器&#39;; params.prototype.run = function () { console.log(&#39;这是一个装饰器&#39;); } } @logClass class Log { constructor() { } getData() { } } var log: any = new Log(); // 这里变量类型声明any log.run(); // 这是一个装饰器 9.1.1 装饰器工厂装饰器工厂可以传参，通过闭包的方式进行操作 function logClass(params?: any) { return function (target: any) { console.log(params); } } @logClass(&#39;get&#39;) class Log { constructor() { } } var log: any = new Log(); // get 这里调用装饰器的时候方法立即执行 function logClass(params?: any) { return function (target: any) { target.prototype.pro = params; } } @logClass(&#39;post&#39;) class Log { constructor() { } } var log: any = new Log(); console.log(log.pro); 上面这一段代码通过装饰器动态给类添加属性，在调用构造器的时候一定要加括号，参数可选时没有参数也要带括号 9.1.2 重载构造函数 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数； 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明； function logClass(target: any) { return class extends target { url = &#39;newValue&#39; getData() { console.log(&#39;getData:&#39;, this.url); } } } @logClass class HttpClient { public url: string | undefined; constructor() { this.url = &#39;value&#39; } getData() { console.log(this.url); } } var http = new HttpClient(); http.getData(); //getData: newValue 装饰器返回的就是HttpClient的子类，因此TS可以自动推导 http 的类型； 重载时必须将类里面的所有属性几方法重载 9.2 属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入两个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 成员的名字； function LogProperty(params: any) { return function (target: any, attr: any) { console.log(target); console.log(attr); } } class User { @LogProperty(&#39;zhangsan&#39;) name: string; constructor() { } } 从图中可以看到属性装饰器传入的两个参数 function LogProperty(params: any) { return function (target: any, attr: any) { target[attr] = params; } } class User { @LogProperty(&#39;zhangsan&#39;) name: string | undefined; constructor() { } getName(): void { console.log(this.name); } } var u = new User(); u.getName(); // zhangsan 9.3 方法装饰器方法装饰器被应用到方法的属性描述符上，可以用来监视、修改、替换方法的定义。方法装饰器会在运行时传入3个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 成员的名字； 成员的属性描述符； function get(params: any) { return function (target: any, methodName: any, desc: any) { console.log(target); console.log(methodName); console.log(desc); } } class HttpClient { url: string | undefined; constructor() { } @get(&#39;/user&#39;) getData() { console.log(&#39;getData: &#39;, this.url); } } 可以从打印结果看到方法装饰器的三个参数 function get(params:any) { return function(target:any, methodName:any, desc:any) { var oldMethod = desc.value; desc.value = function(...args:any[]) { let newArgs = args.map((item)=&gt;{ return String(item); }); oldMethod.apply(this, newArgs); } } } class HttpClient { constructor() { } @get(&#39;http://baidu.com&#39;) getData(...args:any[]) { console.log(&#39;getData: &#39;, args); } } var http = new HttpClient(); http.getData(1, 2, true); // getData: [&quot;1&quot;, &quot;2&quot;, &quot;true&quot;] 9.4 参数装饰器参数装饰器表达式会在运行时被调用，可以为类的原型增加一些元素数据，传入3个参数： 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象； 方法名称，如果装饰的是构造函数的参数，则值为undefined 参数在函数参数列表中的索引； function logParams(params:any) { return function(target:any, methodName:any, paramIndex:any) { console.log(target) // { constructor:f, getData:f } console.log(methodName) // getData console.log(paramIndex) // 0 } } class HttpClient { constructor() { } getData(@logParams(&#39;uuid&#39;) uuid:any) { console.log(uuid); } } 参数装饰器只能用来监视一个方法的参数是否被传入 9.5 装饰器执行顺序多个装饰器同时装饰到一个声明上，语法支持从左到右，或从上到下书写； 不同装饰器的执行顺序：属性装饰器 &gt; 方法装饰器 &gt; 参数装饰器 &gt; 类装饰器；","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"Vue组件通信","slug":"Vue组件通信","date":"2020-08-04T13:44:18.572Z","updated":"2020-08-04T13:45:42.022Z","comments":true,"path":"2020/08/04/Vue组件通信/","link":"","permalink":"https://fengjing95.github.io/2020/08/04/Vue组件通信/","excerpt":"","text":"Vue组件间通信Vue中组件的通信方式大致有：父——子、子——父、兄弟之间的通信 父子传值父——子父组件向子组件传值的时候，使用v-bind绑定属性，携带要发送的数据，子组件通过props接收这个数据（要跟属性名相同） Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; &lt;Son :fromFather=&quot;fromFatherM&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFatherM: &quot;父组件的消息&quot;, }; }, }; &lt;/script&gt; 为了容易区分属性名和数据，数据后加了个M，子组件接收数据时要使用这里面的属性名 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, // 接收参数并指定类型 }, data() { return {}; }, }; &lt;/script&gt; 效果如图 子——父子组件向父组件发送数据要通过方法来完成，父组件引用子组件的时候向子组件传递一个方法，子组件通过触发事件向方法中传参来向父组件发行数据 Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; 接收：{{sonData}} &lt;Son :fromFather=&quot;fromFather&quot; @receive=&quot;receiveData&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFather: &quot;父组件的消息&quot;, sonData: &quot;&quot;, }; }, methods: { receiveData(d) { // 接收数据并赋值 this.sonData = d; }, }, }; &lt;/script&gt; 使用@receive绑定事件，子组件发出数据时需要向这个绑定事件提交 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;input type=&quot;text&quot; v-model=&quot;fromSon&quot; /&gt; &lt;button @click=&quot;sonHandle&quot;&gt;send&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, }, data() { return { fromSon: &quot;&quot;, }; }, methods: { sonHandle() { this.$emit(&quot;receive&quot;, this.fromSon); // 发送数据的事件 }, }, }; &lt;/script&gt; 效果如图 使用$parent和$children官方文档中还给出了一对API mounted() { console.log(this.$parent.id + &quot;$parent&quot;); }, mounted() { console.log(this.$children[0].id + &quot;$children&quot;); }, 这里一定要注意获取的数组 还可以通过$refs来获取，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 可以获取 上面三种方式的结果如图 兄弟组件兄弟组件传值可以借助一个空白组件，如果项目较大，可以使用Vue官方状态管理Vuex，之后会发Vuex的介绍","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"JS正则表达式","slug":"JS正则表达式","date":"2020-08-03T16:26:08.012Z","updated":"2020-08-03T16:32:24.560Z","comments":true,"path":"2020/08/04/JS正则表达式/","link":"","permalink":"https://fengjing95.github.io/2020/08/04/JS正则表达式/","excerpt":"","text":"JS正则表达式创建正则的两种方式： 创建字面量正则表达式，使用//包裹 let reg = /\\w/ 创建正则表达式对象，使用new RegExp() let reg = new RegExp(/\\w/) 选择符 |“I” 左右两边匹配到一个就算是true let str = &#39;张三：010-1568413，李四：020-1586640&#39; let reg = /(010|020)\\-\\d{7,8}/ console.log(reg.test(str)); // true 转义在字符串中\\d和d是一样的 console.log(&#39;\\d&#39; === &#39;d&#39;) // true 在创建字面量的时候直接使用//创建，或者在字符串中转义 let str = &#39;123.abc&#39; let reg = &quot;\\\\d+\\\\.\\\\w+&quot; let reg2 = /\\d+\\.\\w+/ console.log(str.match(reg)); console.log(str.match(reg2)); 边界以^开始，以$结束，可用于检测网址开头和文件后缀 ^开始边界let str = &#39;http:www.easyremember.cn&#39; let reg = /^https?:www\\..+/ console.log(reg.test(str)); // true $结束边界let str = &#39;C://Users/All Users/abc.txt&#39; let str2 = &#39;C://Users/All Users/abc.log&#39; let reg = /\\.txt$/ console.log(reg.test(str)); // true console.log(reg.test(str2)); // false 元字符\\w：所有的字母、数字、下划线 \\W：所有的非数字、字母、下划线 \\d：所有的数字 \\D：所有的非数字 \\s：所有的空白字符，换行、空格等 \\S：所有的非空白字符 .：除换行以外的任意字符 模式修饰符 i：不区分大小写 g：全局匹配 y：从lastIndex开始匹配 u：处理UTF-16编码字符 m：多行处理 s：单行处理，忽略换行符 原子表 原子表 说明 [] 只匹配其中的一个原子 [^] 只匹配”除了”其中字符的任意一个原子 [0-9] 匹配0-9任何一个数字 [a-z] 匹配小写a-z任何一个字母 [A-Z] 匹配大写A-Z任何一个字母 Tips:\\d == [0-9] \\D == [^0-9] 原子组使用（）包裹 引用分组：引用之前原子组匹配到的内容，\\1\\2…… let str = &#39;abc123.c123&#39; let reg = /([a-z]\\d+)\\.\\1/g console.log(str.match(reg)); // [&quot;c123.123&quot;] 分组别名 为不同分组命名，使用?&lt;&gt;命名，使用$&lt;&gt;引用 let str = &#39;abc123.c123&#39; let reg = /(?&lt;init&gt;[a-z]\\d+)\\.\\1/g // console.log(str.match(reg)); console.log(str.replace(reg, `&lt;p&gt;$&lt;init&gt;&lt;/p&gt;`)); 重复+：重复一次或多次 *：重复零次或多次 ?：重复零次或一次 {n}：重复n次 {n,}：重复n次或更多次 {n,m}：重复n次到m次 let str = &#39;1234&#39; let reg = /\\d/ let reg2 = /\\d+/let reg3 = /^\\d{1,2}$/ console.log(str.match(reg)); console.log(str.match(reg2)); console.log(reg3.test(str)); 字符方法search返回要搜索内容的索引，没有返回-1 let str = &#39;abcdef&#39; console.log(str.search(&#39;ef&#39;));// 4 console.log(str.search(/\\w/)); // 0 console.log(str.search(&#39;efg&#39;)); // -1 match使用字符串或者正则表达式匹配，返回匹配的内容，匹配不到返回null let str = &#39;abcdef&#39;console.log(str.match(&#39;ef&#39;)); // ef console.log(str.match(/\\w+/)); // abcdef matchAll：返回一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` for (let s of str.matchAll(reg)) { console.log(s); } split：使用字符分割字符串 let str = &#39;abc/def/123&#39; console.log(str.split(&#39;/&#39;)); // [&quot;abc&quot;,&quot;def&quot;,&quot;123&quot;] replace替换字符为 let str = &#39;abc/def/123&#39; console.log(str.replace(/\\W/g, &#39;-&#39;)); // abc-def-123 正则方法test检测字符串是否符合要求，返回值是一个布尔值 exec不使用全局匹配与match相同，使用全局匹配会匹配完全部字符串，返回结果是一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` console.log(reg.exec(str)); console.log(reg.exec(str)); 断言?=exp相当于if，但是是后置的例如 &lt;main&gt; 中国努力建设有中国特色社会主义&lt;/main&gt; &lt;script type=&quot;text/javascript&quot;&gt; let reg = /中国(?=特色)/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) &lt;/script&gt; ?&lt;=exp前置断言 let reg = /(?&lt;=有)中国/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) 效果跟前面的?=效果是一样的 ?!exp后面不能出现exp匹配到的内容 ?&lt;!exp前面不能出现exp匹配到的内容","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"let、const和var的区别","slug":"let、const和var","date":"2020-08-02T11:09:59.170Z","updated":"2020-08-02T11:11:39.247Z","comments":true,"path":"2020/08/02/let、const和var/","link":"","permalink":"https://fengjing95.github.io/2020/08/02/let、const和var/","excerpt":"","text":"let、const和var作用域var作用于全局，先来看一个例子 for (var i = 0; i &lt; 5; i++) { var a = 1; } console.log(a, i); // 1 5 跳出了for循环之外a依旧可以访问，用于控制循环的i也能够访问，i=5循环跳出，所以i是5 再来看一下把var改成const for (var i = 0; i &lt; 5; i++) { const a = 1; } console.log(a, i); // Uncaught ReferenceError: a is not defined 这时a是块级作用域，除了循环之后就访问不到了，再来看i，把i改成const声明 Uncaught TypeError: Assignment to constant variable. const属于常量，赋值之后不能改变，这里应该用let，let是变量 重复声明var b = 1; var b = 2; console.log(b); // 2 用var可以重复声明，再来试一下const const b = 1; const b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 可以看出const不可以重复声明，再来试一下let let b = 1; let b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 由此可以看出，const和let不可以重复声明 总结cosnt和let是ES6新出的块级作用域，不可以重复声明，此外 const b; b = 2; console.log(b); // Uncaught SyntaxError: Missing initializer in const declaration const不可以先声明后赋值，let可以 上面说到const不可以重新赋值，有一种情况例外 const b = { a: &#39;a&#39; }; b.a = &#39;b&#39;; console.log(b); 来看一下结果 可以看到值已经发生了改变","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Less预编译使用","slug":"Less预编译","date":"2020-08-02T06:11:51.895Z","updated":"2020-08-02T06:13:59.998Z","comments":true,"path":"2020/08/02/Less预编译/","link":"","permalink":"https://fengjing95.github.io/2020/08/02/Less预编译/","excerpt":"","text":"less预编译1 初见lessless是一门向后兼容的 CSS 扩展语言。 HTML标签不能直接识别less样式，需要引入less.js来编译 引入样式文件 &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt; 引入编译脚本 &lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 但是，这种方式是运行时编译，不是预编译，在VSCode插件商店中搜索less下载对应的编译插件 每次保存less文件时就可以自动编译出css文件 2 less语法2.1 注释less有两种注释 常规的css注释 /* 可见注释，会被编译到css文件中 */ 编译后不可见注释 // 不可见注释，不会被编译到css文件中 2.2 变量使用@符号声明变量，样式中可以引用，less的变量都是块级作用域，直接上代码，一目了然 less块级作用域：首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承 @width: 10px; @height: @width + 10px; .box { width: @width; height: @height; } 编译结果为 属性名和选择器也可以用变量，但是在引用的时候需要用 {}包裹起来，上代码 @width: 10px; @height: @width + 10px; @m: margin; @selector: #nav; .box { @{m}: 10px; width: @width; height: @height; } @{selector} { color: red; } 来看下编译后的，属性和选择器引用很少使用 变量延迟加载 .over { @var: 1; .three { @var: 2; brass: @var; @var: 3; } one: @var; } one属性是在over作用域中的，跟brass无关，所以one的值是1；在brass作用域中，要等变量先加载完再引用，这就是延迟加载，所以three的值是3 2.3 嵌套前面的代码已经能够体现嵌套规则了，可以根据HTML的层级关系来嵌套css样式，伪类选择器也是可以嵌套的 .box { width: @width; height: @height; background-color: pink; :hover { background-color: deeppink; } } 编译结果是这样的 注意这里多了一个空格，这样是不生效的，那怎么样去掉这个空格呢，使用&amp;取消父子关系，让两个类挨在一起 .box { width: @width; height: @height; background-color: pink; &amp;:hover { background-color: deeppink; } } 再来看结果 空格没了 2.3.1 @嵌套和冒泡@ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变 例如 .component { width: 600px; @media (min-width: 768px) { width: 300px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } @media (min-width: 1280px) { width: 800px; } } 这段代码在component类中嵌套了三个媒体查询，编译之后media会编译到最外层 2.4 混合2.4.1 混合混合就是将一系列属性从一个规则集引用到另一个规则集的方式，简单来说已定义的类可以在另一个类中进行引用 .border { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 结果 引用混合的时候，混合没有参数时，括号可以加也可以不加；混合需要使用默认参数时，括号必须加 2.4.2 不编译的混合如果只想定义一个混合，在选择其后面加一个括号，那么这个混合不会被编译 .border() { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 编译结果只有.border-2这个类 2.4.3 带参数的混合类似于js定义方法一样接收参数，然后进行编译（但是，他不叫函数，叫混合） .bar(@w, @h, @color) { width: @w; height: @h; color: @color; } .nav-bar { .bar(100px, 200px, #409eff); } 在引用bar的时候将参数填入，然后进行编译 可以设置参数的默认值，可以传递命名参数 .bar(@w: 10px, @h:10px, @color:green) { width: @w; height: @h; color: @color; } .nav-bar { .bar(@color: #409eff); } 结果 当引用混合的时候不加任何参数就会全部使用默认值 2.4.4 匹配模式根据标识匹配混合，下面定义了4种样式，分别是上右下左边框 .border-style(@_, @w, @h, @c) { border-style: solid; } .border-style(T, @w, @h, @c) { width: @w; height: @h; border-color: @c transparent transparent transparent; } .border-style(R, @w, @h, @c) { width: @w; height: @h; border-color: transparent @c transparent transparent; } .border-style(B, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent @c transparent; } .border-style(L, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent transparent @c; } .border-3 { .border-style(B, 100px, 100px, #000); } 匹配效果如图 注意代码开始的地方 .border-style(@_, @w, @h, @c) { border-style: solid; } 这一段，@_用来匹配L、R、B、T标识，每次使用匹配模式时自动带上这段公共代码 2.4.5 @arguments@arguments包含传进来的所有参数 .border_arg(@w:30px,@c:red,@sty:solid){ border:@arguments; } .test_arguments{ .border_arg(); } 结果如图 2.5 运算 算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。计算的结果以最左侧操作数的单位类型为准。如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px 到 cm 或 rad 到 % 的转换 @color: #224488 / 2; //结果是 #112244 background-color: #112244 + #111; // 结果是 #223355,#111-&gt;#111111 2.6 转义当需要引入无效的CSS语法或Less不能识别的字符，就需要使用转义字符，在字符串前面加一个 ~，并将需要转义的字符串放在 “” 中 @min768: ~&quot;(min-width: 768px)&quot;; .element { @media @min768 { color: pink; } } // 结果 @media (min-width: 768px) { .element { color: pink; } } 在需要使用cacl()的时候less会自动编译括号里面的东西 使用转义来避免自动编译 .no { height: 100 +20px; width: ~&quot;cacl(200px + 20)&quot;; } 2.7 映射 Less 3.5 版本开始，可以将混合和规则集作为一组值的映射（map）使用 #colors() { primary: blue; secondary: green; } .button { color: #colors[primary]; border: 1px solid #colors[secondary]; } // 结果 .button { color: blue; border: 1px solid green; } 2.8 导入less文件导入可以省略后缀名 @import &quot;main&quot;; // mian.less @import &quot;style.css&quot;; 2.9 继承使用extend函数继承一个类 .middle { margin: 0 auto; } .footer:extend(.middle) { color: pink; } 编译之后的middle类将会变成两个类公共部分，用逗号连接","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"https://fengjing95.github.io/tags/css/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"动态控制输入框数量","slug":"动态控制输入框","date":"2020-08-01T14:00:17.672Z","updated":"2020-08-01T14:01:28.214Z","comments":true,"path":"2020/08/01/动态控制输入框/","link":"","permalink":"https://fengjing95.github.io/2020/08/01/动态控制输入框/","excerpt":"","text":"动态控制输入框在开发中经常会遇到根据情况动态控制输入框的情况，以前都是使用UI框架提供的组件，这次自己动手完成了一个简易的动态输入框 先来上效果 正片开始 加减号使用fontawesome的图标不多做赘述 先来看一下标签 &lt;div id=&quot;upload-problem-outin&quot; v-for=&quot;(item, index) in problem.sample&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.inputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输入样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.outputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输出样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;/div&gt; problem.sample是problem对象中的样例相关部分，格式如下 sample: [{ inputSample: &#39;&#39;, outputSample: &#39;&#39; }], 通过v-for遍历sample数组来渲染样例组数，通过数据绑定，控制sample数组的内容来实现样例组数的渲染 再来看一下控制的方法 addSample() { this.problem.sample.push({ inputSample: &#39;&#39;, outputSample: &#39;&#39; }) }, subSample() { if(this.problem.sample.length &lt; 2) { alert(&#39;至少保留一组&#39;) return } this.problem.sample.pop() } 触发增加事件时向原数组追加一个sample对象，触发减少事件时丢掉最后一项，智力有一个判断，即样例数不能少于1 大功告成","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue绑定不到组件","slug":"Vue子路由常见的问题","date":"2020-08-01T10:38:09.001Z","updated":"2020-08-01T10:39:27.068Z","comments":true,"path":"2020/08/01/Vue子路由常见的问题/","link":"","permalink":"https://fengjing95.github.io/2020/08/01/Vue子路由常见的问题/","excerpt":"","text":"Vue子路由常见的问题之前在进行开发的时候遇到了一个很玄学的问题，有一个页面需要设置二级路由，在设置二级路由之后浏览器却出现了报错 路由设置如下 报错信息 在查阅了相关资料之后找到了一种解决办法，component改为conponents 虽然没搞明白原理，先试试再说，浏览器正常不报错，但是！！！ 组件也没加载出来，TnT，这啥啊，治标不治本 然后我发现了这个 由于vue-router版本升级的原因需要手动添加.default来加载组件 原因如下 还有种方法 { path: &#39;back&#39;, name: &#39;back&#39;, component: resolve =&gt; require([&#39;@/components/Admin/Back&#39;], resolve), } 我试了下，我试了下这种方式也没问题，resolve是require的回调 还找到了一种说法 require 是 CommonJS 的模块导入方式，而组件定义时写的 export default 是 ES6 方式，因此require 导入的结果其实是一个含 default 属性的对象，所以 vue 中 component 用这个会报错，而恰好 vue 的命名视图组件注册用 components ，而官方也说了“如果 router-view 没有设置名字，那么默认为 default”，所以这两个default 正好对应起来，于是像楼主所说加了s就不会报错了。而合理的用法应该是 require(‘xxx.vue’).default 或是用 import","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue刷新页面","slug":"Vue页面刷新方法","date":"2020-07-31T14:14:47.733Z","updated":"2020-07-31T23:18:10.761Z","comments":true,"path":"2020/07/31/Vue页面刷新方法/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/Vue页面刷新方法/","excerpt":"","text":"Vue页面刷新方法在编写提交表单的时候，当表单提交上之后清空当前表单 开始的时候我想的是表单提交成功之后data中表单中有关表单内容的变量重新赋空值，但是这样太过麻烦 偶然间在一篇博客中发现可以通过路由跳转当前路由来清空页面 然后就想着搜集一下有没有其他方法，搜集之后总结在这里了 路由跳转this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.go(0) }) 通过this.$router.go(0)来刷新页面 location.reload()也可以实现刷新页面 但是这样或有一个空白的过程 通过空白组件刷新将上传成功之后的回调修改 this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.replace({ path: &#39;/admin/back&#39;, name: &#39;back&#39; }) }) 然后创建一个新的空白组件back.vue，script部分如下 // 用于刷新页面，没有实际意义 export default { name: &quot;Back&quot;, data() { this.$router.replace({ path: &#39;/admin/uploadProblem&#39;, name: &#39;UploadProblem&#39; }) return { } } } 效果如下，网上说会有路由的改变过程，我没有发现。。。 provide / inject 组合先修改一下app.vue，通过provide传递reload方法 export default { provide() { return { reload: this.reload() } }, name: &quot;Back&quot;, data() { return { isRouterAlive: true } }, methods: { reload() { this.isRouterAlive = false this.$nextTick(function() { this.isRouterAlive = true }) } } } 在需要重新加载的页面通过 inject: [&#39;reload&#39;],接收方法（网上叫它‘注入依赖’），然后就可以在方法中调用 this.reload()","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue点击切换导航栏样式","slug":"Vue点击切换导航栏样式","date":"2020-07-31T06:09:30.441Z","updated":"2020-07-31T06:16:16.925Z","comments":true,"path":"2020/07/31/Vue点击切换导航栏样式/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/Vue点击切换导航栏样式/","excerpt":"","text":"Vue点击切换导航栏样式导航栏内容如下 &lt;div class=&quot;collapse&quot;&gt; &lt;div class=&quot;links&quot;&gt; &lt;router-link v-for=&quot;link in linkLists&quot; :to=&quot;link.links&quot; :key=&quot;link.id&quot; exact&gt;{{link.show}} &lt;/router-link&gt; &lt;/div&gt; 效果如图 感觉太过简单，就想着加一个激活效果，开始想了很多种方法，但是都存着一定的缺陷，偶然间发现了router-link-active这个东西 可以给激活的router-link添加样式，尝试了一下 在links里面添加样式（使用的less预编译） .links { display: flex; margin-right: auto; a { color: #777; margin: 0 10px; } a:hover { color: #409eff; } .router-link-active { color: #409eff; } } 开始我以为完事了，但是却发现无论怎么切换首页一直处于激活状态，我开始面向百度解决问题 然后我发现了exact exact 是一个单独的属性 正确用法是 &lt;router-link to=&quot;/home&quot; active-class=&quot;bianlan&quot; exact&gt;。 这样，只有当路径刚好是 /home 时才会添加 bianlan 类名，而当路径是 /home/something 时则不会（因为不 exact） 在router-link标签中添加exact属性之后效果完美","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"JS递归、闭包、作用域链","slug":"JS递归、闭包、作用域链","date":"2020-07-31T04:14:58.555Z","updated":"2020-08-02T00:42:52.409Z","comments":true,"path":"2020/07/31/JS递归、闭包、作用域链/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/JS递归、闭包、作用域链/","excerpt":"","text":"JS递归、闭包、作用域链递归常规的递归函数function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } } console.log(func(4)); // 24 这是一个非常常见的递归函数，但是有一种情况会使得此方法出现错误。 var func2 = func; func = null; console.log(func2(4)); 将递归函数赋值给一个变量，然后把原函数赋值为null，这时候再调用就会报错 这是因为function属于引用类型，赋值时通过指针指向原函数，原函数发生改变，调用时就会出错 使用callee在上面的情况下，使用arguments.callee就可以解决，arguments.callee是一个指向正在执行函数的指针，将经典递归做以下改动 function func(number) { if (number &lt;= 1) { return 1; } else { return number * arguments.callee(number - 1); } } console.log(func(4)); //24 使用指针进行递归，无论怎么调用函数都不会出错，但是，在严格模式下使用arguments.callee会报错 命名函数表达式以上两种方法都存在这不同程度的缺陷，使用命名函数表达式可以达到指针的效果，亦可以同时运行在严格模式和非严格模式下 var func2 = (function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } }); var func3 = func2; func2 = null; console.log(func3(4)); 这时依旧可以正常显示结果 闭包 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 上面的递归最后一种方法就可以理解为一个闭包 闭包与变量经典的示例 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function () { return i; } } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } // 10,10,10,10,10,10,10,10,10,10 乍一看好像是for循环中每次循环将0-9赋值给数组的每一项，其实并不是，因为当前的newArray()正在执行，每个函数作用域链都保存着newArray()的活动对象，所以for循环中每次都是引用的同一个变量i，for循环结束之后，i是10，所以每个函数内部的i都是10。 再将返回i的函数包在一个匿名函数中，就可以达到互不影响的效果 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function (num: number) { return function () { return num; }; }(i) } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } 结果如下 在for循环中,自调用函数立即执行,获取实时地i赋值给num. 循环结束之后,返回result，在自调用函数执行之后，他的作用域就被销毁了，不会再被其他操作影响 this对象// 非严格模式 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return function () { return this.arg; }; } }; console.log(object.getArg()()); //window 为什么结果会是window呢，来看一下最后一行 // object.getArg()()相当于 var val = object.getArg(); val(); 把getArg返回的方法赋值给了val变量，然后执行函数。因为val在全局中，所以获得的arg是全局中的arg还有一种情况会出现问题 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return this.arg; } }; object.getArg() // object object.getArg() // object (object.getArg = object.getArg)() // window 第一种方法简单的调用了object的方法；第二种方法引用了object的方法，this对象能够维持；但是第三种是一个赋值语句，赋值语句是有返回值的，也就是等号右边，所以这里引用了方法，但不是object内部而是指向window 从这张图就可以看出赋值语句其实是有返回值的 解决方法 1 传递this指向var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { var _this = this; return function () { return _this.arg; }; } }; console.log(object.getArg()()); 将object的this传递到getArg之内，然后使用这个引用值获取arg 2 箭头函数也就是lambda表达式 var arg: string = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return () =&gt; { return this.arg } } } console.log(object.getArg()()); 箭头函数的一大特点就是不改变this的指向 内存泄漏闭包的缺陷在于会造成内存泄露，当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，比如通过node结点给html元素添加点击事件的时候，当事件添加完之后，存储node结点的变量会一直占用内存，造成内存泄漏 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; 存储divNode的内存将会无法释放也无法使用，怎么解决呢 在添加完事件之后将divNode手动赋值为空 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; divNode = null; 作用域链作用域 作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。 全局作用域一般全局作用域有以下几种情况 最外层函数和最外层函数外面定义的变量拥有全局作用域 所有未直接定义的变量 所有window对象 函数作用域声明在函数内部的变量，函数作用域一般只有代码片段中可以访问，比如函数内部 例如 function func1(a) { var b = a * 2; function func2(c) { console.log(a, b, c); } func2(b * 2); } func1(2) 这段代码中存在3个作用域 全局作用域，标识符func1 作用域func1，标识符a，b，func2 作用域func2，标识符c 作用域链 由多级作用域连续引用形成的链式结果，掌管一切变量的使用顺序： 先在局部找，没有，就延作用域向父级作用域找。 可以向上搜索，但不可以向下搜索 这种一层一层的关系，就是 作用域链 。","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Express+MySQL实现增删查改","slug":"Express+MySQL实现增删查改","date":"2020-07-28T13:56:38.115Z","updated":"2020-07-28T15:51:38.028Z","comments":true,"path":"2020/07/28/Express+MySQL实现增删查改/","link":"","permalink":"https://fengjing95.github.io/2020/07/28/Express+MySQL实现增删查改/","excerpt":"","text":"Express+MySQL实现增删查改现在Node后台开发在网上找到的资料基本都是用的MongoDB数据库，不太容易找到使用MySQL数据库的资料，所以我整理了一下这篇文章，将会讲解如何使用Express和MySQL来实现CRUD 环境搭建生成器可以直接使用Express生成器自动生成Express工程 $ npm install -g express-generator $ express --view=ejs myapp 手动搭建创建一个项目目录$ npm init 新建app.js入口文件 新建router.js路由文件 创建views文件夹，存放EJS模板文件（student.ejs, editStu.ejs） 新建public公共资源 views文件夹命名不可以是别的，会报错 安装第三方模块$ npm install express --save $ npm install mysql --save $ npm install ejs --save 编写代码编写入口文件实例化、模板引擎设置、静态资源、监听 const express = require(&#39;express&#39;); const app = express(); const stuRoute = require(&#39;/router&#39;) // 设置模板引擎 app.set(&quot;view engine&quot;, &quot;ejs&quot;); // 加载静态资源 app.use(express.static(&#39;public&#39;)); // 使用路由 app.use(stuRoute); // 监听 app.listen(3001, () =&gt; { console.log(&#39;启动成功&#39;); }) 编写路由文件const express = require(&#39;express&#39;); const route = express.Router(); const mysql = require(&#39;mysql&#39;); // 配置数据库,连接池模式 var pool = mysql.createPool({ connectionLimit: 10, // 连接数量 host: &#39;localhost&#39;, // 地址 user: &#39;liuhao&#39;, // 数据库用户名 password: &#39;123456&#39;, // 数据可密码 database: &#39;ssmbuild&#39; // 数据库名 }); route.get(&#39;/student&#39;, (req, res) =&gt; { console.log(&quot;/student:&quot;, req.query); const sql = &#39;select * from books where bookName = ?&#39;; let params = [&#39;java&#39;]; // 根据条件查询信息 pool.getConnection(function (err, connection) { if (err) throw err; // not connected! connection.query(sql, params, function (error, results, fields) { connection.release(); console.log(results); // 将数据传到ejs渲染 res.render(&#39;student&#39;, { res: [] }) if (error) throw error; }); }); }) module.exports = route; 效果展示查询结果 数据库数据 这里可以看到数据已经查询成功 本篇主要讲解mysql模块使用，对数据渲染不再赘述另外修改删除修改一下sql语句和params参数即可，开发时数据库部分一般会单独作为一个模块进行封装 现在大部分开发一般是返回json数据，后期会再进行记录","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"express","slug":"express","permalink":"https://fengjing95.github.io/tags/express/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"思途实训day5","slug":"STDay 5","date":"2020-07-26T13:40:01.320Z","updated":"2020-07-28T14:13:30.586Z","comments":true,"path":"2020/07/26/STDay 5/","link":"","permalink":"https://fengjing95.github.io/2020/07/26/STDay 5/","excerpt":"","text":"Day 5引入js尽量放在body标签的最后，先加载静态标签，再加载js脚本 jQuery表达式必须有分号 jQuery改变元素样式(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); })() click事件$(function () { $(&#39;button&#39;).click(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); }); }); 导航栏颜色修改 &lt;ul id=&quot;nav-ul&quot; onclick=&quot;navHandle()&quot;&gt; &lt;li id=&quot;li1&quot;&gt;首页&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;所有宝贝&lt;/li&gt; &lt;li id=&quot;li3&quot;&gt;每周一上新&lt;/li&gt; &lt;li id=&quot;li4&quot;&gt;生活馆&lt;/li&gt; &lt;li id=&quot;li5&quot;&gt;特惠&lt;/li&gt; &lt;li id=&quot;li6&quot;&gt;礼品区&lt;/li&gt; &lt;/ul&gt; function navHandle() { var nodeId = window.event.target.id; // console.log(node); $(&#39;#&#39; + nodeId).css({ &#39;color&#39;: &#39;#d62cc0&#39; }).siblings().css({ &#39;color&#39;: &#39;#ffffff&#39; }); } siblings()方法返回被选中元素的同级元素 鼠标经过和移出$(function() { $(&#39;#mouse&#39;).mouseenter(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;red&#39; }); }); }); $(function() { $(&#39;#mouse&#39;).mouseleave(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;#409eff&#39; }); }); }); 淡入淡出效果$(function() { $(&#39;.b-f-1&#39;).mouseenter(() =&gt; { $(&#39;#black1&#39;).fadeOut(500); }); }); $(function() { $(&#39;.b-f-1&#39;).mouseleave(() =&gt; { $(&#39;#black1&#39;).fadeIn(300); }); }); 滑动效果slideDown、slideUp $(function() { $(&#39;div&#39;).mouseenter(() =&gt; { $(&#39;div&#39;).slideDown(1000); }); }); $(function() { $(&#39;div&#39;).mouseleave(() =&gt; { $(&#39;div&#39;).slideUp(1000); }); }); 总结今天大概复习了一下jQuery，很多东西都忘了，需要再看一下","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day4","slug":"STDay 4","date":"2020-07-24T11:29:57.687Z","updated":"2020-07-28T14:13:32.824Z","comments":true,"path":"2020/07/24/STDay 4/","link":"","permalink":"https://fengjing95.github.io/2020/07/24/STDay 4/","excerpt":"","text":"Day4旋转+透明度div { width: 150px; height: 150px; border-radius: 50%; overflow: hidden; border: solid 3px #409eff; transition: 0.5s; opacity: 0.5; } div:hover { transform: rotate(200deg); opacity: 1; } 今日收获。。。就是个透明opacity 成果","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day3","slug":"STDay 3","date":"2020-07-24T01:17:51.174Z","updated":"2020-07-28T14:13:34.338Z","comments":true,"path":"2020/07/24/STDay 3/","link":"","permalink":"https://fengjing95.github.io/2020/07/24/STDay 3/","excerpt":"","text":"Day 3HTML标签。。。从0开始的那种。。。 css样式通配符选择器* { margin: 0; list-style: none; /* 去掉list圆点 */ text-decoration: none; /* 去掉下划线 */ } 列表右浮动只给父级不给子级背景图片引入背景图片必须设置高度，否则不显示 .binner { /* no-repeat不平铺 */ background: url(../img/TB183NQapLM8KJjSZFBSutJHVXa.jpg) no-repeat; height: 568px; background-size: 100% auto; /* 图片自适应 */ } 行高等于div高度时自动居中.nav-f { width: 660px; height: 120px; position: absolute; left: 168px; line-height: 120px; } 精灵图使用Photoshop信息面板配合精灵图设置图片 比如这张精灵图 .shopping { width: 30px; height: 30px; background: url(../img/icon.png); background-position: -16px -133px; } 引入图片之后将鼠标移至图标左上角，看到位置是X：16，Y：133，将图片位置设置为-16px,-133px，将图片沿着X轴Y轴移动之后，浏览器会自动根据设置的宽高从起点位置裁切","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"JS异步轮询","slug":"异步轮询","date":"2020-07-23T05:50:43.924Z","updated":"2020-07-23T05:52:50.933Z","comments":true,"path":"2020/07/23/异步轮询/","link":"","permalink":"https://fengjing95.github.io/2020/07/23/异步轮询/","excerpt":"","text":"异步轮询异步先来看一个例子 console.log(&#39;start&#39;) setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;) }, 4000) console.log(&#39;end&#39;) 这段代码的执行顺序是什么，你可能想到的结果是 start setTimeout end 但是，js是单线程的，不会因为一个任务而被阻塞，异步操作将会被放到队列中，等主线程执行完第一轮任务，然后再执行队列中的任务 这里稍微扯一下栈和队列 栈（stack） 栈是一种先进后出的数据结构，可以理解为一个桶，先放进的东西在最低下，后放的东西在最外面，外面的取完了之后才能拿出最先放进去的东西； 队列（queue） 队列是一种先进先出的数据结构，可以看做一个管道，先进的先出，后进的后出 回到正题，上面的例子中setTimeout是一个异步操作，被放到了队列中，当主线程执行完成之后再来执行队列中的任务，所以答案应该是 在js的队列中有两种划分，一种是宏任务（macrotask queue），一种是微任务（microtask queue），每一个事件循环（Event Loop）都有一个微任务，会有一个或多个宏任务，每一次事件循环都会首先执行微任务执行完后从宏任务取出一个加入到微任务然后执行，直至队列中所有的任务执行结束 宏任务 script(整体代码) setTimeout setInterval I/O UI交互事件 postMessage MessageChannel setImmediate(Node.js 环境) 微任务 Promise.then Object.observe MutaionObserver process.nextTick(Node.js 环境) Promise异步原理看完了，下面开始Promise let promise = new Promise((resolve, reject) =&gt; { // resolve(&quot;成功&quot;) // reject(&quot;失败&quot;) }) console.log(promise) 先来看一下Promise对象的结构 当没有任何操作的时候，Promise对象的状态时pending，值是undefinded 当在Promise中调用resolve之后，状态变为resolved，值是成功 当调用reject的时候，状态变为rejected，值是失败 pending就是未决，resolve可以理解为成功，reject可以理解为拒绝 Promise的状态是不可逆的，resolve和reject同时出现，先执行的决定状态，后执行的不生效 下面这三种方法可以触发Promise.then的错误方法 throw new Error(‘fail’) reject(‘fail’) 错误操作（默认，类似try/catch） 链式调用console.log(&#39;start&#39;) let promise = new Promise((resolve, reject) =&gt; { console.log(&#39;promise&#39;) resolve(&quot;success&quot;) // reject(&quot;faild&quot;) }).then(value =&gt; { console.log(value+1) return value }, reason =&gt; { console.log(reason) }).then(value =&gt; { console.log(value+2) }, reason =&gt; { console.log(reason) }) console.log(&#39;end&#39;) 打印结果为 Promise会将返回值作为.then()的参数传递下去，而且两个.then是在主线程执行完成之后才执行的，这里被放到了微任务（不是并列的，当执行第一个.then的时候第二个.then才会被放到微任务），如果不调用resolve或者reject，微任务是不创建的 每一个Promise.then也是一个Promise 状态中转let promiseErr = new Promise((resolve, reject) =&gt; { reject(&#39;faild&#39;) }) let promise = new Promise((resolve, reject) =&gt; { resolve(promiseErr) }).then(value =&gt; { console.log(&#39;value:&#39;+value) }, reason =&gt; { console.log(&#39;err:&#39;+reason); }) 这里promise虽然调用了resolve，但是返回的状态却是promiseErr的，所以他的结果是 .then是对它前一个Promise对象的操作 错误捕获这样每一个then都有两个方法，过于繁琐，可以在then中只写成功方法，在最后使用catch方法捕获错误 let promise = new Promise((resolve, reject) =&gt; { resolve() }).then(v =&gt; { console.log(&#39;p1&#39;) throw new Error(&#39;fail&#39;) }).then(v =&gt; { console.log(&#39;p2&#39;) }).catch(err =&gt; { console.log(err) }).then(v =&gt; { console.log(&#39;p3&#39;) }).then(v =&gt; { console.log(&#39;p4&#39;) }) 结果为 有结果可以看出，发生错误的地方到catch之间的代码不会执行，catch返回值也是一个Promise对象 async/await了解了Promise之后，async/await就很容易了，它其实就是Promise的语法糖 async function asyncFunc() { return &quot;asunc&quot; } let result = asyncFunc() console.log(result); 从结果看出，async方法返回的也是一个Promise对象 来看看下面这个例子 function p() { console.log(&#39;p&#39;) } async function func() { await p(); console.log(&#39;OK&#39;) } console.log(&#39;start&#39;) func() console.log(&#39;end&#39;) // start // p // end // OK 用知乎上看到过一个例子来解释，可以将 async function func() { await p(); console.log(&#39;OK&#39;) } 理解为 function func() { return Promise.resolve(p()).then(() =&gt; { console.log(&#39;OK&#39;) }) } console.log(‘OK’)被分配到微任务中等待下一轮轮询 来看一个综合案例 async function async1() { console.log(&#39;async1 start&#39;) await async2() console.log(&#39;async1 end&#39;) } async function async2() { console.log(&#39;async2&#39;) } console.log(&#39;script start&#39;) setTimeout(function () { console.log(&#39;settimeout&#39;) }) async1() new Promise(function (resolve) { console.log(&#39;promise1&#39;) resolve() }).then(function () { console.log(&#39;promise2&#39;) }) console.log(&#39;script end&#39;) 输出结果是 script start async1 start async2 promise1 script end async1 end promise2 settimeout 你做对了么(๑´ㅂ`๑)","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"JS中的闭包","slug":"闭包","date":"2020-07-23T05:28:46.515Z","updated":"2020-07-23T05:36:52.742Z","comments":true,"path":"2020/07/23/闭包/","link":"","permalink":"https://fengjing95.github.io/2020/07/23/闭包/","excerpt":"","text":"​ 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 相信你看了这段鬼话，80%会感到懵逼，看完下面的内容再回来看这句话，相信你就可以理解了。 函数的作用域 在全局环境中定义了title变量和show方法，当执行show方法时，开辟出一块内存，如果在show方法内部调用context是可以正常执行的，当show执行完的时候，show中定义的context变量不被保留，这时外部调用context就会 not defined。 数据的作用默认就是在函数体内 数据向下流动，只会向子级传递，不会向父级传递 当show方法执行完之后，内存被释放，执行多个show方法相当于多次开辟了内存 如果在show方法中再定义一个head方法，再执行，此时的内存结构如图所示，head方法时show方法内部的，show执行时为head开辟一块内存；那多次调用show方法会一直调用那一个head方法么？不是的！！！多次调用show方法会开辟多块内存，他们之间是没有关系的。 这个例子更能清楚的说明，按照常理，第一次调用++n之后变成了2，但是这里第二次调用结果还是2，这就说明了两次调用创建了两次 那么怎么让n一直被使用呢，这时你应该想起来开头有一句话 但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 当数据一直被使用时就会保留下来，那么怎么让他一直被使用呢？ 将sum方法作为返回值赋值给a，这时候，feng中的数据就会一直被使用，直到a销毁，这时候多次调用a方法，n就会累加 如果再赋值给b，这就又开辟了一块内存，与a无关n又重新开始计算，结果如下： 这时候你又想起了开头还有一句话： 每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址 如果在sum中在添加一个function，这样再执行两次a结果是什么呢？ 你没有看错，其实很简单，这跟之前一样，相当于在a中开辟了两块不相关的内存，那么怎么让m累加呢？也很简单，再把show返回出去 这时再创建b，打印结果依旧是2 3 2 3 利用闭包选择数组区间 由于过滤函数一直在调用between的子函数，所以a，b也被保留了下来 闭包会造成内存泄漏 这段代码的意思是点击div会触发打印descript属性，因为事件处理函数是一直存在的，所以每个item在使用完成之后都会保存，而且都是不同的内存区域，对于复杂对象来说是非常浪费内存的 那么怎么解决闭包带来的内存泄漏呢 在使用完之后给item项赋空值 这样就可以解决不必要的内存浪费","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"思途实训day2","slug":"STDay 2","date":"2020-07-22T08:57:04.870Z","updated":"2020-07-28T14:13:35.489Z","comments":true,"path":"2020/07/22/STDay 2/","link":"","permalink":"https://fengjing95.github.io/2020/07/22/STDay 2/","excerpt":"","text":"Day 2字体选择： 中文：微软雅黑， 宋体，黑体 英文：arial 字体大小： 网页最小字号：12px， 不重要信息 一般用的最小字号：14px 精确抠图解锁原背景，新建图层填充鲜艳的颜色，例如绿色 用魔棒工具选择背景色，调整容差值，右键选择【调整边缘】 调整参数 菱形方格 制作一个这样的菱形方格 用矩形工具选择一个矩形框填充一个颜色，【ctrl】+【T】自由变换，按住shift旋90度 在图层调节描边，内阴影和投影 就可以看到效果图中的样式 图层蒙版将要贴入的图片拖拽至目标图层上方 注意在图层区域要将两图层放在一起 左上角有自动选择，点一下就可以定位图层 在两图层之间按住【alt】+鼠标左键 图层区会变成 显示的样式就会变成 图标绘制 锚点工具使用 首先利用椭圆工具绘制黄色圆形，然后复制两份 利用圆角矩形工具绘制蓝色矩形，绘制完成之后按【A】键选中元素出现锚点，按住【ctrl】用鼠标拖拽锚点成为一个梯形 在梯形内绘制三个圆角矩形，填充背景色构造成镂空的感觉 绘制底座，使用圆角矩形，使用锚点工具选择右上角两个点，【delete】，然后将描边改为白色 使用钢笔工具绘制上面的把手，钢笔工具点击一个点，再点第二个点不要松手，调整弧度至合理，使用上面底座相同的配置即可 钢笔工具在使用的时候如果出现角度很别扭的时候，可以在上一个点调好之后不松手，按住【alt】鼠标移动调节手柄 切图将所有的背景色全部隐藏，用切片工具画出切片区域，存储为web格式","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day1","slug":"STDay 1","date":"2020-07-22T07:27:01.446Z","updated":"2020-07-28T14:13:13.761Z","comments":true,"path":"2020/07/22/STDay 1/","link":"","permalink":"https://fengjing95.github.io/2020/07/22/STDay 1/","excerpt":"","text":"Day 1PhotoShop操作快捷键 图层复制：【Ctrl】+【J】 自由变换：【Ctrl】+【T】 画笔工具：【B】，画笔调节：粗——右中括号，细——左中括号 放大：【ctrl】+【space】，缩小：【ctrl】+【alt】+【space】，抓手：【space】 盖印：【ctrl】+【alt】+【shift】+【e】 首选项：【ctrl】+【k】 填充前景色：【alt】+【delete】，填充背景色：【ctrl】+【delete】 移动工具：【v】 编组：【ctrl】+【g】 制作大头像调节图层素材图片 1 复制一个图层（可使用ctrl+j，也可以拖拽图层到下方的新建图层图标） 2 ctrl+t自由变换图层，缩放到合适的比例（按住shift等比缩放） 3 调节新图层透明度，50%-60%合适 4 将两图层下巴对齐 5 在小图层上新建蒙版 6 用黑色画笔将大图层头部涂黑，涂完之后将不透明度调至100%，如果有多余部分使用白色画笔涂回去（硬度调为0） 7 使用裁切工具只保留需要的部分，盖印生成图层 成果图如下 图层修饰 滤镜中点开液化 使用膨胀工具在两眼位置分别点击两下将眼部放大 使用褶皱工具将鼻子和嘴缩小 使用左推工具将脸收一下 如果拖坏了可以使用重建工具将要恢复的地方涂一下 GIF制作窗口打开时间轴，新建帧动画 在图层中控制要显示的帧然后添加关键帧 调节每一帧的时间 导出：存储为web格式，调节为GIF格式 网页设计项目立项——分析市场环境——解决用户痛点 仿照图 自己做的设计图： 渐变色：在选区内添加渐变图层，否则会使整个背景全部渐变 选择多个图层：选中第一个图层，按住shift选中最后一个图层 要选中某一图层的某一部分：先用多边形框选工具选出大致部分，然后ctrl+alt+shift+点击要选中部分的图层","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"Typora图片自动上传到图床","slug":"Typora图片自动上传到图床","date":"2020-07-15T11:50:22.787Z","updated":"2020-07-15T13:53:48.283Z","comments":true,"path":"2020/07/15/Typora图片自动上传到图床/","link":"","permalink":"https://fengjing95.github.io/2020/07/15/Typora图片自动上传到图床/","excerpt":"","text":"Typora图片自动上传到图床你是否还在为找不到可靠的图床而烦恼 是否害怕图床网站关闭资源丢失 是否担心资源不能管理而发愁 今天他来了 1 下载安装picGo地址在这里，根据需要的版本进行下载 下载完成后进行安装 安装完之后在桌面右下角图标打开picGo详细界面 2 配置picGo图床+giteepicGo支持多个图床 这里主要说一下gitee新建一个公开的仓库，私有的在相册和Typora无法显示 搜索插件gitee（需要安装Node环境） 据说是两个都可以，我只试过了gitee，安装好之后在上面的图床列表里就会出现gitee图床 这里是配置信息 owner：gitee用户名 repo：gitee仓库名 path：路径，存放到根目录可以不用写 token：gitee个人令牌 message：可以不写 关于gitee个人令牌的获取 点开gitee的设置，在左侧栏找到私人令牌，然后点击生成新令牌 描述可以随便写一下，然后点击确认会生成一个token 将token复制到picGo中就可以了 3 配置Typora+picGo在Typora的偏好设置中将插入图片改为上传图片，上传服务修改为picGo App，并选择到安装目录 点击验证 如果出现false情况，看一下连接中的端口号，然后到picGo的设置中找到Server服务 将端口号修改一致 然后保存，再试一下验证","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"ES6笔记","slug":"ES6笔记","date":"2020-07-15T07:24:55.780Z","updated":"2020-08-02T06:22:10.833Z","comments":true,"path":"2020/07/15/ES6笔记/","link":"","permalink":"https://fengjing95.github.io/2020/07/15/ES6笔记/","excerpt":"","text":"ES6笔记变量let和constvar存在的问题 可以重复声明 无法限制修改 没有块级作用域 ES6新的定义变量 let 不能重复声明 变量，可以修改 块级作用域 const 不能重复声明 常量，不能修改 块级作用域 最大的区别：const一经定义值不能再变 函数箭头函数let show = function(n1,n2) { return n1-n2; } ----------等价-------------- let show = (n1, n2) =&gt; { return n1-n2; } 如果只有一个参数，()可以省略 let show = (n) =&gt; { return n; } --------省略-------- let show = n =&gt; { return n; } 如果只有一个return，{}可以省略 let show = n =&gt; { return 2*n; } -------省略-------- let show = n =&gt; 2*n; 箭头函数的this不会变：this指向的是当前对象，传统的function需要定义一个const that= this才能在里面的函数访问到最外层的this，箭头函数不会改变this指向，也就是说，无需定义that就可以用this访问原来的对象 箭头函数的优势和劣势 参数...args接收参数 命名随意，但必须放到参数最后，用于收集剩余参数 let show = function (a, b, ...args) { alert(a); alert(b); alert(args); } show(14,2,3,4,5); 多余的参数将会由args接收 展开数组 展开后效果跟直接把数组放在那一样 let arr = [1,2,3,4]; show(...arr);// == show(1,2,3,4) ------------------- let arr1=[1,2,3]; let arr2=[4,5,6]; let arr=[...arr1,...arr2]; // == let arr=[1,2,3,4,5,6]; 默认参数let show = function (a, b=5, c=10) { XXX } show(12); 当传的参数只有一个的时候，b默认是5，c默认是10； 当传参数大于一位时，会依次顶替默认参数 解构赋值左右两边结构必须一样 let [a, b, c] = [1,2,3] let {a,b,c} = {a:1,b:2,c:3} 右边必须合法 声明和赋值不能分开 let [a, b] = [5, 12];// 合法 ------------------------ let [a, b]; [a, b] = [5, 12];// 报错，解构赋值声明和赋值不能分开 数组map映射————一个对一个 let arr = [1, 2, 3, 4]; let result = arr.map(item =&gt; item * 2); // result 2,4,6,8 reduce汇总————一堆出来一个 let arr= [12, 8, 9, 16]; let result = arr.reduce( function (tmp, item, index) { return tmp + item; }) function中的三个参数分别是存储的和的中间数、要计算的数、索引 filter过滤器————保留一部分 let arr = [10,3,16,15,21,20]; let result = arr.filter(item =&gt; { if(item % 3 == 0) { return true; } return false; }); alert(result); -------------------------------- // json类型 let arr = [ {name: &#39;tom&#39;, price: 75}, {name: &#39;jerry&#39;, price: 60} ]; let result = arr.filter(item =&gt; { return item.price&gt;65; }); console.log(result); 当filter中的方法返回true的时候数据保留，返回false数据删除 forEach循环（迭代）————每一项进行操作 吧数组中的每一项都放到方法中执行 字符串两个新方法startsWith 匹配前面的字符串，相同返回true，不相同返回false endWith 匹配末尾的字符串，相同返回true，不相同返回false 应用：检测文件后缀 字符串模板字符串拼接 let a = &#39;AScri&#39;; let str = `ECM${a}pt6`; alert(str); // str=ECMAScript6 注意：插入字符串的字符串要用反单引号（数字键盘1左边的那个） 应用，拼接字符串 let html = `&lt;div&gt; &lt;h1&gt;${title}&lt;/h1&gt; &lt;p&gt;${content}&lt;/p&gt; &lt;/div&gt;`; 优势：直接把字符串插到字符串中；可以折行 面向对象语法class User { constructor(name, age) { this.name = name; this.age = age; } showName() { alert(this.name); } showAge() { alert(this.age); } } var user = new User(&#39;Tom&#39;, 18); user.showName(); user.showAge(); 对象创建关键字class，相当于java的类 构造器关键字constructor，相当java的构造函数 方法直接写在class里面，不需要加function 继承class VipUser extends User { constructor(name, age, level) { super(name, age); this.level = level; } showLevel() { alert(this.level); } } var vip = new VipUser(&#39;Tom&#39;, 18, 3); vip.showName(); vip.showAge(); vip.showLevel(); 继承关键字extens，相当于java的继承 构造函数中使用super关键字，调用父类的构造函数 添加新的属性和新的方法 JSON标准写法 只能用双引号 所有名字都必须用引号括起来 { &quot;a&quot;: &quot;abx&quot;, &quot;b&quot;: 12, &quot;c&quot;: true } 格式化为字符串let json = {a: 11, b: 12}; alert(JSON.stringify(json)); JSON.stringify()得到的结果是一个字符串 格式化为JSONlet str = &#39;{&quot;a&quot;: 11, &quot;b&quot;: 12}&#39;; console.log(JSON.parse(str)); JSON.parse()得到的结果是一个json对象，但是，字符串的内容必须符合json格式标准，另外，双引号的外面是单引号 简写属性名简写 let a = 12; let b = 5; let json = {a, b, c: 15}; console.log(json); 当已经存在的值和json属性名一样的时候，可以只写值，不一样的可以按照json格式添加 这里的json指的是json字面量 方法简写 let json = { a: 12, show() { console.log(this.a); } } json.show(); 方法可以只写方法名，省略 function Promise作用：消除异步操作，用同步的方式来写异步代码 异步：操作之间没啥关系，同时进行多个操作；代码复杂 同步：同时只能做一件事，前面的事没干完后面的事不能开始；代码简单 封装ajax（基于jquery） let ajax = new Promise(function (resolve, reject) { $.ajax({ url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); ajax.then(result =&gt; { alert(result); }, err =&gt; { console.log(err); }) Promise.all()当有两个Promise对象时，可以使用Promisr.all()处理两个Promise对象 Promise.all([ ajax1, ajax2 ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 这里注意，当使用.all处理多个Promise对象时，有一个出错就会报错，全部成功才会执行成功的回调函数 有多个ajax请求不同地址的时候可以，再次封装 function createPromise(url) { return new Promise(function(resolve, reject) { $.ajax({ url, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); } Promise.all([ createPromise(&#39;js/arr.txt&#39;), createPromise(&#39;js/arr2.txt&#39;) ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 以上只是示例，jquery的作者当然想到了这一点，$.ajax()是有返回值的（高版本，低版本可能没有） let p = $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}); 可以将 $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}) 放到Promise.all()里面，代替上面的createPromise方法 Promise.race()同时处理多个Promise对象，有一个先完成的就停止 应用场景，同时向多个负载发送请求 Promise链式调用let test = new Promise((resolve, reject) =&gt; { let random = Math.random() if (random &gt; 0.5) { resolve(&#39;大于0.5&#39;) } else { reject(&#39;小于等于0.5&#39;) } }) let p = test.then((result) =&gt; { console.log(result) return result }).catch((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(&#39;last&#39;, result) }) console.log(p) ------------------------- Promise { &lt;pending&gt; } // p 大于0.5 // 或者小于，下同 大于0.5 last 大于0.5 promise 的 then 方法里面可以继续返回一个新的 promise 对象 下一个 then 方法的参数是上一个 promise 对象的 resolve 参数 catch 方法的参数是其之前某个 promise 对象的 rejecte 参数 一旦某个 then 方法里面的 promise 状态改变为了 rejected，则promise 方法连会跳过后面的 then 直接执行 catch；如果状态一直为fulfilled，catch里面的的代码不执行 catch 方法里面依旧可以返回一个新的 promise 对象 promies的三种状态是未决的pending（进行中），和已决的fulfilled（成功）/rejected（失败），reslove和reject是成功和失败的参数，在promies里调用参数之后then方法才会执行 参考资料： 深入理解Promise三种状态与链式调用 Promise对象then方法链式调用 生成器函数generator 普通函数：一直执行到最后 generator函数：中间可以暂停 function *show() { alert(&#39;1&#39;); yield; alert(&#39;2&#39;); } let obj = show(); obj.next(); obj.next(); 直接运行show()并不会有任何反应，用show来创建一个对象，用next方法可以执行，遇到yield停下，再执行next可以继续运行之后的部分 原理是把一个大函数的代码切分成多个小函数，每next一次执行一次 一个生成器中可以存在多个yield；注意函数命名方式 function *show(){}，带有星号 yield可以传参 第一个next无法传参，可以理解为generator的启动器，第二个next开始向第一个yield传参 function *show() { alert(&#39;1&#39;); let a = yield; alert(a); } let obj = show(); obj.next(); obj.next(10); -------------------------- // 打印结果 a=10 有返回值 function *show() { alert(&#39;1&#39;); let a = yield &#39;axc&#39; + &#39;ac&#39;; alert(a); // 10 // 如果这里return 55，那么下边b1的value就是55 } let obj = show(); let a1 = obj.next(); console.log(a1); // {value: &quot;axcac&quot;, done: false} let b1 = obj.next(10); console.log(b1); // {value: undifind, done: true} 一个yield相当于一个被分解成小函数的return 总结：第一个yield返回的值给了第一个next，第二个next的参数给了第一个yield 附：ES7 async awaitasync function doSome() { try { let data1 = await function(data); let data2 = await function(data1); let data3 = await function(data2); } catch(err) { console.log(&quot;Error:&quot; + err); } } 用同步的方式实现异步 await的返回值是promise；await后面可以用Promise.all()执行多个Promise操作 awat 外面必须包裹着async， 把await和成功后的操作放到try里，失败的放在catch 参考资料： async和await","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"VS Code 快捷键","slug":"VS Code 快捷键","date":"2020-07-14T07:29:20.384Z","updated":"2020-08-13T06:32:58.301Z","comments":true,"path":"2020/07/14/VS Code 快捷键/","link":"","permalink":"https://fengjing95.github.io/2020/07/14/VS Code 快捷键/","excerpt":"","text":"VS Code 快捷键打开一个新窗口 Ctrl+Shift+N 关闭窗口 Ctrl+Shift+W 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 复制或剪切当前行/当前选中内容 Ctrl+C 、 Ctrl+V 代码格式化： Shift+Alt+F 上下移动一行 Alt+Up 或 Alt+Down 向上向下复制一行 Shift+Alt+Up 或 Shift+Alt+Down 在当前行下方插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 移动到行首 Home 移动到行尾 End 移动到文件结尾 Ctrl+End 移动到文件开头 Ctrl+Home 移动到定义处 F12 定义处缩略图 只看一眼而不跳转过去 Alt+F12 找到所有的引用 Shift+F12 同时修改本文件中所有匹配的 Ctrl+F12 重命名 比如要修改一个方法名，可以选中后按 F2，输入新名字，回车，则所有该方法的引用也都同步更新了 跳转到下一个 Error 或 Warning 当有多个错误时可以按 F8 逐个跳转 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-14T07:29:20.383Z","updated":"2020-07-15T09:59:41.550Z","comments":true,"path":"2020/07/14/hello-world/","link":"","permalink":"https://fengjing95.github.io/2020/07/14/hello-world/","excerpt":"","text":"2020-07-13 博客诞生","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://fengjing95.github.io/tags/hello/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]}]}