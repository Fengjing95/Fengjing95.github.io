{"meta":{"title":"前端小枫","subtitle":"","description":"","author":"小枫","url":"https://fengjing95.github.io"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"about/index.html","permalink":"https://fengjing95.github.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-07-13T12:13:10.593Z","comments":false,"path":"bangumi/index.html","permalink":"https://fengjing95.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"client/index.html","permalink":"https://fengjing95.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-07-13T12:13:10.594Z","comments":true,"path":"comment/index.html","permalink":"https://fengjing95.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-07-13T12:13:10.595Z","comments":true,"path":"links/index.html","permalink":"https://fengjing95.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-07-13T12:13:10.594Z","comments":false,"path":"donate/index.html","permalink":"https://fengjing95.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-07-13T12:13:10.595Z","comments":false,"path":"lab/index.html","permalink":"https://fengjing95.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-13T12:13:10.596Z","comments":false,"path":"music/index.html","permalink":"https://fengjing95.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"rss/index.html","permalink":"https://fengjing95.github.io/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://fengjing95.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-13T12:13:10.596Z","comments":true,"path":"tags/index.html","permalink":"https://fengjing95.github.io/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-07-13T12:13:10.597Z","comments":false,"path":"video/index.html","permalink":"https://fengjing95.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Vue组件通信","slug":"Vue组件通信","date":"2020-08-04T13:44:18.572Z","updated":"2020-08-04T13:45:42.022Z","comments":true,"path":"2020/08/04/Vue组件通信/","link":"","permalink":"https://fengjing95.github.io/2020/08/04/Vue组件通信/","excerpt":"","text":"Vue组件间通信Vue中组件的通信方式大致有：父——子、子——父、兄弟之间的通信 父子传值父——子父组件向子组件传值的时候，使用v-bind绑定属性，携带要发送的数据，子组件通过props接收这个数据（要跟属性名相同） Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; &lt;Son :fromFather=&quot;fromFatherM&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFatherM: &quot;父组件的消息&quot;, }; }, }; &lt;/script&gt; 为了容易区分属性名和数据，数据后加了个M，子组件接收数据时要使用这里面的属性名 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, // 接收参数并指定类型 }, data() { return {}; }, }; &lt;/script&gt; 效果如图 子——父子组件向父组件发送数据要通过方法来完成，父组件引用子组件的时候向子组件传递一个方法，子组件通过触发事件向方法中传参来向父组件发行数据 Father.vue &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h2&gt;Father&lt;/h2&gt; 接收：{{sonData}} &lt;Son :fromFather=&quot;fromFather&quot; @receive=&quot;receiveData&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from &quot;@/components/Son&quot;; export default { components: { Son, }, data() { return { fromFather: &quot;父组件的消息&quot;, sonData: &quot;&quot;, }; }, methods: { receiveData(d) { // 接收数据并赋值 this.sonData = d; }, }, }; &lt;/script&gt; 使用@receive绑定事件，子组件发出数据时需要向这个绑定事件提交 Son.vue &lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;h2&gt;Son&lt;/h2&gt; 接收：{{fromFather}} &lt;input type=&quot;text&quot; v-model=&quot;fromSon&quot; /&gt; &lt;button @click=&quot;sonHandle&quot;&gt;send&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { fromFather: String, }, data() { return { fromSon: &quot;&quot;, }; }, methods: { sonHandle() { this.$emit(&quot;receive&quot;, this.fromSon); // 发送数据的事件 }, }, }; &lt;/script&gt; 效果如图 使用$parent和$children官方文档中还给出了一对API mounted() { console.log(this.$parent.id + &quot;$parent&quot;); }, mounted() { console.log(this.$children[0].id + &quot;$children&quot;); }, 这里一定要注意获取的数组 还可以通过$refs来获取，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 可以获取 上面三种方式的结果如图 兄弟组件兄弟组件传值可以借助一个空白组件，如果项目较大，可以使用Vue官方状态管理Vuex，之后会发Vuex的介绍","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"JS正则表达式","slug":"JS正则表达式","date":"2020-08-03T16:26:08.012Z","updated":"2020-08-03T16:32:24.560Z","comments":true,"path":"2020/08/04/JS正则表达式/","link":"","permalink":"https://fengjing95.github.io/2020/08/04/JS正则表达式/","excerpt":"","text":"JS正则表达式创建正则的两种方式： 创建字面量正则表达式，使用//包裹 let reg = /\\w/ 创建正则表达式对象，使用new RegExp() let reg = new RegExp(/\\w/) 选择符 |“I” 左右两边匹配到一个就算是true let str = &#39;张三：010-1568413，李四：020-1586640&#39; let reg = /(010|020)\\-\\d{7,8}/ console.log(reg.test(str)); // true 转义在字符串中\\d和d是一样的 console.log(&#39;\\d&#39; === &#39;d&#39;) // true 在创建字面量的时候直接使用//创建，或者在字符串中转义 let str = &#39;123.abc&#39; let reg = &quot;\\\\d+\\\\.\\\\w+&quot; let reg2 = /\\d+\\.\\w+/ console.log(str.match(reg)); console.log(str.match(reg2)); 边界以^开始，以$结束，可用于检测网址开头和文件后缀 ^开始边界let str = &#39;http:www.easyremember.cn&#39; let reg = /^https?:www\\..+/ console.log(reg.test(str)); // true $结束边界let str = &#39;C://Users/All Users/abc.txt&#39; let str2 = &#39;C://Users/All Users/abc.log&#39; let reg = /\\.txt$/ console.log(reg.test(str)); // true console.log(reg.test(str2)); // false 元字符\\w：所有的字母、数字、下划线 \\W：所有的非数字、字母、下划线 \\d：所有的数字 \\D：所有的非数字 \\s：所有的空白字符，换行、空格等 \\S：所有的非空白字符 .：除换行以外的任意字符 模式修饰符 i：不区分大小写 g：全局匹配 y：从lastIndex开始匹配 u：处理UTF-16编码字符 m：多行处理 s：单行处理，忽略换行符 原子表 原子表 说明 [] 只匹配其中的一个原子 [^] 只匹配”除了”其中字符的任意一个原子 [0-9] 匹配0-9任何一个数字 [a-z] 匹配小写a-z任何一个字母 [A-Z] 匹配大写A-Z任何一个字母 Tips:\\d == [0-9] \\D == [^0-9] 原子组使用（）包裹 引用分组：引用之前原子组匹配到的内容，\\1\\2…… let str = &#39;abc123.c123&#39; let reg = /([a-z]\\d+)\\.\\1/g console.log(str.match(reg)); // [&quot;c123.123&quot;] 分组别名 为不同分组命名，使用?&lt;&gt;命名，使用$&lt;&gt;引用 let str = &#39;abc123.c123&#39; let reg = /(?&lt;init&gt;[a-z]\\d+)\\.\\1/g // console.log(str.match(reg)); console.log(str.replace(reg, `&lt;p&gt;$&lt;init&gt;&lt;/p&gt;`)); 重复+：重复一次或多次 *：重复零次或多次 ?：重复零次或一次 {n}：重复n次 {n,}：重复n次或更多次 {n,m}：重复n次到m次 let str = &#39;1234&#39; let reg = /\\d/ let reg2 = /\\d+/let reg3 = /^\\d{1,2}$/ console.log(str.match(reg)); console.log(str.match(reg2)); console.log(reg3.test(str)); 字符方法search返回要搜索内容的索引，没有返回-1 let str = &#39;abcdef&#39; console.log(str.search(&#39;ef&#39;));// 4 console.log(str.search(/\\w/)); // 0 console.log(str.search(&#39;efg&#39;)); // -1 match使用字符串或者正则表达式匹配，返回匹配的内容，匹配不到返回null let str = &#39;abcdef&#39;console.log(str.match(&#39;ef&#39;)); // ef console.log(str.match(/\\w+/)); // abcdef matchAll：返回一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` for (let s of str.matchAll(reg)) { console.log(s); } split：使用字符分割字符串 let str = &#39;abc/def/123&#39; console.log(str.split(&#39;/&#39;)); // [&quot;abc&quot;,&quot;def&quot;,&quot;123&quot;] replace替换字符为 let str = &#39;abc/def/123&#39; console.log(str.replace(/\\W/g, &#39;-&#39;)); // abc-def-123 正则方法test检测字符串是否符合要求，返回值是一个布尔值 exec不使用全局匹配与match相同，使用全局匹配会匹配完全部字符串，返回结果是一个可迭代对象 let reg = /&lt;(h[1-6])&gt;[\\s\\S]+&lt;\\/\\1&gt;/g let str = `&lt;h1&gt;前段小枫&lt;/h1&gt; &lt;h2&gt;blog.easyremember.cn&lt;/h2&gt;` console.log(reg.exec(str)); console.log(reg.exec(str)); 断言?=exp相当于if，但是是后置的例如 &lt;main&gt; 中国努力建设有中国特色社会主义&lt;/main&gt; &lt;script type=&quot;text/javascript&quot;&gt; let reg = /中国(?=特色)/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) &lt;/script&gt; ?&lt;=exp前置断言 let reg = /(?&lt;=有)中国/ let str = document.querySelector(&#39;main&#39;) str.innerHTML = str.innerHTML.replace(reg, &#39;&lt;a href=&quot;&quot;&gt;中国&lt;/a&gt;&#39;) 效果跟前面的?=效果是一样的 ?!exp后面不能出现exp匹配到的内容 ?&lt;!exp前面不能出现exp匹配到的内容","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"let、const和var的区别","slug":"let、const和var","date":"2020-08-02T11:09:59.170Z","updated":"2020-08-02T11:11:39.247Z","comments":true,"path":"2020/08/02/let、const和var/","link":"","permalink":"https://fengjing95.github.io/2020/08/02/let、const和var/","excerpt":"","text":"let、const和var作用域var作用于全局，先来看一个例子 for (var i = 0; i &lt; 5; i++) { var a = 1; } console.log(a, i); // 1 5 跳出了for循环之外a依旧可以访问，用于控制循环的i也能够访问，i=5循环跳出，所以i是5 再来看一下把var改成const for (var i = 0; i &lt; 5; i++) { const a = 1; } console.log(a, i); // Uncaught ReferenceError: a is not defined 这时a是块级作用域，除了循环之后就访问不到了，再来看i，把i改成const声明 Uncaught TypeError: Assignment to constant variable. const属于常量，赋值之后不能改变，这里应该用let，let是变量 重复声明var b = 1; var b = 2; console.log(b); // 2 用var可以重复声明，再来试一下const const b = 1; const b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 可以看出const不可以重复声明，再来试一下let let b = 1; let b = 2; console.log(b); // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared 由此可以看出，const和let不可以重复声明 总结cosnt和let是ES6新出的块级作用域，不可以重复声明，此外 const b; b = 2; console.log(b); // Uncaught SyntaxError: Missing initializer in const declaration const不可以先声明后赋值，let可以 上面说到const不可以重新赋值，有一种情况例外 const b = { a: &#39;a&#39; }; b.a = &#39;b&#39;; console.log(b); 来看一下结果 可以看到值已经发生了改变","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Less预编译使用","slug":"Less预编译","date":"2020-08-02T06:11:51.895Z","updated":"2020-08-02T06:13:59.998Z","comments":true,"path":"2020/08/02/Less预编译/","link":"","permalink":"https://fengjing95.github.io/2020/08/02/Less预编译/","excerpt":"","text":"less预编译1 初见lessless是一门向后兼容的 CSS 扩展语言。 HTML标签不能直接识别less样式，需要引入less.js来编译 引入样式文件 &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt; 引入编译脚本 &lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 但是，这种方式是运行时编译，不是预编译，在VSCode插件商店中搜索less下载对应的编译插件 每次保存less文件时就可以自动编译出css文件 2 less语法2.1 注释less有两种注释 常规的css注释 /* 可见注释，会被编译到css文件中 */ 编译后不可见注释 // 不可见注释，不会被编译到css文件中 2.2 变量使用@符号声明变量，样式中可以引用，less的变量都是块级作用域，直接上代码，一目了然 less块级作用域：首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承 @width: 10px; @height: @width + 10px; .box { width: @width; height: @height; } 编译结果为 属性名和选择器也可以用变量，但是在引用的时候需要用 {}包裹起来，上代码 @width: 10px; @height: @width + 10px; @m: margin; @selector: #nav; .box { @{m}: 10px; width: @width; height: @height; } @{selector} { color: red; } 来看下编译后的，属性和选择器引用很少使用 变量延迟加载 .over { @var: 1; .three { @var: 2; brass: @var; @var: 3; } one: @var; } one属性是在over作用域中的，跟brass无关，所以one的值是1；在brass作用域中，要等变量先加载完再引用，这就是延迟加载，所以three的值是3 2.3 嵌套前面的代码已经能够体现嵌套规则了，可以根据HTML的层级关系来嵌套css样式，伪类选择器也是可以嵌套的 .box { width: @width; height: @height; background-color: pink; :hover { background-color: deeppink; } } 编译结果是这样的 注意这里多了一个空格，这样是不生效的，那怎么样去掉这个空格呢，使用&amp;取消父子关系，让两个类挨在一起 .box { width: @width; height: @height; background-color: pink; &amp;:hover { background-color: deeppink; } } 再来看结果 空格没了 2.3.1 @嵌套和冒泡@ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变 例如 .component { width: 600px; @media (min-width: 768px) { width: 300px; @media (min-resolution: 192dpi) { background-image: url(/img/retina2x.png); } } @media (min-width: 1280px) { width: 800px; } } 这段代码在component类中嵌套了三个媒体查询，编译之后media会编译到最外层 2.4 混合2.4.1 混合混合就是将一系列属性从一个规则集引用到另一个规则集的方式，简单来说已定义的类可以在另一个类中进行引用 .border { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 结果 引用混合的时候，混合没有参数时，括号可以加也可以不加；混合需要使用默认参数时，括号必须加 2.4.2 不编译的混合如果只想定义一个混合，在选择其后面加一个括号，那么这个混合不会被编译 .border() { border-bottom: solid 2px #000; } .border-2 { .border(); color: red; } 编译结果只有.border-2这个类 2.4.3 带参数的混合类似于js定义方法一样接收参数，然后进行编译（但是，他不叫函数，叫混合） .bar(@w, @h, @color) { width: @w; height: @h; color: @color; } .nav-bar { .bar(100px, 200px, #409eff); } 在引用bar的时候将参数填入，然后进行编译 可以设置参数的默认值，可以传递命名参数 .bar(@w: 10px, @h:10px, @color:green) { width: @w; height: @h; color: @color; } .nav-bar { .bar(@color: #409eff); } 结果 当引用混合的时候不加任何参数就会全部使用默认值 2.4.4 匹配模式根据标识匹配混合，下面定义了4种样式，分别是上右下左边框 .border-style(@_, @w, @h, @c) { border-style: solid; } .border-style(T, @w, @h, @c) { width: @w; height: @h; border-color: @c transparent transparent transparent; } .border-style(R, @w, @h, @c) { width: @w; height: @h; border-color: transparent @c transparent transparent; } .border-style(B, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent @c transparent; } .border-style(L, @w, @h, @c) { width: @w; height: @h; border-color: transparent transparent transparent @c; } .border-3 { .border-style(B, 100px, 100px, #000); } 匹配效果如图 注意代码开始的地方 .border-style(@_, @w, @h, @c) { border-style: solid; } 这一段，@_用来匹配L、R、B、T标识，每次使用匹配模式时自动带上这段公共代码 2.4.5 @arguments@arguments包含传进来的所有参数 .border_arg(@w:30px,@c:red,@sty:solid){ border:@arguments; } .test_arguments{ .border_arg(); } 结果如图 2.5 运算 算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。计算的结果以最左侧操作数的单位类型为准。如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px 到 cm 或 rad 到 % 的转换 @color: #224488 / 2; //结果是 #112244 background-color: #112244 + #111; // 结果是 #223355,#111-&gt;#111111 2.6 转义当需要引入无效的CSS语法或Less不能识别的字符，就需要使用转义字符，在字符串前面加一个 ~，并将需要转义的字符串放在 “” 中 @min768: ~&quot;(min-width: 768px)&quot;; .element { @media @min768 { color: pink; } } // 结果 @media (min-width: 768px) { .element { color: pink; } } 在需要使用cacl()的时候less会自动编译括号里面的东西 使用转义来避免自动编译 .no { height: 100 +20px; width: ~&quot;cacl(200px + 20)&quot;; } 2.7 映射 Less 3.5 版本开始，可以将混合和规则集作为一组值的映射（map）使用 #colors() { primary: blue; secondary: green; } .button { color: #colors[primary]; border: 1px solid #colors[secondary]; } // 结果 .button { color: blue; border: 1px solid green; } 2.8 导入less文件导入可以省略后缀名 @import &quot;main&quot;; // mian.less @import &quot;style.css&quot;; 2.9 继承使用extend函数继承一个类 .middle { margin: 0 auto; } .footer:extend(.middle) { color: pink; } 编译之后的middle类将会变成两个类公共部分，用逗号连接","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"https://fengjing95.github.io/tags/css/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"动态控制输入框数量","slug":"动态控制输入框","date":"2020-08-01T14:00:17.672Z","updated":"2020-08-01T14:01:28.214Z","comments":true,"path":"2020/08/01/动态控制输入框/","link":"","permalink":"https://fengjing95.github.io/2020/08/01/动态控制输入框/","excerpt":"","text":"动态控制输入框在开发中经常会遇到根据情况动态控制输入框的情况，以前都是使用UI框架提供的组件，这次自己动手完成了一个简易的动态输入框 先来上效果 正片开始 加减号使用fontawesome的图标不多做赘述 先来看一下标签 &lt;div id=&quot;upload-problem-outin&quot; v-for=&quot;(item, index) in problem.sample&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.inputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输入样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;outin-style&quot;&gt; &lt;v-textarea v-model=&quot;item.outputSample&quot; :rules=&quot;rule.sampleRule&quot; dense outlined clearable :label=&quot;&#39;输出样例&#39;+(index+1)&quot; /&gt; &lt;/div&gt; &lt;/div&gt; problem.sample是problem对象中的样例相关部分，格式如下 sample: [{ inputSample: &#39;&#39;, outputSample: &#39;&#39; }], 通过v-for遍历sample数组来渲染样例组数，通过数据绑定，控制sample数组的内容来实现样例组数的渲染 再来看一下控制的方法 addSample() { this.problem.sample.push({ inputSample: &#39;&#39;, outputSample: &#39;&#39; }) }, subSample() { if(this.problem.sample.length &lt; 2) { alert(&#39;至少保留一组&#39;) return } this.problem.sample.pop() } 触发增加事件时向原数组追加一个sample对象，触发减少事件时丢掉最后一项，智力有一个判断，即样例数不能少于1 大功告成","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue绑定不到组件","slug":"Vue子路由常见的问题","date":"2020-08-01T10:38:09.001Z","updated":"2020-08-01T10:39:27.068Z","comments":true,"path":"2020/08/01/Vue子路由常见的问题/","link":"","permalink":"https://fengjing95.github.io/2020/08/01/Vue子路由常见的问题/","excerpt":"","text":"Vue子路由常见的问题之前在进行开发的时候遇到了一个很玄学的问题，有一个页面需要设置二级路由，在设置二级路由之后浏览器却出现了报错 路由设置如下 报错信息 在查阅了相关资料之后找到了一种解决办法，component改为conponents 虽然没搞明白原理，先试试再说，浏览器正常不报错，但是！！！ 组件也没加载出来，TnT，这啥啊，治标不治本 然后我发现了这个 由于vue-router版本升级的原因需要手动添加.default来加载组件 原因如下 还有种方法 { path: &#39;back&#39;, name: &#39;back&#39;, component: resolve =&gt; require([&#39;@/components/Admin/Back&#39;], resolve), } 我试了下，我试了下这种方式也没问题，resolve是require的回调 还找到了一种说法 require 是 CommonJS 的模块导入方式，而组件定义时写的 export default 是 ES6 方式，因此require 导入的结果其实是一个含 default 属性的对象，所以 vue 中 component 用这个会报错，而恰好 vue 的命名视图组件注册用 components ，而官方也说了“如果 router-view 没有设置名字，那么默认为 default”，所以这两个default 正好对应起来，于是像楼主所说加了s就不会报错了。而合理的用法应该是 require(‘xxx.vue’).default 或是用 import","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue刷新页面","slug":"Vue页面刷新方法","date":"2020-07-31T14:14:47.733Z","updated":"2020-07-31T23:18:10.761Z","comments":true,"path":"2020/07/31/Vue页面刷新方法/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/Vue页面刷新方法/","excerpt":"","text":"Vue页面刷新方法在编写提交表单的时候，当表单提交上之后清空当前表单 开始的时候我想的是表单提交成功之后data中表单中有关表单内容的变量重新赋空值，但是这样太过麻烦 偶然间在一篇博客中发现可以通过路由跳转当前路由来清空页面 然后就想着搜集一下有没有其他方法，搜集之后总结在这里了 路由跳转this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.go(0) }) 通过this.$router.go(0)来刷新页面 location.reload()也可以实现刷新页面 但是这样或有一个空白的过程 通过空白组件刷新将上传成功之后的回调修改 this.$http.put(`/admin/problem`, newObj).then(res =&gt; { if (res) { this.$message.success(`上传成功`) } }).then(() =&gt; { //初始化界面数据 this.$router.replace({ path: &#39;/admin/back&#39;, name: &#39;back&#39; }) }) 然后创建一个新的空白组件back.vue，script部分如下 // 用于刷新页面，没有实际意义 export default { name: &quot;Back&quot;, data() { this.$router.replace({ path: &#39;/admin/uploadProblem&#39;, name: &#39;UploadProblem&#39; }) return { } } } 效果如下，网上说会有路由的改变过程，我没有发现。。。 provide / inject 组合先修改一下app.vue，通过provide传递reload方法 export default { provide() { return { reload: this.reload() } }, name: &quot;Back&quot;, data() { return { isRouterAlive: true } }, methods: { reload() { this.isRouterAlive = false this.$nextTick(function() { this.isRouterAlive = true }) } } } 在需要重新加载的页面通过 inject: [&#39;reload&#39;],接收方法（网上叫它‘注入依赖’），然后就可以在方法中调用 this.reload()","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"Vue点击切换导航栏样式","slug":"Vue点击切换导航栏样式","date":"2020-07-31T06:09:30.441Z","updated":"2020-07-31T06:16:16.925Z","comments":true,"path":"2020/07/31/Vue点击切换导航栏样式/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/Vue点击切换导航栏样式/","excerpt":"","text":"Vue点击切换导航栏样式导航栏内容如下 &lt;div class=&quot;collapse&quot;&gt; &lt;div class=&quot;links&quot;&gt; &lt;router-link v-for=&quot;link in linkLists&quot; :to=&quot;link.links&quot; :key=&quot;link.id&quot; exact&gt;{{link.show}} &lt;/router-link&gt; &lt;/div&gt; 效果如图 感觉太过简单，就想着加一个激活效果，开始想了很多种方法，但是都存着一定的缺陷，偶然间发现了router-link-active这个东西 可以给激活的router-link添加样式，尝试了一下 在links里面添加样式（使用的less预编译） .links { display: flex; margin-right: auto; a { color: #777; margin: 0 10px; } a:hover { color: #409eff; } .router-link-active { color: #409eff; } } 开始我以为完事了，但是却发现无论怎么切换首页一直处于激活状态，我开始面向百度解决问题 然后我发现了exact exact 是一个单独的属性 正确用法是 &lt;router-link to=&quot;/home&quot; active-class=&quot;bianlan&quot; exact&gt;。 这样，只有当路径刚好是 /home 时才会添加 bianlan 类名，而当路径是 /home/something 时则不会（因为不 exact） 在router-link标签中添加exact属性之后效果完美","categories":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://fengjing95.github.io/tags/vue/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"https://fengjing95.github.io/categories/随想/"}]},{"title":"JS递归、闭包、作用域链","slug":"JS递归、闭包、作用域链","date":"2020-07-31T04:14:58.555Z","updated":"2020-08-02T00:42:52.409Z","comments":true,"path":"2020/07/31/JS递归、闭包、作用域链/","link":"","permalink":"https://fengjing95.github.io/2020/07/31/JS递归、闭包、作用域链/","excerpt":"","text":"JS递归、闭包、作用域链递归常规的递归函数function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } } console.log(func(4)); // 24 这是一个非常常见的递归函数，但是有一种情况会使得此方法出现错误。 var func2 = func; func = null; console.log(func2(4)); 将递归函数赋值给一个变量，然后把原函数赋值为null，这时候再调用就会报错 这是因为function属于引用类型，赋值时通过指针指向原函数，原函数发生改变，调用时就会出错 使用callee在上面的情况下，使用arguments.callee就可以解决，arguments.callee是一个指向正在执行函数的指针，将经典递归做以下改动 function func(number) { if (number &lt;= 1) { return 1; } else { return number * arguments.callee(number - 1); } } console.log(func(4)); //24 使用指针进行递归，无论怎么调用函数都不会出错，但是，在严格模式下使用arguments.callee会报错 命名函数表达式以上两种方法都存在这不同程度的缺陷，使用命名函数表达式可以达到指针的效果，亦可以同时运行在严格模式和非严格模式下 var func2 = (function func(number) { if (number &lt;= 1) { return 1; } else { return number * func(number - 1); } }); var func3 = func2; func2 = null; console.log(func3(4)); 这时依旧可以正常显示结果 闭包 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 上面的递归最后一种方法就可以理解为一个闭包 闭包与变量经典的示例 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function () { return i; } } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } // 10,10,10,10,10,10,10,10,10,10 乍一看好像是for循环中每次循环将0-9赋值给数组的每一项，其实并不是，因为当前的newArray()正在执行，每个函数作用域链都保存着newArray()的活动对象，所以for循环中每次都是引用的同一个变量i，for循环结束之后，i是10，所以每个函数内部的i都是10。 再将返回i的函数包在一个匿名函数中，就可以达到互不影响的效果 function newArray() { var result = new Array(); for (var i = 0; i &lt; 10; i++) { result[i] = function (num: number) { return function () { return num; }; }(i) } return result; } var newArr = newArray(); for (var i = 0; i &lt; 10; i++) { console.log(newArr[i]()); } 结果如下 在for循环中,自调用函数立即执行,获取实时地i赋值给num. 循环结束之后,返回result，在自调用函数执行之后，他的作用域就被销毁了，不会再被其他操作影响 this对象// 非严格模式 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return function () { return this.arg; }; } }; console.log(object.getArg()()); //window 为什么结果会是window呢，来看一下最后一行 // object.getArg()()相当于 var val = object.getArg(); val(); 把getArg返回的方法赋值给了val变量，然后执行函数。因为val在全局中，所以获得的arg是全局中的arg还有一种情况会出现问题 var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return this.arg; } }; object.getArg() // object object.getArg() // object (object.getArg = object.getArg)() // window 第一种方法简单的调用了object的方法；第二种方法引用了object的方法，this对象能够维持；但是第三种是一个赋值语句，赋值语句是有返回值的，也就是等号右边，所以这里引用了方法，但不是object内部而是指向window 从这张图就可以看出赋值语句其实是有返回值的 解决方法 1 传递this指向var arg = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { var _this = this; return function () { return _this.arg; }; } }; console.log(object.getArg()()); 将object的this传递到getArg之内，然后使用这个引用值获取arg 2 箭头函数也就是lambda表达式 var arg: string = &#39;window&#39;; var object = { arg: &#39;object&#39;, getArg: function () { return () =&gt; { return this.arg } } } console.log(object.getArg()()); 箭头函数的一大特点就是不改变this的指向 内存泄漏闭包的缺陷在于会造成内存泄露，当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，比如通过node结点给html元素添加点击事件的时候，当事件添加完之后，存储node结点的变量会一直占用内存，造成内存泄漏 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; 存储divNode的内存将会无法释放也无法使用，怎么解决呢 在添加完事件之后将divNode手动赋值为空 var divNode = document.getElementById(&#39;box&#39;); divNode.onclick = function () { alert(&#39;click&#39;); }; divNode = null; 作用域链作用域 作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。 全局作用域一般全局作用域有以下几种情况 最外层函数和最外层函数外面定义的变量拥有全局作用域 所有未直接定义的变量 所有window对象 函数作用域声明在函数内部的变量，函数作用域一般只有代码片段中可以访问，比如函数内部 例如 function func1(a) { var b = a * 2; function func2(c) { console.log(a, b, c); } func2(b * 2); } func1(2) 这段代码中存在3个作用域 全局作用域，标识符func1 作用域func1，标识符a，b，func2 作用域func2，标识符c 作用域链 由多级作用域连续引用形成的链式结果，掌管一切变量的使用顺序： 先在局部找，没有，就延作用域向父级作用域找。 可以向上搜索，但不可以向下搜索 这种一层一层的关系，就是 作用域链 。","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Express+MySQL实现增删查改","slug":"Express+MySQL实现增删查改","date":"2020-07-28T13:56:38.115Z","updated":"2020-07-28T15:51:38.028Z","comments":true,"path":"2020/07/28/Express+MySQL实现增删查改/","link":"","permalink":"https://fengjing95.github.io/2020/07/28/Express+MySQL实现增删查改/","excerpt":"","text":"Express+MySQL实现增删查改现在Node后台开发在网上找到的资料基本都是用的MongoDB数据库，不太容易找到使用MySQL数据库的资料，所以我整理了一下这篇文章，将会讲解如何使用Express和MySQL来实现CRUD 环境搭建生成器可以直接使用Express生成器自动生成Express工程 $ npm install -g express-generator $ express --view=ejs myapp 手动搭建创建一个项目目录$ npm init 新建app.js入口文件 新建router.js路由文件 创建views文件夹，存放EJS模板文件（student.ejs, editStu.ejs） 新建public公共资源 views文件夹命名不可以是别的，会报错 安装第三方模块$ npm install express --save $ npm install mysql --save $ npm install ejs --save 编写代码编写入口文件实例化、模板引擎设置、静态资源、监听 const express = require(&#39;express&#39;); const app = express(); const stuRoute = require(&#39;/router&#39;) // 设置模板引擎 app.set(&quot;view engine&quot;, &quot;ejs&quot;); // 加载静态资源 app.use(express.static(&#39;public&#39;)); // 使用路由 app.use(stuRoute); // 监听 app.listen(3001, () =&gt; { console.log(&#39;启动成功&#39;); }) 编写路由文件const express = require(&#39;express&#39;); const route = express.Router(); const mysql = require(&#39;mysql&#39;); // 配置数据库,连接池模式 var pool = mysql.createPool({ connectionLimit: 10, // 连接数量 host: &#39;localhost&#39;, // 地址 user: &#39;liuhao&#39;, // 数据库用户名 password: &#39;123456&#39;, // 数据可密码 database: &#39;ssmbuild&#39; // 数据库名 }); route.get(&#39;/student&#39;, (req, res) =&gt; { console.log(&quot;/student:&quot;, req.query); const sql = &#39;select * from books where bookName = ?&#39;; let params = [&#39;java&#39;]; // 根据条件查询信息 pool.getConnection(function (err, connection) { if (err) throw err; // not connected! connection.query(sql, params, function (error, results, fields) { connection.release(); console.log(results); // 将数据传到ejs渲染 res.render(&#39;student&#39;, { res: [] }) if (error) throw error; }); }); }) module.exports = route; 效果展示查询结果 数据库数据 这里可以看到数据已经查询成功 本篇主要讲解mysql模块使用，对数据渲染不再赘述另外修改删除修改一下sql语句和params参数即可，开发时数据库部分一般会单独作为一个模块进行封装 现在大部分开发一般是返回json数据，后期会再进行记录","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"express","slug":"express","permalink":"https://fengjing95.github.io/tags/express/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"思途实训day5","slug":"STDay 5","date":"2020-07-26T13:40:01.320Z","updated":"2020-07-28T14:13:30.586Z","comments":true,"path":"2020/07/26/STDay 5/","link":"","permalink":"https://fengjing95.github.io/2020/07/26/STDay 5/","excerpt":"","text":"Day 5引入js尽量放在body标签的最后，先加载静态标签，再加载js脚本 jQuery表达式必须有分号 jQuery改变元素样式(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); })() click事件$(function () { $(&#39;button&#39;).click(() =&gt; { $(&#39;div&#39;).css({&#39;color&#39;: &#39;red&#39;}); }); }); 导航栏颜色修改 &lt;ul id=&quot;nav-ul&quot; onclick=&quot;navHandle()&quot;&gt; &lt;li id=&quot;li1&quot;&gt;首页&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;所有宝贝&lt;/li&gt; &lt;li id=&quot;li3&quot;&gt;每周一上新&lt;/li&gt; &lt;li id=&quot;li4&quot;&gt;生活馆&lt;/li&gt; &lt;li id=&quot;li5&quot;&gt;特惠&lt;/li&gt; &lt;li id=&quot;li6&quot;&gt;礼品区&lt;/li&gt; &lt;/ul&gt; function navHandle() { var nodeId = window.event.target.id; // console.log(node); $(&#39;#&#39; + nodeId).css({ &#39;color&#39;: &#39;#d62cc0&#39; }).siblings().css({ &#39;color&#39;: &#39;#ffffff&#39; }); } siblings()方法返回被选中元素的同级元素 鼠标经过和移出$(function() { $(&#39;#mouse&#39;).mouseenter(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;red&#39; }); }); }); $(function() { $(&#39;#mouse&#39;).mouseleave(() =&gt; { $(&#39;#mouse&#39;).css({ &#39;background&#39;: &#39;#409eff&#39; }); }); }); 淡入淡出效果$(function() { $(&#39;.b-f-1&#39;).mouseenter(() =&gt; { $(&#39;#black1&#39;).fadeOut(500); }); }); $(function() { $(&#39;.b-f-1&#39;).mouseleave(() =&gt; { $(&#39;#black1&#39;).fadeIn(300); }); }); 滑动效果slideDown、slideUp $(function() { $(&#39;div&#39;).mouseenter(() =&gt; { $(&#39;div&#39;).slideDown(1000); }); }); $(function() { $(&#39;div&#39;).mouseleave(() =&gt; { $(&#39;div&#39;).slideUp(1000); }); }); 总结今天大概复习了一下jQuery，很多东西都忘了，需要再看一下","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day4","slug":"STDay 4","date":"2020-07-24T11:29:57.687Z","updated":"2020-07-28T14:13:32.824Z","comments":true,"path":"2020/07/24/STDay 4/","link":"","permalink":"https://fengjing95.github.io/2020/07/24/STDay 4/","excerpt":"","text":"Day4旋转+透明度div { width: 150px; height: 150px; border-radius: 50%; overflow: hidden; border: solid 3px #409eff; transition: 0.5s; opacity: 0.5; } div:hover { transform: rotate(200deg); opacity: 1; } 今日收获。。。就是个透明opacity 成果","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day3","slug":"STDay 3","date":"2020-07-24T01:17:51.174Z","updated":"2020-07-28T14:13:34.338Z","comments":true,"path":"2020/07/24/STDay 3/","link":"","permalink":"https://fengjing95.github.io/2020/07/24/STDay 3/","excerpt":"","text":"Day 3HTML标签。。。从0开始的那种。。。 css样式通配符选择器* { margin: 0; list-style: none; /* 去掉list圆点 */ text-decoration: none; /* 去掉下划线 */ } 列表右浮动只给父级不给子级背景图片引入背景图片必须设置高度，否则不显示 .binner { /* no-repeat不平铺 */ background: url(../img/TB183NQapLM8KJjSZFBSutJHVXa.jpg) no-repeat; height: 568px; background-size: 100% auto; /* 图片自适应 */ } 行高等于div高度时自动居中.nav-f { width: 660px; height: 120px; position: absolute; left: 168px; line-height: 120px; } 精灵图使用Photoshop信息面板配合精灵图设置图片 比如这张精灵图 .shopping { width: 30px; height: 30px; background: url(../img/icon.png); background-position: -16px -133px; } 引入图片之后将鼠标移至图标左上角，看到位置是X：16，Y：133，将图片位置设置为-16px,-133px，将图片沿着X轴Y轴移动之后，浏览器会自动根据设置的宽高从起点位置裁切","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"JS异步轮询","slug":"异步轮询","date":"2020-07-23T05:50:43.924Z","updated":"2020-07-23T05:52:50.933Z","comments":true,"path":"2020/07/23/异步轮询/","link":"","permalink":"https://fengjing95.github.io/2020/07/23/异步轮询/","excerpt":"","text":"异步轮询异步先来看一个例子 console.log(&#39;start&#39;) setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;) }, 4000) console.log(&#39;end&#39;) 这段代码的执行顺序是什么，你可能想到的结果是 start setTimeout end 但是，js是单线程的，不会因为一个任务而被阻塞，异步操作将会被放到队列中，等主线程执行完第一轮任务，然后再执行队列中的任务 这里稍微扯一下栈和队列 栈（stack） 栈是一种先进后出的数据结构，可以理解为一个桶，先放进的东西在最低下，后放的东西在最外面，外面的取完了之后才能拿出最先放进去的东西； 队列（queue） 队列是一种先进先出的数据结构，可以看做一个管道，先进的先出，后进的后出 回到正题，上面的例子中setTimeout是一个异步操作，被放到了队列中，当主线程执行完成之后再来执行队列中的任务，所以答案应该是 在js的队列中有两种划分，一种是宏任务（macrotask queue），一种是微任务（microtask queue），每一个事件循环（Event Loop）都有一个微任务，会有一个或多个宏任务，每一次事件循环都会首先执行微任务执行完后从宏任务取出一个加入到微任务然后执行，直至队列中所有的任务执行结束 宏任务 script(整体代码) setTimeout setInterval I/O UI交互事件 postMessage MessageChannel setImmediate(Node.js 环境) 微任务 Promise.then Object.observe MutaionObserver process.nextTick(Node.js 环境) Promise异步原理看完了，下面开始Promise let promise = new Promise((resolve, reject) =&gt; { // resolve(&quot;成功&quot;) // reject(&quot;失败&quot;) }) console.log(promise) 先来看一下Promise对象的结构 当没有任何操作的时候，Promise对象的状态时pending，值是undefinded 当在Promise中调用resolve之后，状态变为resolved，值是成功 当调用reject的时候，状态变为rejected，值是失败 pending就是未决，resolve可以理解为成功，reject可以理解为拒绝 Promise的状态是不可逆的，resolve和reject同时出现，先执行的决定状态，后执行的不生效 下面这三种方法可以触发Promise.then的错误方法 throw new Error(‘fail’) reject(‘fail’) 错误操作（默认，类似try/catch） 链式调用console.log(&#39;start&#39;) let promise = new Promise((resolve, reject) =&gt; { console.log(&#39;promise&#39;) resolve(&quot;success&quot;) // reject(&quot;faild&quot;) }).then(value =&gt; { console.log(value+1) return value }, reason =&gt; { console.log(reason) }).then(value =&gt; { console.log(value+2) }, reason =&gt; { console.log(reason) }) console.log(&#39;end&#39;) 打印结果为 Promise会将返回值作为.then()的参数传递下去，而且两个.then是在主线程执行完成之后才执行的，这里被放到了微任务（不是并列的，当执行第一个.then的时候第二个.then才会被放到微任务），如果不调用resolve或者reject，微任务是不创建的 每一个Promise.then也是一个Promise 状态中转let promiseErr = new Promise((resolve, reject) =&gt; { reject(&#39;faild&#39;) }) let promise = new Promise((resolve, reject) =&gt; { resolve(promiseErr) }).then(value =&gt; { console.log(&#39;value:&#39;+value) }, reason =&gt; { console.log(&#39;err:&#39;+reason); }) 这里promise虽然调用了resolve，但是返回的状态却是promiseErr的，所以他的结果是 .then是对它前一个Promise对象的操作 错误捕获这样每一个then都有两个方法，过于繁琐，可以在then中只写成功方法，在最后使用catch方法捕获错误 let promise = new Promise((resolve, reject) =&gt; { resolve() }).then(v =&gt; { console.log(&#39;p1&#39;) throw new Error(&#39;fail&#39;) }).then(v =&gt; { console.log(&#39;p2&#39;) }).catch(err =&gt; { console.log(err) }).then(v =&gt; { console.log(&#39;p3&#39;) }).then(v =&gt; { console.log(&#39;p4&#39;) }) 结果为 有结果可以看出，发生错误的地方到catch之间的代码不会执行，catch返回值也是一个Promise对象 async/await了解了Promise之后，async/await就很容易了，它其实就是Promise的语法糖 async function asyncFunc() { return &quot;asunc&quot; } let result = asyncFunc() console.log(result); 从结果看出，async方法返回的也是一个Promise对象 来看看下面这个例子 function p() { console.log(&#39;p&#39;) } async function func() { await p(); console.log(&#39;OK&#39;) } console.log(&#39;start&#39;) func() console.log(&#39;end&#39;) // start // p // end // OK 用知乎上看到过一个例子来解释，可以将 async function func() { await p(); console.log(&#39;OK&#39;) } 理解为 function func() { return Promise.resolve(p()).then(() =&gt; { console.log(&#39;OK&#39;) }) } console.log(‘OK’)被分配到微任务中等待下一轮轮询 来看一个综合案例 async function async1() { console.log(&#39;async1 start&#39;) await async2() console.log(&#39;async1 end&#39;) } async function async2() { console.log(&#39;async2&#39;) } console.log(&#39;script start&#39;) setTimeout(function () { console.log(&#39;settimeout&#39;) }) async1() new Promise(function (resolve) { console.log(&#39;promise1&#39;) resolve() }).then(function () { console.log(&#39;promise2&#39;) }) console.log(&#39;script end&#39;) 输出结果是 script start async1 start async2 promise1 script end async1 end promise2 settimeout 你做对了么(๑´ㅂ`๑)","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"JS中的闭包","slug":"闭包","date":"2020-07-23T05:28:46.515Z","updated":"2020-07-23T05:36:52.742Z","comments":true,"path":"2020/07/23/闭包/","link":"","permalink":"https://fengjing95.github.io/2020/07/23/闭包/","excerpt":"","text":"​ 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 相信你看了这段鬼话，80%会感到懵逼，看完下面的内容再回来看这句话，相信你就可以理解了。 函数的作用域 在全局环境中定义了title变量和show方法，当执行show方法时，开辟出一块内存，如果在show方法内部调用context是可以正常执行的，当show执行完的时候，show中定义的context变量不被保留，这时外部调用context就会 not defined。 数据的作用默认就是在函数体内 数据向下流动，只会向子级传递，不会向父级传递 当show方法执行完之后，内存被释放，执行多个show方法相当于多次开辟了内存 如果在show方法中再定义一个head方法，再执行，此时的内存结构如图所示，head方法时show方法内部的，show执行时为head开辟一块内存；那多次调用show方法会一直调用那一个head方法么？不是的！！！多次调用show方法会开辟多块内存，他们之间是没有关系的。 这个例子更能清楚的说明，按照常理，第一次调用++n之后变成了2，但是这里第二次调用结果还是2，这就说明了两次调用创建了两次 那么怎么让n一直被使用呢，这时你应该想起来开头有一句话 但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。 当数据一直被使用时就会保留下来，那么怎么让他一直被使用呢？ 将sum方法作为返回值赋值给a，这时候，feng中的数据就会一直被使用，直到a销毁，这时候多次调用a方法，n就会累加 如果再赋值给b，这就又开辟了一块内存，与a无关n又重新开始计算，结果如下： 这时候你又想起了开头还有一句话： 每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址 如果在sum中在添加一个function，这样再执行两次a结果是什么呢？ 你没有看错，其实很简单，这跟之前一样，相当于在a中开辟了两块不相关的内存，那么怎么让m累加呢？也很简单，再把show返回出去 这时再创建b，打印结果依旧是2 3 2 3 利用闭包选择数组区间 由于过滤函数一直在调用between的子函数，所以a，b也被保留了下来 闭包会造成内存泄漏 这段代码的意思是点击div会触发打印descript属性，因为事件处理函数是一直存在的，所以每个item在使用完成之后都会保存，而且都是不同的内存区域，对于复杂对象来说是非常浪费内存的 那么怎么解决闭包带来的内存泄漏呢 在使用完之后给item项赋空值 这样就可以解决不必要的内存浪费","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"思途实训day2","slug":"STDay 2","date":"2020-07-22T08:57:04.870Z","updated":"2020-07-28T14:13:35.489Z","comments":true,"path":"2020/07/22/STDay 2/","link":"","permalink":"https://fengjing95.github.io/2020/07/22/STDay 2/","excerpt":"","text":"Day 2字体选择： 中文：微软雅黑， 宋体，黑体 英文：arial 字体大小： 网页最小字号：12px， 不重要信息 一般用的最小字号：14px 精确抠图解锁原背景，新建图层填充鲜艳的颜色，例如绿色 用魔棒工具选择背景色，调整容差值，右键选择【调整边缘】 调整参数 菱形方格 制作一个这样的菱形方格 用矩形工具选择一个矩形框填充一个颜色，【ctrl】+【T】自由变换，按住shift旋90度 在图层调节描边，内阴影和投影 就可以看到效果图中的样式 图层蒙版将要贴入的图片拖拽至目标图层上方 注意在图层区域要将两图层放在一起 左上角有自动选择，点一下就可以定位图层 在两图层之间按住【alt】+鼠标左键 图层区会变成 显示的样式就会变成 图标绘制 锚点工具使用 首先利用椭圆工具绘制黄色圆形，然后复制两份 利用圆角矩形工具绘制蓝色矩形，绘制完成之后按【A】键选中元素出现锚点，按住【ctrl】用鼠标拖拽锚点成为一个梯形 在梯形内绘制三个圆角矩形，填充背景色构造成镂空的感觉 绘制底座，使用圆角矩形，使用锚点工具选择右上角两个点，【delete】，然后将描边改为白色 使用钢笔工具绘制上面的把手，钢笔工具点击一个点，再点第二个点不要松手，调整弧度至合理，使用上面底座相同的配置即可 钢笔工具在使用的时候如果出现角度很别扭的时候，可以在上一个点调好之后不松手，按住【alt】鼠标移动调节手柄 切图将所有的背景色全部隐藏，用切片工具画出切片区域，存储为web格式","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"思途实训day1","slug":"STDay 1","date":"2020-07-22T07:27:01.446Z","updated":"2020-07-28T14:13:13.761Z","comments":true,"path":"2020/07/22/STDay 1/","link":"","permalink":"https://fengjing95.github.io/2020/07/22/STDay 1/","excerpt":"","text":"Day 1PhotoShop操作快捷键 图层复制：【Ctrl】+【J】 自由变换：【Ctrl】+【T】 画笔工具：【B】，画笔调节：粗——右中括号，细——左中括号 放大：【ctrl】+【space】，缩小：【ctrl】+【alt】+【space】，抓手：【space】 盖印：【ctrl】+【alt】+【shift】+【e】 首选项：【ctrl】+【k】 填充前景色：【alt】+【delete】，填充背景色：【ctrl】+【delete】 移动工具：【v】 编组：【ctrl】+【g】 制作大头像调节图层素材图片 1 复制一个图层（可使用ctrl+j，也可以拖拽图层到下方的新建图层图标） 2 ctrl+t自由变换图层，缩放到合适的比例（按住shift等比缩放） 3 调节新图层透明度，50%-60%合适 4 将两图层下巴对齐 5 在小图层上新建蒙版 6 用黑色画笔将大图层头部涂黑，涂完之后将不透明度调至100%，如果有多余部分使用白色画笔涂回去（硬度调为0） 7 使用裁切工具只保留需要的部分，盖印生成图层 成果图如下 图层修饰 滤镜中点开液化 使用膨胀工具在两眼位置分别点击两下将眼部放大 使用褶皱工具将鼻子和嘴缩小 使用左推工具将脸收一下 如果拖坏了可以使用重建工具将要恢复的地方涂一下 GIF制作窗口打开时间轴，新建帧动画 在图层中控制要显示的帧然后添加关键帧 调节每一帧的时间 导出：存储为web格式，调节为GIF格式 网页设计项目立项——分析市场环境——解决用户痛点 仿照图 自己做的设计图： 渐变色：在选区内添加渐变图层，否则会使整个背景全部渐变 选择多个图层：选中第一个图层，按住shift选中最后一个图层 要选中某一图层的某一部分：先用多边形框选工具选出大致部分，然后ctrl+alt+shift+点击要选中部分的图层","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"思途实训","slug":"思途实训","permalink":"https://fengjing95.github.io/tags/思途实训/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]},{"title":"Typora图片自动上传到图床","slug":"Typora图片自动上传到图床","date":"2020-07-15T11:50:22.787Z","updated":"2020-07-15T13:53:48.283Z","comments":true,"path":"2020/07/15/Typora图片自动上传到图床/","link":"","permalink":"https://fengjing95.github.io/2020/07/15/Typora图片自动上传到图床/","excerpt":"","text":"Typora图片自动上传到图床你是否还在为找不到可靠的图床而烦恼 是否害怕图床网站关闭资源丢失 是否担心资源不能管理而发愁 今天他来了 1 下载安装picGo地址在这里，根据需要的版本进行下载 下载完成后进行安装 安装完之后在桌面右下角图标打开picGo详细界面 2 配置picGo图床+giteepicGo支持多个图床 这里主要说一下gitee新建一个公开的仓库，私有的在相册和Typora无法显示 搜索插件gitee（需要安装Node环境） 据说是两个都可以，我只试过了gitee，安装好之后在上面的图床列表里就会出现gitee图床 这里是配置信息 owner：gitee用户名 repo：gitee仓库名 path：路径，存放到根目录可以不用写 token：gitee个人令牌 message：可以不写 关于gitee个人令牌的获取 点开gitee的设置，在左侧栏找到私人令牌，然后点击生成新令牌 描述可以随便写一下，然后点击确认会生成一个token 将token复制到picGo中就可以了 3 配置Typora+picGo在Typora的偏好设置中将插入图片改为上传图片，上传服务修改为picGo App，并选择到安装目录 点击验证 如果出现false情况，看一下连接中的端口号，然后到picGo的设置中找到Server服务 将端口号修改一致 然后保存，再试一下验证","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"ES6笔记","slug":"ES6笔记","date":"2020-07-15T07:24:55.780Z","updated":"2020-08-02T06:22:10.833Z","comments":true,"path":"2020/07/15/ES6笔记/","link":"","permalink":"https://fengjing95.github.io/2020/07/15/ES6笔记/","excerpt":"","text":"ES6笔记变量let和constvar存在的问题 可以重复声明 无法限制修改 没有块级作用域 ES6新的定义变量 let 不能重复声明 变量，可以修改 块级作用域 const 不能重复声明 常量，不能修改 块级作用域 最大的区别：const一经定义值不能再变 函数箭头函数let show = function(n1,n2) { return n1-n2; } ----------等价-------------- let show = (n1, n2) =&gt; { return n1-n2; } 如果只有一个参数，()可以省略 let show = (n) =&gt; { return n; } --------省略-------- let show = n =&gt; { return n; } 如果只有一个return，{}可以省略 let show = n =&gt; { return 2*n; } -------省略-------- let show = n =&gt; 2*n; 箭头函数的this不会变：this指向的是当前对象，传统的function需要定义一个const that= this才能在里面的函数访问到最外层的this，箭头函数不会改变this指向，也就是说，无需定义that就可以用this访问原来的对象 箭头函数的优势和劣势 参数...args接收参数 命名随意，但必须放到参数最后，用于收集剩余参数 let show = function (a, b, ...args) { alert(a); alert(b); alert(args); } show(14,2,3,4,5); 多余的参数将会由args接收 展开数组 展开后效果跟直接把数组放在那一样 let arr = [1,2,3,4]; show(...arr);// == show(1,2,3,4) ------------------- let arr1=[1,2,3]; let arr2=[4,5,6]; let arr=[...arr1,...arr2]; // == let arr=[1,2,3,4,5,6]; 默认参数let show = function (a, b=5, c=10) { XXX } show(12); 当传的参数只有一个的时候，b默认是5，c默认是10； 当传参数大于一位时，会依次顶替默认参数 解构赋值左右两边结构必须一样 let [a, b, c] = [1,2,3] let {a,b,c} = {a:1,b:2,c:3} 右边必须合法 声明和赋值不能分开 let [a, b] = [5, 12];// 合法 ------------------------ let [a, b]; [a, b] = [5, 12];// 报错，解构赋值声明和赋值不能分开 数组map映射————一个对一个 let arr = [1, 2, 3, 4]; let result = arr.map(item =&gt; item * 2); // result 2,4,6,8 reduce汇总————一堆出来一个 let arr= [12, 8, 9, 16]; let result = arr.reduce( function (tmp, item, index) { return tmp + item; }) function中的三个参数分别是存储的和的中间数、要计算的数、索引 filter过滤器————保留一部分 let arr = [10,3,16,15,21,20]; let result = arr.filter(item =&gt; { if(item % 3 == 0) { return true; } return false; }); alert(result); -------------------------------- // json类型 let arr = [ {name: &#39;tom&#39;, price: 75}, {name: &#39;jerry&#39;, price: 60} ]; let result = arr.filter(item =&gt; { return item.price&gt;65; }); console.log(result); 当filter中的方法返回true的时候数据保留，返回false数据删除 forEach循环（迭代）————每一项进行操作 吧数组中的每一项都放到方法中执行 字符串两个新方法startsWith 匹配前面的字符串，相同返回true，不相同返回false endWith 匹配末尾的字符串，相同返回true，不相同返回false 应用：检测文件后缀 字符串模板字符串拼接 let a = &#39;AScri&#39;; let str = `ECM${a}pt6`; alert(str); // str=ECMAScript6 注意：插入字符串的字符串要用反单引号（数字键盘1左边的那个） 应用，拼接字符串 let html = `&lt;div&gt; &lt;h1&gt;${title}&lt;/h1&gt; &lt;p&gt;${content}&lt;/p&gt; &lt;/div&gt;`; 优势：直接把字符串插到字符串中；可以折行 面向对象语法class User { constructor(name, age) { this.name = name; this.age = age; } showName() { alert(this.name); } showAge() { alert(this.age); } } var user = new User(&#39;Tom&#39;, 18); user.showName(); user.showAge(); 对象创建关键字class，相当于java的类 构造器关键字constructor，相当java的构造函数 方法直接写在class里面，不需要加function 继承class VipUser extends User { constructor(name, age, level) { super(name, age); this.level = level; } showLevel() { alert(this.level); } } var vip = new VipUser(&#39;Tom&#39;, 18, 3); vip.showName(); vip.showAge(); vip.showLevel(); 继承关键字extens，相当于java的继承 构造函数中使用super关键字，调用父类的构造函数 添加新的属性和新的方法 JSON标准写法 只能用双引号 所有名字都必须用引号括起来 { &quot;a&quot;: &quot;abx&quot;, &quot;b&quot;: 12, &quot;c&quot;: true } 格式化为字符串let json = {a: 11, b: 12}; alert(JSON.stringify(json)); JSON.stringify()得到的结果是一个字符串 格式化为JSONlet str = &#39;{&quot;a&quot;: 11, &quot;b&quot;: 12}&#39;; console.log(JSON.parse(str)); JSON.parse()得到的结果是一个json对象，但是，字符串的内容必须符合json格式标准，另外，双引号的外面是单引号 简写属性名简写 let a = 12; let b = 5; let json = {a, b, c: 15}; console.log(json); 当已经存在的值和json属性名一样的时候，可以只写值，不一样的可以按照json格式添加 这里的json指的是json字面量 方法简写 let json = { a: 12, show() { console.log(this.a); } } json.show(); 方法可以只写方法名，省略 function Promise作用：消除异步操作，用同步的方式来写异步代码 异步：操作之间没啥关系，同时进行多个操作；代码复杂 同步：同时只能做一件事，前面的事没干完后面的事不能开始；代码简单 封装ajax（基于jquery） let ajax = new Promise(function (resolve, reject) { $.ajax({ url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); ajax.then(result =&gt; { alert(result); }, err =&gt; { console.log(err); }) Promise.all()当有两个Promise对象时，可以使用Promisr.all()处理两个Promise对象 Promise.all([ ajax1, ajax2 ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 这里注意，当使用.all处理多个Promise对象时，有一个出错就会报错，全部成功才会执行成功的回调函数 有多个ajax请求不同地址的时候可以，再次封装 function createPromise(url) { return new Promise(function(resolve, reject) { $.ajax({ url, dataType: &#39;json&#39;, success(json) { resolve(json); }, error(err) { reject(err); } }) }); } Promise.all([ createPromise(&#39;js/arr.txt&#39;), createPromise(&#39;js/arr2.txt&#39;) ]).then(result =&gt; { let [arr1, arr2] = result; alert(arr1); alert(arr2); }, err =&gt; { console.log(err); }) 以上只是示例，jquery的作者当然想到了这一点，$.ajax()是有返回值的（高版本，低版本可能没有） let p = $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}); 可以将 $.ajax({url: &#39;js/arr.txt&#39;, dataType: &#39;json&#39;}) 放到Promise.all()里面，代替上面的createPromise方法 Promise.race()同时处理多个Promise对象，有一个先完成的就停止 应用场景，同时向多个负载发送请求 Promise链式调用let test = new Promise((resolve, reject) =&gt; { let random = Math.random() if (random &gt; 0.5) { resolve(&#39;大于0.5&#39;) } else { reject(&#39;小于等于0.5&#39;) } }) let p = test.then((result) =&gt; { console.log(result) return result }).catch((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(result) return result }).then((result) =&gt; { console.log(&#39;last&#39;, result) }) console.log(p) ------------------------- Promise { &lt;pending&gt; } // p 大于0.5 // 或者小于，下同 大于0.5 last 大于0.5 promise 的 then 方法里面可以继续返回一个新的 promise 对象 下一个 then 方法的参数是上一个 promise 对象的 resolve 参数 catch 方法的参数是其之前某个 promise 对象的 rejecte 参数 一旦某个 then 方法里面的 promise 状态改变为了 rejected，则promise 方法连会跳过后面的 then 直接执行 catch；如果状态一直为fulfilled，catch里面的的代码不执行 catch 方法里面依旧可以返回一个新的 promise 对象 promies的三种状态是未决的pending（进行中），和已决的fulfilled（成功）/rejected（失败），reslove和reject是成功和失败的参数，在promies里调用参数之后then方法才会执行 参考资料： 深入理解Promise三种状态与链式调用 Promise对象then方法链式调用 生成器函数generator 普通函数：一直执行到最后 generator函数：中间可以暂停 function *show() { alert(&#39;1&#39;); yield; alert(&#39;2&#39;); } let obj = show(); obj.next(); obj.next(); 直接运行show()并不会有任何反应，用show来创建一个对象，用next方法可以执行，遇到yield停下，再执行next可以继续运行之后的部分 原理是把一个大函数的代码切分成多个小函数，每next一次执行一次 一个生成器中可以存在多个yield；注意函数命名方式 function *show(){}，带有星号 yield可以传参 第一个next无法传参，可以理解为generator的启动器，第二个next开始向第一个yield传参 function *show() { alert(&#39;1&#39;); let a = yield; alert(a); } let obj = show(); obj.next(); obj.next(10); -------------------------- // 打印结果 a=10 有返回值 function *show() { alert(&#39;1&#39;); let a = yield &#39;axc&#39; + &#39;ac&#39;; alert(a); // 10 // 如果这里return 55，那么下边b1的value就是55 } let obj = show(); let a1 = obj.next(); console.log(a1); // {value: &quot;axcac&quot;, done: false} let b1 = obj.next(10); console.log(b1); // {value: undifind, done: true} 一个yield相当于一个被分解成小函数的return 总结：第一个yield返回的值给了第一个next，第二个next的参数给了第一个yield 附：ES7 async awaitasync function doSome() { try { let data1 = await function(data); let data2 = await function(data1); let data3 = await function(data2); } catch(err) { console.log(&quot;Error:&quot; + err); } } 用同步的方式实现异步 await的返回值是promise；await后面可以用Promise.all()执行多个Promise操作 awat 外面必须包裹着async， 把await和成功后的操作放到try里，失败的放在catch 参考资料： async和await","categories":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"https://fengjing95.github.io/tags/js/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://fengjing95.github.io/categories/笔记/"}]},{"title":"VS Code 快捷键","slug":"VS Code 快捷键","date":"2020-07-14T07:29:20.384Z","updated":"2020-07-18T11:11:16.205Z","comments":true,"path":"2020/07/14/VS Code 快捷键/","link":"","permalink":"https://fengjing95.github.io/2020/07/14/VS Code 快捷键/","excerpt":"","text":"VS Code 快捷键打开一个新窗口 Ctrl+Shift+N 关闭窗口 Ctrl+Shift+W 新建文件 Ctrl+N 文件之间切换 Ctrl+Tab 复制或剪切当前行/当前选中内容 Ctrl+C 、 Ctrl+V 代码格式化： Shift+Alt+F 上下移动一行 Alt+Up 或 Alt+Down 向上向下复制一行 Shift+Alt+Up 或 Shift+Alt+Down 在当前行下方插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 移动到行首 Home 移动到行尾 End 移动到文件结尾 Ctrl+End 移动到文件开头 Ctrl+Home 移动到定义处 F12 定义处缩略图 只看一眼而不跳转过去 Alt+F12 找到所有的引用 Shift+F12 同时修改本文件中所有匹配的 Ctrl+F12 重命名 比如要修改一个方法名，可以选中后按 F2，输入新名字，回车，则所有该方法的引用也都同步更新了 跳转到下一个 Error 或 Warning 当有多个错误时可以按 F8 逐个跳转 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F","categories":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://fengjing95.github.io/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://fengjing95.github.io/categories/技术/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-14T07:29:20.383Z","updated":"2020-07-15T09:59:41.550Z","comments":true,"path":"2020/07/14/hello-world/","link":"","permalink":"https://fengjing95.github.io/2020/07/14/hello-world/","excerpt":"","text":"2020-07-13 博客诞生","categories":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://fengjing95.github.io/tags/hello/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://fengjing95.github.io/categories/生活/"}]}]}